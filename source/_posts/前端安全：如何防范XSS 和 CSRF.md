---
title: 前端安全：如何防范 XSS 和 CSRF
date: 2021-06-25 22:47:32
tags: 安全
swiper: true
swiperDesc: '什么是 XSS 攻击？如何防范 XSS 攻击？</br>
什么是 CSRF 攻击？如何防范 CSRF 攻击？
'
categories: 前端
---
{% title h2, 什么是 XSS 攻击？如何防范 XSS 攻击？ %}


XSS 攻击指的是跨站脚本攻击，是一种`代码注入攻击`。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 `cookie` 等。

XSS 的本质是因为`网站没有对恶意代码进行过滤`，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。

而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。

{% p primary, XSS 一般分为存储型、反射型和 DOM 型。 %}


存储型指的是恶意代码提交到了网站的数据库中，当用户请求数据的时候，`服务器将其拼接为 HTML 后返回给了用户`，从而导致了恶意代码的执行。

反射型指的是攻击者构建了特殊的 URL，当服务器接收到请求后，从 `URL 中获取数据，拼接到 HTML 后返回`，从而导致了恶意代码的执行。

DOM 型指的是攻击者构建了特殊的 URL，用户打开网站后，`js 脚本从 URL 中获取数据，从而导致了恶意代码的执行`。
{% p primary, XSS 攻击的预防可以从两个方面入手，一个是恶意代码提交的时候，一个是浏览器执行恶意代码的时候。 %}


对于第一个方面，如果我们对存入数据库的数据都进行的转义处理，但是一个数据可能在多个地方使用，有的地方可能不需要转义，由于我们没有办法判断数据最后的使用场景，`所以直接在输入端进行恶意代码的处理，其实是不太可靠的`。

因此我们可以从`浏览器的执行来进行预防`，一种是使用纯前端的方式，不用服务器端拼接后返回。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，我们对于`数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码`情况进行判断。

在使用 `.innerHTML`、`.outerHTML`、`document.write()` 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 `.textContent`、`.setAttribute()` 等。

如果用 Vuet 技术栈，并且不使用 `v-html`功能，就在前端 render 阶段避免 `innerHTML`、`outerHTML` 的 XSS 隐患。

DOM 中的内联事件监听器，如 `location`、`onclick`、`onerror`、`onload`、`onmouseover` 等，`<a>` 标签的 `href` 属性，JavaScript 的 `eval()`、`setTimeout()`、`setInterval()` 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。

```
<!-- 内联事件监听器中包含恶意代码 -->
<img onclick="UNTRUSTED" onerror="UNTRUSTED" src="data:image/png,">

<!-- 链接内包含恶意代码 -->
<a href="UNTRUSTED">1</a>

<script>
// setTimeout()/setInterval() 中调用恶意代码
setTimeout("UNTRUSTED")
setInterval("UNTRUSTED")

// location 调用恶意代码
location.href = 'UNTRUSTED'

// eval() 中调用恶意代码
eval("UNTRUSTED")
</script>

```

**输入内容长度控制**

对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。

**HTTP-only Cookie**

禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。

**验证码**

防止脚本冒充用户提交危险操作。

**检测**

 只要在网站的各输入框中提交这个字符串，或者把它拼接到 URL 参数上，就可以进行检测了

```
http://xxx/search?keyword=jaVasCript%3A%2F*-%2F*%60%2F*%60%2F*%27%2F*%22%2F**%2F(%2F*%20*%2FoNcliCk%3Dalert()%20)%2F%2F%250D%250A%250d%250a%2F%2F%3C%2FstYle%2F%3C%2FtitLe%2F%3C%2FteXtarEa%2F%3C%2FscRipt%2F--!%3E%3CsVg%2F%3CsVg%2FoNloAd%3Dalert()%2F%2F%3E%3E
```

{% title h2, 什么是 CSRF 攻击？如何防范 CSRF 攻击？ %}
CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被
攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。
CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。

**一个典型的CSRF攻击有着如下的流程：**

- [受害者登录a.com](http://xn--a-f38al5vkzdt61bv7l.com)，并保留了登录凭证（Cookie）。

- [攻击者引诱受害者访问了b.com](http://xn--b-nv6ao4io8bp6po6e00mu47cda4311avpa330h.com)。

- [b.com](http://b.com) 向 [a.com](http://a.com) 发送了一个请求：[a.com/act=xx。浏览器会…](http://a.com/act=xx。浏览器会默认携带a.com的Cookie。)

- a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。

- a.com以受害者的名义执行了act=xx。

- 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。

  **CSRF的特点**

  - 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。
  - 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。
  - 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。
  - 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。

  CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。

一般的 CSRF 攻击类型有三种：
{% p primary, 第一种是 GET 类型的 CSRF 攻击 %}
比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。
{% p primary, 第二种是 POST 类型的 CSRF 攻击 %}
比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。
{% p primary, 第三种是链接类型的 CSRF 攻击 %}
比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。

CSRF 可以用下面几种方法来防护：
{% p success, 第一种是同源检测的方法 %}
服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。
{% p success, 第二种方法是使用 CSRF Token 来进行验证 %}
服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。
{% p success, 第三种方式使用双重 Cookie 验证的办法 %}
服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。
{% p success, 第四种方式是使用在设置 cookie 属性的时候设置 Samesite %}
 限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。