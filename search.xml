<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>react+ts仿jira笔记</title>
      <link href="/2023/04/06/react-ts-fang-jira-bi-ji/"/>
      <url>/2023/04/06/react-ts-fang-jira-bi-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Devtools提供了过程截屏的能力, 用户可以直观地看到页面的选过程</span><br><span class="line">切换至network面板, 点击setting按钮后勾选Capture screenshots, 这样在刷新页面的同时浏览器会自动吧关键帧的截屏保留下来</span><br></pre></td></tr></table></figure><h3 id="vite-build"><a href="#vite-build" class="headerlink" title="vite build"></a>vite build</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">托管dist文件</span><br><span class="line"></span><br><span class="line">cd dist</span><br><span class="line">npx static-server -z</span><br></pre></td></tr></table></figure><h3 id="performance-API"><a href="#performance-API" class="headerlink" title="performance API"></a>performance API</h3><h4 id="perfomance-now"><a href="#perfomance-now" class="headerlink" title="perfomance.now()"></a>perfomance.now()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">performance.now()</span><br><span class="line">精度精确到微秒</span><br><span class="line">获取的是把页面打开时间点作为基点的相对时间, 不依赖操作系统的时间</span><br></pre></td></tr></table></figure><h3 id="度量首屏"><a href="#度量首屏" class="headerlink" title="度量首屏"></a>度量首屏</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FP(first paint) 第一次绘制时间</span><br><span class="line">FCP(first contentful paint) 第一次绘制出DOM元素的时间</span><br><span class="line">FMP(first meaningful paint) 第一次有意义的绘制(主观) , 替代方案LCP</span><br><span class="line">TTI(time to interaction) 可交互时间</span><br></pre></td></tr></table></figure><h3 id="度量流畅度的指标"><a href="#度量流畅度的指标" class="headerlink" title="度量流畅度的指标"></a>度量流畅度的指标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FPS 每秒传输帧数, 达到60fps就会让用户感觉到非常流畅</span><br><span class="line">使用requestAnimationFrame</span><br><span class="line">FPS降低的根本原因是UI线程被阻塞, 而这种阻塞是由一些长时间未能完成的长任务导致的, 如长时间的js任务执行或代价高昂的浏览器重绘</span><br><span class="line">使用Long Task API 可以定位这些阻塞UI线程的长任务</span><br><span class="line"></span><br><span class="line">const oberver = new PerformanceObserver((list) =&gt; &#123;</span><br><span class="line">    const perfEntries = list.getEntries()</span><br><span class="line">    for (let i = 0; i &lt; perfEntries.length; i++) &#123;</span><br><span class="line">      // 处理长任务, 一般大于50ms会被统计</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  oberver.observe(&#123; entryTypes: [&#x27;longtask&#x27;], buffered: true &#125;)</span><br></pre></td></tr></table></figure><h3 id="最佳实践-Core-Web-Vitals"><a href="#最佳实践-Core-Web-Vitals" class="headerlink" title="最佳实践 Core Web Vitals"></a>最佳实践 Core Web Vitals</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LCP: 首屏视图中最大的元素的渲染时间</span><br><span class="line">浏览器会持续探测页面中占用最大的元素, 这个元素可能会在加载过程中发生变化(如出现了占用体积更大的元素), 直到页面完全加载后, 才会把最终占用面积最大的元素的渲染时间定为LCP探测的元素</span><br><span class="line">LCP是按照元素的渲染完成时间测算的, 如果一个大的图片只是在面积上占用了最大的空间, 但是还没有加载好, 那么浏览器仍然会把当前的LCP元素指向另外一个较小但是已经渲染好的元素</span><br><span class="line">LCP的特点: 更贴近用户体验的首屏, 可以自动测算, 可以解释</span><br></pre></td></tr></table></figure><h3 id="TTFB"><a href="#TTFB" class="headerlink" title="TTFB"></a>TTFB</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指客户端从发起请求到接收到服务器响应的第一个字节的时间, 能够在前端比较客观的反应后端的耗时</span><br></pre></td></tr></table></figure><h3 id="图片使用-base64-的优缺点"><a href="#图片使用-base64-的优缺点" class="headerlink" title="图片使用 base64 的优缺点"></a>图片使用 base64 的优缺点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">可以减少一个图片请求的开支</span><br><span class="line"></span><br><span class="line">缺点</span><br><span class="line">base64会导致图片的体积增大1/3左右</span><br><span class="line">HTML中内联的图片在多次请求之间无法复用缓存</span><br><span class="line">客户端解析base64是需要时间的</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="WebPageTest"><a href="#WebPageTest" class="headerlink" title="WebPageTest"></a>WebPageTest</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WebPageTest是常用的线上性能分析工具, 能对线上的页面进行性能分析, 生成的报告也非常丰富, 除了自身的分析报告, 还包括DevTools timeline, lighthouse报告, 视频对比等.</span><br><span class="line"></span><br><span class="line">https://www.webpagetest.org/</span><br><span class="line"></span><br><span class="line">Start Render: 开始渲染时间, 既非白屏时间</span><br></pre></td></tr></table></figure><h3 id="RTT"><a href="#RTT" class="headerlink" title="RTT"></a>RTT</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Round-Trip Time 往返延迟</span><br><span class="line">指的是从发送端发送数据开始, 到发送端收到来自接收端的确认的时间, 即一来一回的时间, 一般来说, 这个时间由物理距离, 网络传输路径等决定</span><br><span class="line"></span><br><span class="line">在Ping的时候看到的time=xxms, 大致是1个RTT</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="TCP-的连接"><a href="#TCP-的连接" class="headerlink" title="TCP 的连接"></a>TCP 的连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">客户端向服务器发送SYN, 传输seq=X</span><br><span class="line">服务端向客户端发送ACK X+1, 表示收到, 客户端可以将X+1作为seq发送消息, 同时发送SYN, seq=Y, 把自己设置为established状态(可接受数据)</span><br><span class="line">客户端向服务器发送ACK Y+1, 表示收到, 服务器端可以将Y+1作为seq发送消息, 把自己设置为established</span><br><span class="line"></span><br><span class="line">客户端发送完ACK后就认为连接已经建立完毕(而不是等待服务器端收到这个ACK), 并开始传输应用层数据, 服务器收到这个ACK后才会开始把收到的数据交付给应用层</span><br><span class="line"></span><br><span class="line">http1/1/1 TCP建立连接的时间就是一个RTT</span><br><span class="line">htts 还需要加上SSL的时间</span><br><span class="line"></span><br><span class="line">优化: preconnect</span><br></pre></td></tr></table></figure><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用同一个秘钥进行加密和解密</span><br><span class="line"></span><br><span class="line">优点是简单</span><br><span class="line">不安全, 服务器想要保证传输的数据安全, 就得先把密钥传输过来, 而发送密钥的过程本身是不安全的</span><br></pre></td></tr></table></figure><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有一组密钥 分为公钥和私钥 私钥只能一人保管, 公钥可以公布给任何人</span><br><span class="line"></span><br><span class="line">非对称加密算法的加密和解密是用不同的密钥完成的, 也就是说, 私钥加密后的内容可以被公钥的持有者解密, 而公钥加密后的内容只有私钥的持有者能解密</span><br></pre></td></tr></table></figure><h3 id="SSL-TSL-握手"><a href="#SSL-TSL-握手" class="headerlink" title="SSL/TSL 握手"></a>SSL/TSL 握手</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户端校验服务器端的证书</span><br><span class="line">协商生成对称加密使用的密钥</span><br><span class="line"></span><br><span class="line">需要两个RTT</span><br></pre></td></tr></table></figure><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">就http/2而已, 其提高性能的主要手段有, 连接复用, 头部压缩和Server Push</span><br><span class="line"></span><br><span class="line">连接复用</span><br><span class="line">http/1.1 支持Keep-Alive</span><br><span class="line">Keep-Alive用来表示申请服务器端在响应后仍然保持连接. 服务器端可以控制保持连接的时间, 一般为15s, 其实这里复用的并不是http连接, 而是迭戈http请求复用tcp连接</span><br><span class="line"></span><br><span class="line">队头阻塞</span><br><span class="line">由于http请求-响应是一一对应的, 使用同一个连接发送多个http请求会产生队头阻塞问题, 即第二个请求需要等待第一个请求返回后才能发起</span><br><span class="line"></span><br><span class="line">http/2对此提出了更根本的解决方案, 即让http在单个TCP连接内可以发送多个请求, 并且可以乱序返回</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Server-Push"><a href="#Server-Push" class="headerlink" title="Server Push"></a>Server Push</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">服务端需要在响应html时返回一个PUSH_PROMISE帧, 同时把需要推送的内容的html一起返回给客户端, 当客户端试图加载css时, 可以根据PUSH_PROMISE帧的ID读取到对应的流</span><br><span class="line"></span><br><span class="line">Swever Push 无法有效的和本地缓存复用</span><br><span class="line">无法从第三方推送</span><br><span class="line">Server Push 无法从第三方服务器进行推送, 为了尽快发送内容而放弃了CDN在静态资源托管性能上的优势, 往往是得不偿失的</span><br><span class="line"></span><br><span class="line">折中方案</span><br><span class="line">用户通过Cookie去猜测</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="http-3"><a href="#http-3" class="headerlink" title="http/3"></a>http/3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">无论是http/1还是http/2, 都是基于TCP协议的, 这意味着有一些由TCP协议带来的问题很难得到解决</span><br><span class="line"></span><br><span class="line">http2的队头阻塞问题</span><br><span class="line">TCP是可靠传输协议, 虽然两个请求在http层面是乱序的, 但是如果前面的请求出现了丢包, 那么TCP协议必须等待重传的宝按照次序读取出来, 这就是http2的队头阻塞问题</span><br></pre></td></tr></table></figure><h3 id="压缩和缓存"><a href="#压缩和缓存" class="headerlink" title="压缩和缓存"></a>压缩和缓存</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">br压缩比gzip压缩的效果更显著, 但是也会增加服务器端处理耗时</span><br><span class="line"></span><br><span class="line">accept-encoding, content-encoding</span><br></pre></td></tr></table></figure><h3 id="内存泄漏和性能"><a href="#内存泄漏和性能" class="headerlink" title="内存泄漏和性能"></a>内存泄漏和性能</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当页面中出现了比较严重的内存泄漏时, 会产出一下两个结果</span><br><span class="line">内存总是不够, 导致垃圾回收频繁被触发</span><br><span class="line">内存中存在大量对象, 导致垃圾回收算法本身执行得更加缓慢</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuejs设计与实现</title>
      <link href="/2023/03/13/vuejs-she-ji-yu-shi-xian/"/>
      <url>/2023/03/13/vuejs-she-ji-yu-shi-xian/</url>
      
        <content type="html"><![CDATA[<h3 id="模板的工作原理"><a href="#模板的工作原理" class="headerlink" title="模板的工作原理"></a>模板的工作原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">渲染器: 把虚拟DOM渲染为真实的DOM</span><br><span class="line">组件: 一组DOM元素的封装, 这组DOM元素就是要渲染的内容</span><br><span class="line">编译器: 将模板编译为渲染函数</span><br><span class="line">Vue3的渲染器和编译器可以进行信息传递(通过虚拟DOM)</span><br></pre></td></tr></table></figure><h3 id="响应式系统的作用与实现"><a href="#响应式系统的作用与实现" class="headerlink" title="响应式系统的作用与实现"></a>响应式系统的作用与实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">响应式数据: 当值变化后, 副作用函数自动重新执行</span><br><span class="line"></span><br><span class="line">// 简易实现</span><br><span class="line">const bucket = new WeakMap()</span><br><span class="line"></span><br><span class="line">let activeEffect</span><br><span class="line"></span><br><span class="line">const data = &#123; text: &#x27;hello world&#x27; &#125;</span><br><span class="line"></span><br><span class="line">function track(target, key) &#123;</span><br><span class="line">  if (!activeEffect) return</span><br><span class="line">  let depsMap = bucket.get(target)</span><br><span class="line">  if (!depsMap) &#123;</span><br><span class="line">    bucket.set(target, (depsMap = new Map()))</span><br><span class="line">  &#125;</span><br><span class="line">  let deps = depsMap.get(key)</span><br><span class="line">  if (!deps) &#123;</span><br><span class="line">    depsMap.set(key, (deps = new Set()))</span><br><span class="line">  &#125;</span><br><span class="line">  deps.add(activeEffect)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function trigger(target, key) &#123;</span><br><span class="line">  const depsMap = bucket.get(target)</span><br><span class="line">  if (!depsMap) return</span><br><span class="line">  const effects = depsMap.get(key)</span><br><span class="line">  if (!effects) return</span><br><span class="line">  effects.forEach((fn) =&gt; fn())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj = new Proxy(data, &#123;</span><br><span class="line">  get(target, key) &#123;</span><br><span class="line">    track(target, key)</span><br><span class="line">    return target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  set(target, key, value) &#123;</span><br><span class="line">    target[key] = value</span><br><span class="line">    trigger(target, key)</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function effect(fn) &#123;</span><br><span class="line">  activeEffect = fn</span><br><span class="line">  fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">effect(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;effect run&#x27;)</span><br><span class="line">  document.body.innerHTML = obj.text</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  obj.notExist = &#x27;error&#x27;</span><br><span class="line">  obj.text = &#x27;text&#x27;</span><br><span class="line">&#125;, 1000)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分支切换和-cleanup"><a href="#分支切换和-cleanup" class="headerlink" title="分支切换和 cleanup"></a>分支切换和 cleanup</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">每次副作用函数执行时, 我们可以先把它从所有与之相关联的依赖集合中删除, 当副作用函数执行完毕后, 会重新建立联系, 在新的联系中, 不会包含遗留的副作用函数</span><br><span class="line"></span><br><span class="line">function effect(fn) &#123;</span><br><span class="line">  // activeEffect = fn</span><br><span class="line">  // fn()</span><br><span class="line">  const effectFn = () =&gt; &#123;</span><br><span class="line">    cleanup(effectFn)</span><br><span class="line">    activeEffect = fn</span><br><span class="line">    fn()</span><br><span class="line">  &#125;</span><br><span class="line">  effectFn.deps = []</span><br><span class="line">  effectFn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cleanup(effectFn) &#123;</span><br><span class="line">  for (let i = 0; i &lt; effectFn.deps.length; i++) &#123;</span><br><span class="line">    const deps = effectFn.deps[i]</span><br><span class="line">    deps.delete(effectFn)</span><br><span class="line">  &#125;</span><br><span class="line">  effectFn.deps.length = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在调用forEach遍历Set集合时, 如果一个值已经被访问过了, 但该值被删除重新添加到集合, 如果此时forEach遍历没有结束, 那么改值会重新被访问.</span><br><span class="line">&#123;</span><br><span class="line">  set.delete(1)</span><br><span class="line">  set.add(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套的-effect-与-effect-栈"><a href="#嵌套的-effect-与-effect-栈" class="headerlink" title="嵌套的 effect 与 effect 栈"></a>嵌套的 effect 与 effect 栈</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">我们用全局变量activeEffect来存储effect函数注册的副作用函数, 这意味着同一时刻, activeEffect所存储的副作用函数只能有一个, 当副作用函数发生嵌套时, 内层副作用函数的执行会覆盖activeEffect的值, 并且永远不会恢复</span><br><span class="line"></span><br><span class="line">function effect(fn) &#123;</span><br><span class="line">  const effectFn = () =&gt; &#123;</span><br><span class="line">    cleanup(effectFn)</span><br><span class="line">    activeEffect = effectFn</span><br><span class="line">    effectStack.push(effectFn) // add</span><br><span class="line">    fn()</span><br><span class="line">    effectStack.pop() // add</span><br><span class="line">    activeEffect = effectStack.at(-1) // add</span><br><span class="line">  &#125;</span><br><span class="line">  effectFn.deps = []</span><br><span class="line">  effectFn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="避免无限递归循环"><a href="#避免无限递归循环" class="headerlink" title="避免无限递归循环"></a>避免无限递归循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">effect(() =&gt; obj.foo++) // 既读取obj.foo的值, 又会设置obj.foo的值</span><br><span class="line"></span><br><span class="line">解决方法</span><br><span class="line">在trigger动作发生时增加守卫条件: 如果trigger触发执行的副作用函数与当前正在执行的副作用函数相同, 则不触发执行</span><br><span class="line"></span><br><span class="line">const effectsToRun = new Set()</span><br><span class="line">  effects.forEach((effectFn) =&gt; &#123;</span><br><span class="line">    if (effectFn !== activeEffect) &#123;</span><br><span class="line">      effectsToRun.add(effectFn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="调度执行"><a href="#调度执行" class="headerlink" title="调度执行"></a>调度执行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">调度执行是指当trigger动作触发副作用函数重新执行时, 有能力决定副作用函数执行的时机, 次数, 以及方式</span><br><span class="line"></span><br><span class="line">用户在调用effect函数注册副作用函数时, 可以传递第二个参数options, 它是一个对象, 其中允许指定scheduler调度函数</span><br><span class="line"></span><br><span class="line">effectsToRun.forEach((effectFn) =&gt; &#123;</span><br><span class="line">    const &#123; scheduler &#125; = effectFn.options</span><br><span class="line">    if (scheduler) &#123;</span><br><span class="line">      scheduler(effectFn)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      effectFn()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="计算属性-computed-和-lazy"><a href="#计算属性-computed-和-lazy" class="headerlink" title="计算属性 computed 和 lazy"></a>计算属性 computed 和 lazy</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">export function effect(fn, options = &#123;&#125;) &#123;</span><br><span class="line">  // activeEffect = fn</span><br><span class="line">  // fn()</span><br><span class="line">  const effectFn = () =&gt; &#123;</span><br><span class="line">    cleanup(effectFn)</span><br><span class="line">    activeEffect = effectFn</span><br><span class="line">    effectStack.push(effectFn)</span><br><span class="line">    const res = fn()</span><br><span class="line">    effectStack.pop()</span><br><span class="line">    activeEffect = effectStack.at(-1)</span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line">  effectFn.options = options</span><br><span class="line">  effectFn.deps = []</span><br><span class="line">  if (!options.lazy) &#123;</span><br><span class="line">    effectFn()</span><br><span class="line">  &#125;</span><br><span class="line">  return effectFn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const computed = (getter) =&gt; &#123;</span><br><span class="line">  let value</span><br><span class="line">  let dirty = true</span><br><span class="line">  const effectFn = effect(getter, &#123;</span><br><span class="line">    scheduler() &#123;</span><br><span class="line">      dirty = true</span><br><span class="line">      trigger(obj, &#x27;value&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    lazy: true</span><br><span class="line">  &#125;)</span><br><span class="line">  const obj = &#123;</span><br><span class="line">    get value() &#123;</span><br><span class="line">      if (dirty) &#123;</span><br><span class="line">        value = effectFn()</span><br><span class="line">        dirty = false</span><br><span class="line">      &#125;</span><br><span class="line">      track(obj, &#x27;value&#x27;)</span><br><span class="line">      return value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="watch-的实现原理"><a href="#watch-的实现原理" class="headerlink" title="watch 的实现原理"></a>watch 的实现原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">所谓watch本质就是观测一个响应式数据, 当数据发生变化时通知并执行响应的回调函数, 利用了effect以及options.scheduler选项</span><br><span class="line">newValue, oldValue, 使用了lazy选项</span><br><span class="line">竟态问题: watch函数的回调函数接受第三个参数, onInvalidate, 它是一个函数, 在当前副作用函数过期后执行, 按序发送a, b两个请求, b先返回, 则a过期</span><br><span class="line"></span><br><span class="line">export const watch = (source, cb, options = &#123;&#125;) =&gt; &#123;</span><br><span class="line">  let getter</span><br><span class="line">  if (typeof source === &#x27;function&#x27;) &#123;</span><br><span class="line">    getter = source</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    getter = () =&gt; traverse(source)</span><br><span class="line">  &#125;</span><br><span class="line">  let newValue, oldValue</span><br><span class="line">  let cleanup</span><br><span class="line"></span><br><span class="line">  const onInvalidate = (fn) =&gt; &#123;</span><br><span class="line">    cleanup = fn</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const job = () =&gt; &#123;</span><br><span class="line">    newValue = effectFn()</span><br><span class="line">    if (cleanup) &#123;</span><br><span class="line">      cleanup()</span><br><span class="line">    &#125;</span><br><span class="line">    cb(newValue, oldValue, onInvalidate)</span><br><span class="line">    oldValue = newValue</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const effectFn = effect(() =&gt; getter(), &#123;</span><br><span class="line">    lazy: true,</span><br><span class="line">    scheduler: () =&gt; &#123;</span><br><span class="line">      if (options.flush === &#x27;post&#x27;) &#123;</span><br><span class="line">        const p = Promise.then()</span><br><span class="line">        p.then(job)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        job()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  if (options.immediate) &#123;</span><br><span class="line">    job()</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    oldValue = effectFn()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="理解-Proxy-和-Reflect"><a href="#理解-Proxy-和-Reflect" class="headerlink" title="理解 Proxy 和 Reflect"></a>理解 Proxy 和 Reflect</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Proxy只能代理对象, 且只能拦截对一个对象的基本操作</span><br><span class="line">复合操作: obj.fn(), 第一个基本语义为get, 第二个基本语义为函数调用</span><br><span class="line"></span><br><span class="line">Reflect是一个全局对象, Reflect的第三个参数receiver可以认为是函数调用过程中的this, 代表着谁在读取属性</span><br></pre></td></tr></table></figure><h3 id="代理-Object"><a href="#代理-Object" class="headerlink" title="代理 Object"></a>代理 Object</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">对一个普通对象的所有可能的读取操作</span><br><span class="line">obj.foo (get)</span><br><span class="line">key in obj (has)</span><br><span class="line">for (const key in obj) &#123;&#125; (ownKeys)</span><br><span class="line"></span><br><span class="line">const reactive = (data) =&gt; &#123;</span><br><span class="line">  return new Proxy(data, &#123;</span><br><span class="line">    get(target, key, receiver) &#123;</span><br><span class="line">      // 代理对象的raw属性可以读取原始属性</span><br><span class="line">      // child.raw = obj parent.raw = proto</span><br><span class="line">      if (key === &#x27;raw&#x27;) &#123;</span><br><span class="line">        return target</span><br><span class="line">      &#125;</span><br><span class="line">      if (!isReadonly) &#123;</span><br><span class="line">        track(target, key)</span><br><span class="line">      &#125;</span><br><span class="line">      track(target, key)</span><br><span class="line">      const res = Reflect.get(target, key, receiver)</span><br><span class="line">      if (typeof res === &#x27;object&#x27; &amp;&amp; res !== null) &#123;</span><br><span class="line">        return isReadonly ? readonly(res) : reactive(res)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      return res</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, key, value, receiver) &#123;</span><br><span class="line">      // target是原对象, 当自身对象不存在属性时, 会遍历原型链</span><br><span class="line">      // receiver是代理对象</span><br><span class="line">      const oldValue = target[key]</span><br><span class="line">      // 判断for...in循环是否修改了值</span><br><span class="line">      const type = Object.prototype.hasOwnProperty.call(target, key) ? &#x27;SET&#x27; : &#x27;ADD&#x27;</span><br><span class="line">      const res = Reflect.set(target, key, value, receiver)</span><br><span class="line">      if (target === receiver.raw) &#123;</span><br><span class="line">        if (value !== oldValue) &#123;</span><br><span class="line">          trigger(target, key, type)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return res</span><br><span class="line">    &#125;,</span><br><span class="line">    has(target, key, receiver) &#123;</span><br><span class="line">      track(target, key)</span><br><span class="line">      return Reflect.has(target, key, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    ownKeys(target) &#123;</span><br><span class="line">      track(target, ITERATE_KEY)</span><br><span class="line">      return Reflect.ownKeys(target)</span><br><span class="line">    &#125;,</span><br><span class="line">    deleteProperty(target, key) &#123;</span><br><span class="line">      const res = Reflect.defineProperty(target, key)</span><br><span class="line">      if (res) &#123;</span><br><span class="line">        trigger(target, key)</span><br><span class="line">      &#125;</span><br><span class="line">      return res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="只读与浅只读"><a href="#只读与浅只读" class="headerlink" title="只读与浅只读"></a>只读与浅只读</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果一个数据是可读的</span><br><span class="line">set, delete失效</span><br><span class="line">没必要为只读数据建立响应联系</span><br></pre></td></tr></table></figure><h3 id="原始值的响应式方案"><a href="#原始值的响应式方案" class="headerlink" title="原始值的响应式方案"></a>原始值的响应式方案</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">js中的proxy无法提供对原始值得代理, 因此想要将原始值变成响应式数据, 就必须对其做一层包裹, 也就是ref</span><br><span class="line"></span><br><span class="line">区分ref</span><br><span class="line">function ref(val) &#123;</span><br><span class="line">  const wrapper = &#123;</span><br><span class="line">    value: val</span><br><span class="line">  &#125;</span><br><span class="line">  Object.prototype.defineProperty(wrapper, &#x27;__v_isRef&#x27;, &#123;</span><br><span class="line">    value: true</span><br><span class="line">  &#125;)</span><br><span class="line">  return reactive(wrapper)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ref除了能够用于原始值的响应式方案外, 还能用来解决响应式丢失的问题</span><br><span class="line">(解构一个响应式对象后, 会得到一个普通对象)</span><br><span class="line">function toRef(obj, key) &#123;</span><br><span class="line">  const wrapper = &#123;</span><br><span class="line">    get value() &#123;</span><br><span class="line">      return obj[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    set value(val) &#123;</span><br><span class="line">      obj[key] = val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Object.prototype.defineProperty(wrapper, &#x27;__v_isRef&#x27;, &#123;</span><br><span class="line">    value: true</span><br><span class="line">  &#125;)</span><br><span class="line">  return wrapper</span><br><span class="line">&#125;</span><br><span class="line">function toRefs(obj) &#123;</span><br><span class="line">  const res = &#123;&#125;</span><br><span class="line">  for (let ket in obj) &#123;</span><br><span class="line">    res[key] = toRef(obj, key)</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return &#123; ...toRefs(reactiveData) &#125;</span><br><span class="line"></span><br><span class="line">自动脱ref</span><br><span class="line">function isRef(ref) &#123;</span><br><span class="line">  return !!ref.__v_isRef</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function unref(ref) &#123;</span><br><span class="line">  return isRef(ref) ? ref.value : ref</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function proxyRefs(target) &#123;</span><br><span class="line">  return new Proxy(target, &#123;</span><br><span class="line">    get(target, key, receiver) &#123;</span><br><span class="line">      const value = Reflect.get(target, key, receiver)</span><br><span class="line">      return unref(value)</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, key, newValue, receiver) &#123;</span><br><span class="line">      const value = target[key]</span><br><span class="line">      if (isRef(value)) &#123;</span><br><span class="line">        value.value = newValue</span><br><span class="line">        return true</span><br><span class="line">      &#125;</span><br><span class="line">      return Reflect.set(target, key, newValue, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="渲染器与响应式系统的结合"><a href="#渲染器与响应式系统的结合" class="headerlink" title="渲染器与响应式系统的结合"></a>渲染器与响应式系统的结合</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">渲染器不仅能够渲染真实的DOM, 它还是框架跨平台能力的关键</span><br><span class="line">&lt;script src=&quot;http://unpkg.com/@vue/reactivity#3.0.5/dist/reactivity.global.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    const &#123; effect, ref &#125; = VueReactivity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">渲染器把虚拟DOM节点渲染为真实DOM节点的过程叫做挂载 mount</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">新增, 更新, 删除节点</span><br><span class="line">const renderer = createRenderer()</span><br><span class="line">renderer.render(vnode1, app)</span><br><span class="line">renderer.redner(vnode2, app)</span><br><span class="line">renderer.render(null, app)</span><br><span class="line">首次渲染时, 渲染器会将vnode1渲染为真实的DOM, 渲染完成后, vnode1会存储到容器元素的container._vnode属性中, 它在后续渲染中作为旧vnode使用</span><br><span class="line">第二次渲染时, 旧vnode存在, 此时渲染器会把vnode2作为新node, 并将新旧node一同传递给patch函数进行补丁</span><br><span class="line">第三次渲染, 什么都不渲染, 清空容器</span><br></pre></td></tr></table></figure><h3 id="自定义渲染器"><a href="#自定义渲染器" class="headerlink" title="自定义渲染器"></a>自定义渲染器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">createApp =&gt; renderer.createApp =&gt; createRenderer(options).createApp</span><br><span class="line"></span><br><span class="line">function createRenderer(options = &#123;&#125;) &#123;</span><br><span class="line"></span><br><span class="line">      const &#123; createElement, insert, setElementText &#125; = options</span><br><span class="line"></span><br><span class="line">      function patch(n1, n2, container) &#123;</span><br><span class="line">        if (!n1) &#123;</span><br><span class="line">          mountElement(n2, container)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      function render(vnode, container) &#123;</span><br><span class="line">        if (vnode) &#123;</span><br><span class="line">          patch(container._vnode, vnode, container)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          if (container._vnode) &#123;</span><br><span class="line">            container.innerHTML = &#x27;&#x27;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        container._vnode = vnode</span><br><span class="line">      &#125;</span><br><span class="line">      function hydrate(vnode, container) &#123; &#125;</span><br><span class="line">      function mountElement(vnode, container) &#123;</span><br><span class="line">        const el = createElement(vnode.type)</span><br><span class="line">        if (typeof vnode.children === &#x27;string&#x27;) &#123;</span><br><span class="line">          setElementText(el, vnode.children)</span><br><span class="line">        &#125;</span><br><span class="line">        insert(el, container)</span><br><span class="line">      &#125;</span><br><span class="line">      return &#123;</span><br><span class="line">        render,</span><br><span class="line">        hydrate</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const options = &#123;</span><br><span class="line">      createElement(tag) &#123;</span><br><span class="line">        return document.createElement(tag)</span><br><span class="line">      &#125;,</span><br><span class="line">      setElementText(el, text) &#123;</span><br><span class="line">        el.textContent = text</span><br><span class="line">      &#125;,</span><br><span class="line">      insert(el, parent, anchor = null) &#123;</span><br><span class="line">        parent.insertBefore(el, anchor)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const renderer = createRenderer(options)</span><br><span class="line">    const vnode = &#123; type: &#x27;div&#x27;, props: &#123;&#125;, children: &#x27;hello&#x27; &#125;</span><br><span class="line">    renderer.render(vnode, app)</span><br></pre></td></tr></table></figure><h3 id="正确的设置元素属性"><a href="#正确的设置元素属性" class="headerlink" title="正确的设置元素属性"></a>正确的设置元素属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">HTML attributes的作用是设置与之对应的DOM properties的初始值</span><br><span class="line">如果设置的attribute不合法, 浏览器会使用内建合法值作为与之对应DOM property的默认值</span><br><span class="line"></span><br><span class="line">优先设置元素的DOM properties, 但当值为空字符串时, 要手动将值矫正为true, 如果不存在DOM property, 使用setAttribute</span><br><span class="line"></span><br><span class="line">shouldSetAsProps(el, key, value) &#123;</span><br><span class="line">        if (key === &#x27;form&#x27; &amp;&amp; el, tagName === &#x27;INPUT&#x27;) return false</span><br><span class="line">        return key in el</span><br><span class="line">      &#125;,</span><br><span class="line">      patchProps(el, key, preValue, nextValue) &#123;</span><br><span class="line">        // 使用el.className 代替 setAttribute 性能更好</span><br><span class="line">        if (key === &#x27;class&#x27;) &#123;</span><br><span class="line">          el.className = nextValue || &#x27;&#x27;</span><br><span class="line">        &#125; else if (options.shouldSetAsProps(el, key, nextValue)) &#123;</span><br><span class="line">          const type = typeof el[key]</span><br><span class="line">          if (type === &#x27;boolean&#x27; &amp;&amp; nextValue === &#x27;&#x27;) &#123;</span><br><span class="line">            el[key] = true</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            el[key] = nextValue</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          el.setAttribute(key, nextValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="卸载操作"><a href="#卸载操作" class="headerlink" title="卸载操作"></a>卸载操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">直接通过innerHTML = ‘’ 缺点</span><br><span class="line">1. 容器的内容可能是由某个或多个组件渲染的, 当卸载操作发生时, 应该正确地调用这些组件的beforeUnmount, unmounted生命周期</span><br><span class="line">2. 执行自定义指令钩子</span><br><span class="line">3. 不会移除绑定在DOM元素上的事件处理函数</span><br><span class="line"></span><br><span class="line">const el = container._vnode.el</span><br><span class="line">const parent = el.parentNode</span><br><span class="line">if (parent) parent.removeChild(el)</span><br></pre></td></tr></table></figure><h3 id="区分-vnode-类型"><a href="#区分-vnode-类型" class="headerlink" title="区分 vnode 类型"></a>区分 vnode 类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">当vnode的type不同时, 卸载旧vnode, 挂载新的vnode</span><br><span class="line"></span><br><span class="line">function patch(n1, n2, container) &#123;</span><br><span class="line">    // 当vnode的type不同时, 卸载旧vnode</span><br><span class="line">    if (n1 &amp;&amp; n1.type !== n2.type) &#123;</span><br><span class="line">      unmount(n1)</span><br><span class="line">      n1 = null</span><br><span class="line">    &#125;</span><br><span class="line">    const type = typeof n2.type</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">      case &#x27;fragment&#x27;:</span><br><span class="line">        break</span><br><span class="line">      case &#x27;string&#x27;:</span><br><span class="line">        if (!n1) &#123;</span><br><span class="line">          // 新增</span><br><span class="line">          mountElement(n2, container)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // 更新</span><br><span class="line">          patchElement(n1, n2)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">      case &#x27;object&#x27;:</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="事件的处理"><a href="#事件的处理" class="headerlink" title="事件的处理"></a>事件的处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">绑定一个伪造的事件处理函数invoker, 然后把真正的事件处理函数设置为invoker.value属性的值, 这样当更新事件的时候, 我们将不再需要调用removeEventListener函数来移除上一次绑定的事件, 只需要更新invoker.value的值即可, 同时处理了事件与更新时间间的差异</span><br><span class="line"></span><br><span class="line">if (/^on/.test(key)) &#123;</span><br><span class="line">      const invokers = el._vei || (el._vei = &#123;&#125;)</span><br><span class="line">      let invoker = invokers[key]</span><br><span class="line">      const name = key.slice(2).toLowerCase()</span><br><span class="line">      if (nextValue) &#123;</span><br><span class="line">        if (!invoker) &#123;</span><br><span class="line">          invoker = el._vei[key] = (e) =&gt; &#123;</span><br><span class="line">            console.log(&#x27;e: &#x27;, e)</span><br><span class="line">            // e.timeStamp 时间发生的时间</span><br><span class="line">            // 如果时间发生的时间早于事件处理函数绑定的时间, 则不执行事件处理函数</span><br><span class="line">            if (e.timeStamp &lt; invoker.attached) return</span><br><span class="line">            if (Array.isArray(invoker.value)) &#123;</span><br><span class="line">              invoker.value.forEach((fn) =&gt; fn(e))</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              invoker.value(e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          invoker.value = nextValue</span><br><span class="line">          invoker.attached = performance.now()</span><br><span class="line">          el.addEventListener(name, invoker)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          invoker.value = nextValue</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (invoker) &#123;</span><br><span class="line">        el.removeEventListener(name, invoker)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="更新子节点"><a href="#更新子节点" class="headerlink" title="更新子节点"></a>更新子节点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vnode.children的三种情况: 没有子节点, 文本子节点, 一组子节点</span><br><span class="line"></span><br><span class="line">function patchChildren(n1, n2, container) &#123;</span><br><span class="line">    if (typeof n2.children === &#x27;string&#x27;) &#123;</span><br><span class="line">      // 旧节点的类型有三种可能, 没有子节点, 文本节点以及一组子节点</span><br><span class="line">      // 只有当旧节点为一组节点时, 才需要逐个卸载, 其他情况下什么都不需要做</span><br><span class="line">      if (Array.isArray(n1.children)) &#123;</span><br><span class="line">        n1.children.forEach((c) =&gt; unmount(c))</span><br><span class="line">      &#125;</span><br><span class="line">      setElementText(container, n2.children)</span><br><span class="line">    &#125; else if (Array.isArray(n2.children)) &#123;</span><br><span class="line">      if (Array.isArray(n1.children)) &#123;</span><br><span class="line">        //TODO diff</span><br><span class="line">        n1.children.forEach((c) =&gt; unmount(c))</span><br><span class="line">        n2.children.forEach((c) =&gt; patch(null, c, container))</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        setElementText(container, &#x27;&#x27;)</span><br><span class="line">        n2.children.forEach((c) =&gt; patch(null, c, container))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 代码运行到这里说明新子节点不存在</span><br><span class="line">      if (Array.isArray(n1.children)) &#123;</span><br><span class="line">        n1.children.forEach((c) =&gt; unmount(c))</span><br><span class="line">      &#125; else if (typeof n1.children === &#x27;string&#x27;) &#123;</span><br><span class="line">        setElementText(container, &#x27;&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="文本节点和注释节点"><a href="#文本节点和注释节点" class="headerlink" title="文本节点和注释节点"></a>文本节点和注释节点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">认为创建文本节点和注释节点</span><br><span class="line">cosnt TEXT = Symbol()</span><br><span class="line">const COMMENT = Symbol()</span><br><span class="line"></span><br><span class="line">case TEXT:</span><br><span class="line">        if (!n1) &#123;</span><br><span class="line">          const el = (n2.el = createText(n2.children))</span><br><span class="line">          insert(el, container)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          const el = (n2.el = n1.el)</span><br><span class="line">          if (n2.children !== n1.children) &#123;</span><br><span class="line">            setText(el, n2.children)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">渲染器渲染Fragment时, 只会渲染Fragment的子节点</span><br><span class="line"></span><br><span class="line">unmount(vnode) &#123;</span><br><span class="line">    if (vnode.type === FRAGMENT) &#123;</span><br><span class="line">      vnode.children.forEach((c) =&gt; renderOptions.unmount(c))</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    const parent = vnode.el.parentNode</span><br><span class="line">    if (parent) &#123;</span><br><span class="line">      parent.removeChild(vnode.el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="简单-diff-算法"><a href="#简单-diff-算法" class="headerlink" title="简单 diff 算法"></a>简单 diff 算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在进行对比时, 应该遍历新旧节点中长度较短的一组, 执行patch函数每项比对更新, 接着再对比新旧两组节点的长度, 如果新的一组节点更长, 则说明有新节点需要挂载, 否则说明有旧节点需要卸载</span><br></pre></td></tr></table></figure><h3 id="DOM-复用与-key-的作用"><a href="#DOM-复用与-key-的作用" class="headerlink" title="DOM 复用与 key 的作用"></a>DOM 复用与 key 的作用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">想要通过移动DOM移动完成更新, 必须要保证一个前提: 新旧两组节点中确实存在可以服用的节点 vnode.type &amp;&amp; vnode.key</span><br></pre></td></tr></table></figure><h3 id="找到需要移动的元素"><a href="#找到需要移动的元素" class="headerlink" title="找到需要移动的元素"></a>找到需要移动的元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">当新旧两个子节点的节点顺序不变时, 不需要额外的移动操作</span><br><span class="line"></span><br><span class="line">每一次寻找可复用节点时, 都会记录该可复用节点在旧的一组节点中的位置索引, 如果把这些位置索引按照先后排序, 则可以得到一个序列, 如果是一个递增序列, 就不需要移动节点</span><br><span class="line"></span><br><span class="line">在旧children中寻找具有相同key值节点的过程中, 遇到的最大索引值</span><br><span class="line">如果在后续寻找中, 存在索引值比当前遇到的最大索引值还要小的节点, 则意味着该节点需要移动</span><br><span class="line"></span><br><span class="line">if (Array.isArray(n1.children)) &#123;</span><br><span class="line">        //TODO diff</span><br><span class="line">        const oldChildren = n1.children</span><br><span class="line">        const newChildren = n2.children</span><br><span class="line">        const oldLen = oldChildren.length</span><br><span class="line">        const newLen = newChildren.length</span><br><span class="line">        // 用来存储寻找过程中遇到的最大索引值</span><br><span class="line">        let lastIndex = 0</span><br><span class="line">        for (let i = 0; i &lt; newLen; i++) &#123;</span><br><span class="line">          const newVNode = newChildren[i]</span><br><span class="line">          for (let j = 0; j &lt; oldLen; j++) &#123;</span><br><span class="line">            const oldVNode = oldChildren[j]</span><br><span class="line">            if (newVNode.key === oldVNode.key) &#123;</span><br><span class="line">              patch(oldVNode, newVNode, container)</span><br><span class="line">              if (j &lt; lastIndex) &#123;</span><br><span class="line">                // 如果当前索引小于最大索引, 意味着该节点对应的真实DOM需要移动</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                lastIndex = j</span><br><span class="line">              &#125;</span><br><span class="line">              break</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="如何移动元素"><a href="#如何移动元素" class="headerlink" title="如何移动元素"></a>如何移动元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">要移动的并不是虚拟节点本身, 而是真实的DOM节点 =&gt; vnode.el</span><br><span class="line"></span><br><span class="line">if (j &lt; lastIndex) &#123;</span><br><span class="line">                // 如果当前索引小于最大索引, 意味着该节点对应的真实DOM需要移动</span><br><span class="line">                const preVNode = newChildren[i - 1]</span><br><span class="line">                if (preVNode) &#123;</span><br><span class="line">                  const anchor = preVNode.el.nextSibling</span><br><span class="line">                  insert(newVNode.el, container, anchor)</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                lastIndex = j</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure><h3 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">找到新增节点: 在旧节点组中没有对应的key</span><br><span class="line">挂载到正确的位置上</span><br><span class="line"></span><br><span class="line">const newVNode = newChildren[i]</span><br><span class="line">          let j = 0</span><br><span class="line">          // find代表是否在旧的一组节点中找到可以复用的节点</span><br><span class="line">          let find = false</span><br><span class="line">          for (j; j &lt; oldLen; j++) &#123;</span><br><span class="line">            const oldVNode = oldChildren[j]</span><br><span class="line">            if (newVNode.key === oldVNode.key) &#123;</span><br><span class="line">              find = true</span><br><span class="line">              patch(oldVNode, newVNode, container)</span><br><span class="line">              if (j &lt; lastIndex) &#123;</span><br><span class="line">                // 如果当前索引小于最大索引, 意味着该节点对应的真实DOM需要移动</span><br><span class="line">                const preVNode = newChildren[i - 1]</span><br><span class="line">                if (preVNode) &#123;</span><br><span class="line">                  const anchor = preVNode.el.nextSibling</span><br><span class="line">                  insert(newVNode.el, container, anchor)</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                lastIndex = j</span><br><span class="line">              &#125;</span><br><span class="line">              break</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          if (!find) &#123;</span><br><span class="line">            const preVNode = newChildren[i - 1]</span><br><span class="line">            let anchor = null</span><br><span class="line">            if (preVNode) &#123;</span><br><span class="line">              anchor = preVNode.el.nextSibling</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              anchor = container.firstChild</span><br><span class="line">            &#125;</span><br><span class="line">            patch(null, newVNode, container, anchor)</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><h3 id="移除不存在节点"><a href="#移除不存在节点" class="headerlink" title="移除不存在节点"></a>移除不存在节点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当基本的更新结束时, 我们需要遍历一遍旧节点, 然后去新的节点中寻找具有相同key值的节点, 找不到则删除</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; oldLen; i++) &#123;</span><br><span class="line">          const oldVNode = oldChildren[i]</span><br><span class="line">          const has = newChildren.find((vnode) =&gt; vnode.key === oldVNode.key)</span><br><span class="line">          if (!has) &#123;</span><br><span class="line">            unmount(oldVNode)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="双端-diff-算法"><a href="#双端-diff-算法" class="headerlink" title="双端 diff 算法"></a>双端 diff 算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">双端diff算法是一种同时对新旧两组节点的两个端点进行比较的算法</span><br><span class="line">因此, 我们需要四个索引值, 分别指向新旧两组子节点的端点</span><br><span class="line"></span><br><span class="line">比较旧的一组子节点中的第一个子节点与新的一组子节点中的第一个子节点</span><br><span class="line">比较旧的一组子节点中的最后一个子节点与新的一组子节点中的最后一个子节点</span><br><span class="line">比较旧的一组子节点中的第一个子节点于新的一组子节点中的最后一个子节点</span><br><span class="line">比较旧的一组子节点中的最后一个子节点与新的一组子节点中的第一个子节点</span><br><span class="line"></span><br><span class="line">将索引oldEndIdx指向的虚拟节点所对应的真实DOM移动到索引oldStartIdx指向的虚拟节点所对应的真实DOM前面</span><br><span class="line"></span><br><span class="line">while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">      if (isSameKey(oldStartVNode, newStartVNode)) &#123;</span><br><span class="line">        patch(oldStartVNode, newStartVNode, container)</span><br><span class="line">        oldStartVNode = oldChildren[++oldStartIdx]</span><br><span class="line">        newStartVNode = newChildren[++newStartIdx]</span><br><span class="line">      &#125; else if (isSameKey(oldEndVNode, newEndVNode)) &#123;</span><br><span class="line">        patch(oldEndVNode, newEndVNode, container)</span><br><span class="line">        oldEndVNode = oldChildren[--oldEndIdx]</span><br><span class="line">        newEndVNode = newChildren[--newEndIdx]</span><br><span class="line">      &#125; else if (isSameKey(oldStartVNode, newEndVNode)) &#123;</span><br><span class="line">        patch(oldStartVNode, newEndVNode, container)</span><br><span class="line">        insert(oldStartVNode.el, container, oldEndVNode.el.nextSibling)</span><br><span class="line">        oldStartVNode = oldChildren[++oldStartIdx]</span><br><span class="line">        newEndVNode = newChildren[--newEndIdx]</span><br><span class="line">      &#125; else if (isSameKey(oldEndVNode, newStartVNode)) &#123;</span><br><span class="line">        patch(oldEndVNode, newStartVNode, container)</span><br><span class="line">        insert(oldEndVNode.el, container, oldStartVNode.el)</span><br><span class="line">        oldEndVNode = oldChildren[--oldEndIdx]</span><br><span class="line">        newStartVNode = newChildren[++newStartIdx]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="非理性情况"><a href="#非理性情况" class="headerlink" title="非理性情况"></a>非理性情况</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1, 2, 3, 4</span><br><span class="line">2, 4, 3, 1</span><br><span class="line">我们只能通过增加额外的处理逻辑来处理</span><br><span class="line">拿新的一组子节点的头部节点去旧的一组子节点中寻找, 如果找到, 意味着找到的节点时新节点中的头部</span><br><span class="line"></span><br><span class="line">const idxInOld = oldChildren.findIndex((node) =&gt; node.key === newStartVNode.key)</span><br><span class="line">        if (idxInOld &gt; 0) &#123;</span><br><span class="line">          const vnodeToMove = oldChildren[idxInOld]</span><br><span class="line">          patch(vnodeToMove, newStartVNode, container)</span><br><span class="line">          insert(vnodeToMove.el, container, oldStartVNode.el)</span><br><span class="line">          oldChildren[idxInOld] = undefined</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          patch(null, newStartVNode,container, oldStartVNode.el)</span><br><span class="line">        &#125;</span><br><span class="line">        newStartVNode = newChildren[++newStartIdx]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1, 2, 3</span><br><span class="line">4, 1, 2, 3</span><br><span class="line"></span><br><span class="line">最后, oldEndIdx&lt; oldStartIdx, 会有遗漏的节点没有更新, 需要补充逻辑</span><br><span class="line">if (oldEndIdx &lt; oldStartIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">      for (let i = newStartIdx; i &lt;= newEndIdx; i++) &#123;</span><br><span class="line">        patch(null, newChildren[i], container, oldStartVNode.el)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">移除不存在节点</span><br><span class="line">1, 2, 3, 5</span><br><span class="line">4, 1, 2, 3</span><br><span class="line">if (oldEndIdx &lt; oldStartIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">      for (let i = newStartIdx; i &lt;= newEndIdx; i++) &#123;</span><br><span class="line">        patch(null, newChildren[i], container, oldStartVNode.el)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (newEndIdx &lt; newStartIdx &amp;&amp; oldStartIdx &lt;= oldEndIdx) &#123;</span><br><span class="line">      for (let i = oldStartIdx; i &lt;= oldEndIdx; i++) &#123;</span><br><span class="line">        unmount(oldChildren[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="快速-dif-算法"><a href="#快速-dif-算法" class="headerlink" title="快速 dif 算法"></a>快速 dif 算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">快速diff算法包含了预处理: 找出相同的前置元素和后置元素</span><br><span class="line">1, 2, 3</span><br><span class="line">1, 4, 2, 3</span><br><span class="line">对于相同的前置节点和后置节点, 由于它们在新旧两组节点中的相对位置不变, 所以无需移动它们</span><br><span class="line"></span><br><span class="line">新增</span><br><span class="line">oldEnd &lt; j: 说明在预处理过程中, 所有旧子节点都处理完了</span><br><span class="line">newEnd &gt;=j :说明在预处理过后, 在新的一组子节点中, 仍然有未被处理的节点, 而这些遗留的节点将被视为新增节点</span><br><span class="line"></span><br><span class="line">删除</span><br><span class="line">newEnd &lt; j: 说明在预处理过程中, 所有新子节点都处理完了</span><br><span class="line">oldEnd &gt;= j: 说明在预处理过后, 在新的一组子节点中, 仍然有未被处理的节点, 而这些遗留的节点将被视为删除节点</span><br><span class="line"></span><br><span class="line">function patchKeyedChildren(n1, n2, container) &#123;</span><br><span class="line">    const oldChildren = n1.children</span><br><span class="line">    const newChildren = n2.children</span><br><span class="line"></span><br><span class="line">    // 处理相同的前置节点, 索引j指向新旧两组子节点的开头</span><br><span class="line">    let j = 0</span><br><span class="line">    let oldVNode = oldChildren[j]</span><br><span class="line">    let newVNode = newChildren[j]</span><br><span class="line">    while (oldVNode.key === newVNode.key) &#123;</span><br><span class="line">      patch(oldVNode, newVNode, container)</span><br><span class="line">      j++</span><br><span class="line">      oldVNode = oldChildren[j]</span><br><span class="line">      newVNode = newChildren[j]</span><br><span class="line">    &#125;</span><br><span class="line">    // 处理相同的后置节点</span><br><span class="line">    let oldEnd = oldChildren.length - 1</span><br><span class="line">    let newEnd = newChildren.length - 1</span><br><span class="line">    oldVNode = oldChildren[oldEnd]</span><br><span class="line">    newVNode = newChildren[newEnd]</span><br><span class="line">    while (oldVNode.key === newVNode.key) &#123;</span><br><span class="line">      patch(oldVNode, newVNode, container)</span><br><span class="line">      oldVNode = oldChildren[--oldEnd]</span><br><span class="line">      newVNode = newChildren[--newEnd]</span><br><span class="line">    &#125;</span><br><span class="line">    // 旧子节点处理完毕, 新子节点还有未被处理的节点</span><br><span class="line">    if (j &gt; oldEnd &amp;&amp; j &lt;= newEnd) &#123;</span><br><span class="line">      const anchorIndex = newEnd + 1</span><br><span class="line">      const anchor = anchorIndex &lt; newChildren.length ? newChildren[anchorIndex].el : null</span><br><span class="line">      while (j &lt;= newEnd) &#123;</span><br><span class="line">        patch(null, newChildren[j++], container, anchor)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (j &gt; newEnd &amp;&amp; j &lt; oldEnd) &#123;</span><br><span class="line">      while (j &lt;= oldEnd) &#123;</span><br><span class="line">        unmount(oldChildren[j++])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="判断是否需要进行-DOM-移动操作"><a href="#判断是否需要进行-DOM-移动操作" class="headerlink" title="判断是否需要进行 DOM 移动操作"></a>判断是否需要进行 DOM 移动操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">1,2,3,4,6,5</span><br><span class="line">1,3,4,2,7,5</span><br><span class="line"></span><br><span class="line">判断是否有节点要移动, 以及应该如何移动</span><br><span class="line">找出那些需要被添加或移除的节点</span><br><span class="line"></span><br><span class="line">构造一个数组source, 它的长度=新的一组子节点在经过预处理之后剩余未处理子节点的数量, 并且source中每个元素的初始值都是-1</span><br><span class="line">source用来存储新的一组子节点中的节点再旧的一组子节点中的位置索引, 后面会使用它计算出一个最长递增子序列, 用于辅助完成DOM移动的操作</span><br><span class="line"></span><br><span class="line">// 处理非理想情况</span><br><span class="line">      const count = newEnd - j + 1</span><br><span class="line">      const source = new Array(count).fill(-1)</span><br><span class="line"></span><br><span class="line">      const oldStart = j</span><br><span class="line">      const newStart = j</span><br><span class="line">      let moved = false</span><br><span class="line">      let pos = 0</span><br><span class="line"></span><br><span class="line">      // 构建索引表</span><br><span class="line">      const keyIndex = new Map()</span><br><span class="line">      for (let i = newStart; i &lt;= newEnd; i++) &#123;</span><br><span class="line">        keyIndex.set(newChildren[i].key, i)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 更新过的节点数量</span><br><span class="line">      let patched = 0</span><br><span class="line"></span><br><span class="line">      for (let i = oldStart; i &lt;= oldEnd; i++) &#123;</span><br><span class="line">        oldVNode = oldChildren[i]</span><br><span class="line">        // 如果更新过的节点数量大于需要更新的节点数量, 则卸载多余的节点</span><br><span class="line">        if (patched &gt;= count) &#123;</span><br><span class="line">          unmount(oldVNode)</span><br><span class="line">          continue</span><br><span class="line">        &#125;</span><br><span class="line">        // 通过索引表快速找到新的一组子节点中具有相同key值得节点位置</span><br><span class="line">        const k = keyIndex.get(oldVNode.key)</span><br><span class="line">        if (typeof k !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">          newVNode = newChildren[k]</span><br><span class="line">          patch(oldVNode, newVNode, container)</span><br><span class="line">          patched++</span><br><span class="line">          source[k - newStart] = i</span><br><span class="line">          // 判断是否需要移动</span><br><span class="line">          if (k &lt; pos) &#123;</span><br><span class="line">            moved = true</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            pos = k</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          unmount(oldVNode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="如何移动元素-1"><a href="#如何移动元素-1" class="headerlink" title="如何移动元素"></a>如何移动元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">lis函数: 最长递增子序列中的元素在source数组中的位置索引</span><br><span class="line">含义: 在新的一组子节点中, 重新编号后索引值为0和1的这两个节点在更新前后顺序没有发生变化. 换句话说, 索引值为0和1的节点不需要移动</span><br><span class="line"></span><br><span class="line">// 移动元素</span><br><span class="line">      if (moved) &#123;</span><br><span class="line">        // 最长递增子序列中的元素在source数组中的位置索引</span><br><span class="line">        const seq = lis(source)</span><br><span class="line"></span><br><span class="line">        // s指向最长递增子序列的最后一个元素</span><br><span class="line">        let s = seq.length - 1</span><br><span class="line">        // i 指向新的一组子节点的最后一个元素</span><br><span class="line">        let i = count - 1</span><br><span class="line"></span><br><span class="line">        for (i; i &gt;= 0; i--) &#123;</span><br><span class="line">          const pos = i + newStart</span><br><span class="line">          const newVNode = newChildren[pos]</span><br><span class="line">          const nextPos = pos + 1</span><br><span class="line">          const anchor = nextPos &lt; newChildren.length ? newChildren[nextPos].el : null</span><br><span class="line">          if (source[i] === -1) &#123;</span><br><span class="line">            // 新增子节点</span><br><span class="line">            patch(null, newVNode, container, anchor)</span><br><span class="line">          &#125; else if (i !== seq[s]) &#123;</span><br><span class="line">            // 如果节点的索引i不等于seq[s]的值, 说明节点需要移动</span><br><span class="line">            insert(newVNode.el, container, anchor)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            // 不需要移动</span><br><span class="line">            s--</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="渲染组件"><a href="#渲染组件" class="headerlink" title="渲染组件"></a>渲染组件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">判断组件: vnode.type === ‘object’</span><br><span class="line"></span><br><span class="line">function mountComponent(vnode, container, anchor) &#123;</span><br><span class="line">    const componentOptions = vnode.type</span><br><span class="line">    const &#123; render &#125; = componentOptions</span><br><span class="line">    const subTree = render()</span><br><span class="line">    patch(null, subTree, container, anchor)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="组件状态与自更新"><a href="#组件状态与自更新" class="headerlink" title="组件状态与自更新"></a>组件状态与自更新</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function mountComponent(vnode, container, anchor) &#123;</span><br><span class="line">    const componentOptions = vnode.type</span><br><span class="line">    const &#123; render, data, beforeCreate, created, beforeMount, mounted, beforeUpdate, updated &#125; =</span><br><span class="line">      componentOptions</span><br><span class="line"></span><br><span class="line">    beforeCreate &amp;&amp; beforeCreate()</span><br><span class="line"></span><br><span class="line">    const state = reactive(data())</span><br><span class="line"></span><br><span class="line">    // 定义组件实例, 一个组件实力本质上就是一个对象, 它包含与组件有关的状态信息</span><br><span class="line">    const instance = &#123;</span><br><span class="line">      state,</span><br><span class="line">      isMounted: false,</span><br><span class="line">      subTree: null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vnode.component = instance</span><br><span class="line"></span><br><span class="line">    created &amp;&amp; created.call(state)</span><br><span class="line"></span><br><span class="line">    effect(</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        // 组件自身响应式数据发生变化, 组件自动重新执行渲染函数</span><br><span class="line">        const subTree = render.call(state, state)</span><br><span class="line">        if (!instance.isMounted) &#123;</span><br><span class="line">          beforeMount &amp;&amp; beforeMount.call(state)</span><br><span class="line">          patch(null, subTree, container, anchor)</span><br><span class="line">          instance.isMounted = true</span><br><span class="line">          mounted &amp;&amp; mounted.call(state)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          beforeUpdate &amp;&amp; beforeUpdate(state)</span><br><span class="line">          patch(instance.subTree, subTree, container, anchor)</span><br><span class="line">          updated &amp;&amp; updated(state)</span><br><span class="line">        &#125;</span><br><span class="line">        instance.subTree = subTree</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        scheduler: queueJob</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const queue = new Set()</span><br><span class="line"></span><br><span class="line">let isFlushing = false</span><br><span class="line"></span><br><span class="line">const p = Promise.resolve()</span><br><span class="line"></span><br><span class="line">export function queueJob(job) &#123;</span><br><span class="line">  queue.add(job)</span><br><span class="line">  if (!isFlushing) &#123;</span><br><span class="line">    isFlushing = true</span><br><span class="line">    p.then(() =&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        queue.forEach((job) =&gt; job())</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        isFlushing = true</span><br><span class="line">        queue.length = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="props-与组件的被动更新"><a href="#props-与组件的被动更新" class="headerlink" title="props 与组件的被动更新"></a>props 与组件的被动更新</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent title=‘my title’ :other=‘val’ /&gt;</span><br><span class="line">const App = &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  type: MyComponent,</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: &#x27;my title&#x27;,</span><br><span class="line">    other: this.val</span><br><span class="line">  &#125;,</span><br><span class="line">  children: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">为组件传递的props数据, 即组件的vnode.props对象</span><br><span class="line">组件选项对象定义的props选项, 即MyComponent.props对象</span><br><span class="line"></span><br><span class="line">export function resolveProps(options, propsData) &#123;</span><br><span class="line">  const props = &#123;&#125;</span><br><span class="line">  const attrs = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  for (const key in propsData) &#123;</span><br><span class="line">    if (key in options) &#123;</span><br><span class="line">      // 如果传递的props为自检自身定义的props, 则视为合法</span><br><span class="line">      props[key] = propsData[key]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 否则将其视为attrs</span><br><span class="line">      attrs[key] = propsData[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return [props, attrs]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">props本质是父组件的数据, 当props发生变化时, 会触发父组件的重新渲染</span><br><span class="line">我们把由父组件更新引起的子组件更新叫做子组件的被动更新</span><br><span class="line"></span><br><span class="line">当子组件被动更新时, 我们需要做</span><br><span class="line">检测子组件是否真的需要更新, 因为子组件的props可能是不变的</span><br><span class="line">如果需要更新, 则更新子组件的props, slots等内容</span><br><span class="line">const instance = (n2.component = n1.component)</span><br><span class="line">    const &#123; props &#125; = instance</span><br><span class="line">    // 调用hasPropsChanged检测子组件传递的props是否发生变化, 如果没有变化, 不更新</span><br><span class="line">    if (hasPropsChanged(n1.props, n2.props)) &#123;</span><br><span class="line">      const [nextProps] = resolveProps(n2.type.props, n2.props)</span><br><span class="line">      for (const k in nextProps) &#123;</span><br><span class="line">        props[k] = nextProps[k]</span><br><span class="line">      &#125;</span><br><span class="line">      for (const k in props) &#123;</span><br><span class="line">        if (!(k in nextProps)) delete props[k]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="代理组件实例"><a href="#代理组件实例" class="headerlink" title="代理组件实例"></a>代理组件实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const renderContext = new Proxy(instance, &#123;</span><br><span class="line">      get(t, k, r) &#123;</span><br><span class="line">        const &#123; state, props &#125; = t</span><br><span class="line">        if (state &amp;&amp; k in state) &#123;</span><br><span class="line">          return state[k]</span><br><span class="line">        &#125; else if (k in props) &#123;</span><br><span class="line">          return props[k]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          console.log(`$&#123;key&#125; 未定义`)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      set(t, k, v, r) &#123;</span><br><span class="line">        const &#123; state, props &#125; = t</span><br><span class="line">        if (state &amp;&amp; k in state) &#123;</span><br><span class="line">          state[k] = v</span><br><span class="line">        &#125; else if (k in props) &#123;</span><br><span class="line">          props[k] = v</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          console.log(`$&#123;key&#125; 未定义`)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="setup-函数的作用与实现"><a href="#setup-函数的作用与实现" class="headerlink" title="setup 函数的作用与实现"></a>setup 函数的作用与实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">setup函数只会在被挂载的时候执行一次, 它的返回值可以有两种情况</span><br><span class="line">1. 返回一个函数, 改函数将作为组件的render函数</span><br><span class="line">2. 返回一个对象, 该对象中包含的数据将暴露给模板使用</span><br><span class="line"></span><br><span class="line">setup接受两个参数</span><br><span class="line">setup(props, &#123; slots, emit, attrs, expose &#125;) &#123;&#125;,</span><br><span class="line"></span><br><span class="line">const setupContext = &#123; attrs &#125;</span><br><span class="line">    const setupResult = setup(shallowReadonly(instance.props), &#123; setupContext &#125;)</span><br><span class="line"></span><br><span class="line">    let setupState = null</span><br><span class="line">    if (typeof setupResult === &#x27;function&#x27;) &#123;</span><br><span class="line">      if (render) &#123;</span><br><span class="line">        console.error(&#x27;setup函数返回渲染函数, render选项将被忽略&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">      render = setupResult</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      setupState = setupResult</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="组件事件与-emit-的实现"><a href="#组件事件与-emit-的实现" class="headerlink" title="组件事件与 emit 的实现"></a>组件事件与 emit 的实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent @change=“handler” /&gt;</span><br><span class="line">const Comp = &#123;</span><br><span class="line">  type: MyComponent,</span><br><span class="line">  props: &#123;</span><br><span class="line">    onChange: handler</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function emit(event, ...payload) &#123;</span><br><span class="line">      const eventName = `on$&#123;event[0].toUpperCase() + event.slice(1)&#125;`</span><br><span class="line">      const handler = instance.props[eventName]</span><br><span class="line">      if (handler) &#123;</span><br><span class="line">        handler(...payload)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        console.log(&#x27;事件不存在&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="插槽的工作原理与实现"><a href="#插槽的工作原理与实现" class="headerlink" title="插槽的工作原理与实现"></a>插槽的工作原理与实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">当在父组件中使用插槽</span><br><span class="line">&lt;MyComponent&gt;</span><br><span class="line">  &lt;template #header&gt;</span><br><span class="line">   &lt;h1&gt;Hello&lt;/h1&gt;</span><br><span class="line">  &lt;/tmeplate&gt;</span><br><span class="line">&lt;/MyComponent&gt;</span><br><span class="line"></span><br><span class="line">function render() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: MyComponent,</span><br><span class="line">    // 组件的children会被编译成一个对象, $slots =&gt; children</span><br><span class="line">    children: &#123;</span><br><span class="line">      // 插槽函数</span><br><span class="line">      header() &#123;</span><br><span class="line">        return &#123; type: ‘h1’, children: ‘hello’ &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">用户可以通过this.$slots访问插槽</span><br></pre></td></tr></table></figure><h3 id="注册生命周期"><a href="#注册生命周期" class="headerlink" title="注册生命周期"></a>注册生命周期</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">currnetInstance</span><br><span class="line">每当初始化组件并执行组件的setup之前, 先将currentInstance设置为当前组件实例,载执行setup函数</span><br><span class="line">onMounted函数只能在setup中调用</span><br></pre></td></tr></table></figure><h3 id="异步组件与函数式组件"><a href="#异步组件与函数式组件" class="headerlink" title="异步组件与函数式组件"></a>异步组件与函数式组件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">提供的能力</span><br><span class="line">允许用户指定加载出错时要渲染得组件</span><br><span class="line">允许用户指定loading组件, 以及展示该组件的延迟时间</span><br><span class="line">允许用户设置加载组件的超时时长</span><br><span class="line">组件加载失败时, 为用户提供重试功能</span><br><span class="line"></span><br><span class="line">AsyncComp: defineAsyncComponent(&#123;</span><br><span class="line">  loader: () =&gt; import(‘CompA’),</span><br><span class="line">  timeout: 2000,</span><br><span class="line">  errorComponent: ErrorComp</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export function defineAsyncComponent(options) &#123;</span><br><span class="line">  if (typeof options === &#x27;function&#x27;) &#123;</span><br><span class="line">    options = &#123;</span><br><span class="line">      loader: options</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  const &#123; loader &#125; = options</span><br><span class="line">  // 存储异步加载的组件</span><br><span class="line">  let InnerComp = null</span><br><span class="line">  return &#123;</span><br><span class="line">    name: &#x27;AsyncComponentWrapper&#x27;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">      const loaded = ref(false)</span><br><span class="line">      const timeout = ref(false)</span><br><span class="line">      loader().then((c) =&gt; &#123;</span><br><span class="line">        InnerComp = c</span><br><span class="line">        loaded.value = true</span><br><span class="line">      &#125;)</span><br><span class="line">      let timer = null</span><br><span class="line">      if (options.timeout) &#123;</span><br><span class="line">        timer = setTimeout(() =&gt; &#123;</span><br><span class="line">          timeout.value = true</span><br><span class="line">        &#125;, options.timeout)</span><br><span class="line">      &#125;</span><br><span class="line">      onUnmounted(() =&gt; &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">      &#125;)</span><br><span class="line">      const placeholder = &#123; type: Text, children &#125;</span><br><span class="line">      return () =&gt; &#123;</span><br><span class="line">        if (loaded.value) &#123;</span><br><span class="line">          return &#123; type: InnerComp &#125;</span><br><span class="line">        &#125; else if (timeout.value) &#123;</span><br><span class="line">          return options.errorComponent ? &#123; type: options.errorComponent &#125; : placeholder</span><br><span class="line">        &#125;</span><br><span class="line">        return placeholder</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">展示loading, 当超过200ms没有完成加载, 才展示loading</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数式组件没有自身状态, 可以接收外部传入的props</span><br><span class="line">无需初始化data以及生命周期</span><br></pre></td></tr></table></figure><h3 id="keepAlive"><a href="#keepAlive" class="headerlink" title="keepAlive"></a>keepAlive</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keep-alive的本质是缓存管理, 再加上特殊的挂载/卸载逻辑</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="模板-DSL-的编译器"><a href="#模板-DSL-的编译器" class="headerlink" title="模板 DSL 的编译器"></a>模板 DSL 的编译器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">源代码-词法分析-语法分析-语义分析-中间代码生成-优化-目标代码生成</span><br><span class="line"></span><br><span class="line">const template = `&lt;div&gt;</span><br><span class="line">&lt;h1 v-if=&quot;ok&quot;&gt;Vue Template&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;`</span><br><span class="line"></span><br><span class="line">const templateAST = parse(template)</span><br><span class="line">const jsAST = transform(templateAST)</span><br><span class="line">const code = generate(jsAST)</span><br></pre></td></tr></table></figure><h3 id="tokenzie"><a href="#tokenzie" class="headerlink" title="tokenzie"></a>tokenzie</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">正则表达式的本质就是有限自动机</span><br><span class="line"></span><br><span class="line">function tokenzie(str) &#123;</span><br><span class="line">  let currentState = State.initial</span><br><span class="line">  const chars = []</span><br><span class="line">  const tokens = []</span><br><span class="line">  while (str) &#123;</span><br><span class="line">    const char = str[0]</span><br><span class="line">    switch (currentState) &#123;</span><br><span class="line">      case State.initial:</span><br><span class="line">        if (char === &#x27;&lt;&#x27;) &#123;</span><br><span class="line">          currentState = State.tagOpen</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125; else if (isAlpha(char)) &#123;</span><br><span class="line">          currentState = State.text</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">      case State.tagOpen:</span><br><span class="line">        if (isAlpha(char)) &#123;</span><br><span class="line">          currentState = State.tagName</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125; else if (char === &#x27;/&#x27;) &#123;</span><br><span class="line">          currentState = State.tagEnd</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">      case State.tagName:</span><br><span class="line">        if (isAlpha(char)) &#123;</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125; else if (char === &#x27;&gt;&#x27;) &#123;</span><br><span class="line">          currentState = State.initial</span><br><span class="line">          tokens.push(&#123;</span><br><span class="line">            type: &#x27;tag&#x27;,</span><br><span class="line">            name: chars.join(&#x27;&#x27;)</span><br><span class="line">          &#125;)</span><br><span class="line">          chars.length = 0</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">      case State.text:</span><br><span class="line">        if (isAlpha(char)) &#123;</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125; else if (char === &#x27;&lt;&#x27;) &#123;</span><br><span class="line">          currentState = State.tagOpen</span><br><span class="line">          tokens.push(&#123;</span><br><span class="line">            type: &#x27;text&#x27;,</span><br><span class="line">            content: chars.join(&#x27;&#x27;)</span><br><span class="line">          &#125;)</span><br><span class="line">          chars.length = 0</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">      case State.tagEnd:</span><br><span class="line">        if (isAlpha(char)) &#123;</span><br><span class="line">          currentState = State.tagEndName</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">      case State.tagEndName:</span><br><span class="line">        if (isAlpha(char)) &#123;</span><br><span class="line">          chars.push(char)</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125; else if (char === &#x27;&gt;&#x27;) &#123;</span><br><span class="line">          currentState = State.initial</span><br><span class="line">          tokens.push(&#123;</span><br><span class="line">            type: &#x27;tagEnd&#x27;,</span><br><span class="line">            name: chars.join(&#x27;&#x27;)</span><br><span class="line">          &#125;)</span><br><span class="line">          chars.length = 0</span><br><span class="line">          str = str.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return tokens</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代js库开发</title>
      <link href="/2023/02/19/xian-dai-js-ku-kai-fa/"/>
      <url>/2023/02/19/xian-dai-js-ku-kai-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h3><h3 id="什么是模块"><a href="#什么是模块" class="headerlink" title="什么是模块"></a>什么是模块</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">一个完整的模块, 需要满足以下特性</span><br><span class="line">独立性--能够独立完成某个功能, 隔离外部环境的影响</span><br><span class="line">完整性--能够完成某个功能</span><br><span class="line">可依赖--可以依赖其他模块</span><br><span class="line">被依赖--可以被其他模块依赖</span><br><span class="line">简而言之, 模块就是一个独立的空间, 能引用其他模块, 也能被其他模块引用</span><br><span class="line"></span><br><span class="line">AMD-浏览器环境工作</span><br><span class="line">CommonJS--nodejs环境工作</span><br><span class="line">UMD--既可在浏览器工作, 也可在nodejs环境下工作</span><br></pre></td></tr></table></figure><h3 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">开源库一般来说提供两个入口文件</span><br><span class="line">index.js</span><br><span class="line">index.esm.js</span><br><span class="line"></span><br><span class="line">在webpack中, 可以通过配置mainFields来支持优先使用module字段, 只需要在webpack.config.js文件中添加</span><br><span class="line">resolve: &#123;</span><br><span class="line">  mainFields: [‘module’, ‘main’]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rollup"><a href="#rollup" class="headerlink" title="rollup"></a>rollup</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rollup巧妙地通过将被依赖的模块放在依赖模块前面的方法来解决模块依赖问题</span><br><span class="line"></span><br><span class="line">umd</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  input: &#x27;index.js&#x27;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    file: &#x27;dist/bundle.js&#x27;,</span><br><span class="line">    format: &#x27;umd&#x27;,</span><br><span class="line">    name: &#x27;deepClone&#x27; // 全局变量名</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果我们的库没有副作用, 则可以向package.json文件中添加sideEffects字段, 这样打包工具就能够使用tree-shaking功能进行优化了</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="兼容低版本浏览器"><a href="#兼容低版本浏览器" class="headerlink" title="兼容低版本浏览器"></a>兼容低版本浏览器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用babel</span><br><span class="line">pnpm add rollup-plugin-babel @babel/core @babel/preset-env</span><br></pre></td></tr></table></figure><h3 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一般的库建议选择MIT协议, 如果涉及专利技术, 则可以选择Apache协议</span><br><span class="line"></span><br><span class="line">npm whoami</span><br><span class="line">npm publish --access public</span><br><span class="line">也可以通过publicConfig字段进行控制</span><br></pre></td></tr></table></figure><h3 id="npm-上忽略文件"><a href="#npm-上忽略文件" class="headerlink" title="npm 上忽略文件"></a>npm 上忽略文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可以创建.npmignore文件</span><br><span class="line"></span><br><span class="line">在package.json中添加字段files: [‘/dist’]</span><br><span class="line">使用npm pack --dry-run 命令可以查看哪些文件会被推送</span><br></pre></td></tr></table></figure><h3 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag 1.0.0</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><h3 id="自定义数据"><a href="#自定义数据" class="headerlink" title="自定义数据"></a>自定义数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">npm命令行为每个执行的命令都提供了pre和post钩子</span><br><span class="line">在执行npm install 命令时, npm实际上会执行3条命令</span><br><span class="line">npm run preinstall</span><br><span class="line">npm run install</span><br><span class="line">npm run postinstall</span><br><span class="line">通过npm提供的postinstall钩子, 既可以实现自定义统计数据</span><br><span class="line">&#123;</span><br><span class="line">  scripts: &#123;</span><br><span class="line">    “postinstall”: ‘node postinstall.js’</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果使用了参数 --ignore-scripts 则会跳过执行postinstall钩子</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="github-action"><a href="#github-action" class="headerlink" title="github action"></a>github action</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个开源库可以用3个workflow</span><br><span class="line">持续集成</span><br><span class="line">发包</span><br><span class="line">部署文档站</span><br></pre></td></tr></table></figure><h3 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">假设有两个库A和C, 当这两个库都依赖同一个库, 但是以来的版本不一致时:</span><br><span class="line">当主版本号一致, 次版本号不一致时, npm安装依赖时, 会自动选择次版本号更大的一个进行安装</span><br><span class="line"></span><br><span class="line">使用npm安装一个库时, 默认会自动在版本号前面添加^</span><br></pre></td></tr></table></figure><h3 id="monorepo"><a href="#monorepo" class="headerlink" title="monorepo"></a>monorepo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yarn workspace 会将依赖安装到根目录, 这样各个项目就可以共享依赖</span><br><span class="line">-A</span><br><span class="line">-B</span><br><span class="line">-C</span><br><span class="line">-node_moudles</span><br><span class="line"></span><br><span class="line">yarn workspace 修改了package.json</span><br><span class="line">添加了 private: true, 避免根目录被发布到npm</span><br><span class="line">workspaces: [‘project1’, ‘project2’]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能揭秘阅读笔记</title>
      <link href="/2023/02/13/qian-duan-xing-neng-jie-mi/"/>
      <url>/2023/02/13/qian-duan-xing-neng-jie-mi/</url>
      
        <content type="html"><![CDATA[<h3 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Devtools提供了过程截屏的能力, 用户可以直观地看到页面的选过程</span><br><span class="line">切换至network面板, 点击setting按钮后勾选Capture screenshots, 这样在刷新页面的同时浏览器会自动吧关键帧的截屏保留下来</span><br></pre></td></tr></table></figure><h3 id="vite-build"><a href="#vite-build" class="headerlink" title="vite build"></a>vite build</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">托管dist文件</span><br><span class="line"></span><br><span class="line">cd dist</span><br><span class="line">npx static-server -z</span><br></pre></td></tr></table></figure><h3 id="performance-API"><a href="#performance-API" class="headerlink" title="performance API"></a>performance API</h3><h4 id="perfomance-now"><a href="#perfomance-now" class="headerlink" title="perfomance.now()"></a>perfomance.now()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">performance.now()</span><br><span class="line">精度精确到微秒</span><br><span class="line">获取的是把页面打开时间点作为基点的相对时间, 不依赖操作系统的时间</span><br></pre></td></tr></table></figure><h3 id="度量首屏"><a href="#度量首屏" class="headerlink" title="度量首屏"></a>度量首屏</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FP(first paint) 第一次绘制时间</span><br><span class="line">FCP(first contentful paint) 第一次绘制出DOM元素的时间</span><br><span class="line">FMP(first meaningful paint) 第一次有意义的绘制(主观) , 替代方案LCP</span><br><span class="line">TTI(time to interaction) 可交互时间</span><br></pre></td></tr></table></figure><h3 id="度量流畅度的指标"><a href="#度量流畅度的指标" class="headerlink" title="度量流畅度的指标"></a>度量流畅度的指标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FPS 每秒传输帧数, 达到60fps就会让用户感觉到非常流畅</span><br><span class="line">使用requestAnimationFrame</span><br><span class="line">FPS降低的根本原因是UI线程被阻塞, 而这种阻塞是由一些长时间未能完成的长任务导致的, 如长时间的js任务执行或代价高昂的浏览器重绘</span><br><span class="line">使用Long Task API 可以定位这些阻塞UI线程的长任务</span><br><span class="line"></span><br><span class="line">const oberver = new PerformanceObserver((list) =&gt; &#123;</span><br><span class="line">    const perfEntries = list.getEntries()</span><br><span class="line">    for (let i = 0; i &lt; perfEntries.length; i++) &#123;</span><br><span class="line">      // 处理长任务, 一般大于50ms会被统计</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  oberver.observe(&#123; entryTypes: [&#x27;longtask&#x27;], buffered: true &#125;)</span><br></pre></td></tr></table></figure><h3 id="最佳实践-Core-Web-Vitals"><a href="#最佳实践-Core-Web-Vitals" class="headerlink" title="最佳实践 Core Web Vitals"></a>最佳实践 Core Web Vitals</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LCP: 首屏视图中最大的元素的渲染时间</span><br><span class="line">浏览器会持续探测页面中占用最大的元素, 这个元素可能会在加载过程中发生变化(如出现了占用体积更大的元素), 直到页面完全加载后, 才会把最终占用面积最大的元素的渲染时间定为LCP探测的元素</span><br><span class="line">LCP是按照元素的渲染完成时间测算的, 如果一个大的图片只是在面积上占用了最大的空间, 但是还没有加载好, 那么浏览器仍然会把当前的LCP元素指向另外一个较小但是已经渲染好的元素</span><br><span class="line">LCP的特点: 更贴近用户体验的首屏, 可以自动测算, 可以解释</span><br></pre></td></tr></table></figure><h3 id="TTFB"><a href="#TTFB" class="headerlink" title="TTFB"></a>TTFB</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指客户端从发起请求到接收到服务器响应的第一个字节的时间, 能够在前端比较客观的反应后端的耗时</span><br></pre></td></tr></table></figure><h3 id="图片使用-base64-的优缺点"><a href="#图片使用-base64-的优缺点" class="headerlink" title="图片使用 base64 的优缺点"></a>图片使用 base64 的优缺点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">可以减少一个图片请求的开支</span><br><span class="line"></span><br><span class="line">缺点</span><br><span class="line">base64会导致图片的体积增大1/3左右</span><br><span class="line">HTML中内联的图片在多次请求之间无法复用缓存</span><br><span class="line">客户端解析base64是需要时间的</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="WebPageTest"><a href="#WebPageTest" class="headerlink" title="WebPageTest"></a>WebPageTest</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WebPageTest是常用的线上性能分析工具, 能对线上的页面进行性能分析, 生成的报告也非常丰富, 除了自身的分析报告, 还包括DevTools timeline, lighthouse报告, 视频对比等.</span><br><span class="line"></span><br><span class="line">https://www.webpagetest.org/</span><br><span class="line"></span><br><span class="line">Start Render: 开始渲染时间, 既非白屏时间</span><br></pre></td></tr></table></figure><h3 id="RTT"><a href="#RTT" class="headerlink" title="RTT"></a>RTT</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Round-Trip Time 往返延迟</span><br><span class="line">指的是从发送端发送数据开始, 到发送端收到来自接收端的确认的时间, 即一来一回的时间, 一般来说, 这个时间由物理距离, 网络传输路径等决定</span><br><span class="line"></span><br><span class="line">在Ping的时候看到的time=xxms, 大致是1个RTT</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="TCP-的连接"><a href="#TCP-的连接" class="headerlink" title="TCP 的连接"></a>TCP 的连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">客户端向服务器发送SYN, 传输seq=X</span><br><span class="line">服务端向客户端发送ACK X+1, 表示收到, 客户端可以将X+1作为seq发送消息, 同时发送SYN, seq=Y, 把自己设置为established状态(可接受数据)</span><br><span class="line">客户端向服务器发送ACK Y+1, 表示收到, 服务器端可以将Y+1作为seq发送消息, 把自己设置为established</span><br><span class="line"></span><br><span class="line">客户端发送完ACK后就认为连接已经建立完毕(而不是等待服务器端收到这个ACK), 并开始传输应用层数据, 服务器收到这个ACK后才会开始把收到的数据交付给应用层</span><br><span class="line"></span><br><span class="line">http1/1/1 TCP建立连接的时间就是一个RTT</span><br><span class="line">htts 还需要加上SSL的时间</span><br><span class="line"></span><br><span class="line">优化: preconnect</span><br></pre></td></tr></table></figure><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用同一个秘钥进行加密和解密</span><br><span class="line"></span><br><span class="line">优点是简单</span><br><span class="line">不安全, 服务器想要保证传输的数据安全, 就得先把密钥传输过来, 而发送密钥的过程本身是不安全的</span><br></pre></td></tr></table></figure><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有一组密钥 分为公钥和私钥 私钥只能一人保管, 公钥可以公布给任何人</span><br><span class="line"></span><br><span class="line">非对称加密算法的加密和解密是用不同的密钥完成的, 也就是说, 私钥加密后的内容可以被公钥的持有者解密, 而公钥加密后的内容只有私钥的持有者能解密</span><br></pre></td></tr></table></figure><h3 id="SSL-TSL-握手"><a href="#SSL-TSL-握手" class="headerlink" title="SSL/TSL 握手"></a>SSL/TSL 握手</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户端校验服务器端的证书</span><br><span class="line">协商生成对称加密使用的密钥</span><br><span class="line"></span><br><span class="line">需要两个RTT</span><br></pre></td></tr></table></figure><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">就http/2而已, 其提高性能的主要手段有, 连接复用, 头部压缩和Server Push</span><br><span class="line"></span><br><span class="line">连接复用</span><br><span class="line">http/1.1 支持Keep-Alive</span><br><span class="line">Keep-Alive用来表示申请服务器端在响应后仍然保持连接. 服务器端可以控制保持连接的时间, 一般为15s, 其实这里复用的并不是http连接, 而是迭戈http请求复用tcp连接</span><br><span class="line"></span><br><span class="line">队头阻塞</span><br><span class="line">由于http请求-响应是一一对应的, 使用同一个连接发送多个http请求会产生队头阻塞问题, 即第二个请求需要等待第一个请求返回后才能发起</span><br><span class="line"></span><br><span class="line">http/2对此提出了更根本的解决方案, 即让http在单个TCP连接内可以发送多个请求, 并且可以乱序返回</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Server-Push"><a href="#Server-Push" class="headerlink" title="Server Push"></a>Server Push</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">服务端需要在响应html时返回一个PUSH_PROMISE帧, 同时把需要推送的内容的html一起返回给客户端, 当客户端试图加载css时, 可以根据PUSH_PROMISE帧的ID读取到对应的流</span><br><span class="line"></span><br><span class="line">Swever Push 无法有效的和本地缓存复用</span><br><span class="line">无法从第三方推送</span><br><span class="line">Server Push 无法从第三方服务器进行推送, 为了尽快发送内容而放弃了CDN在静态资源托管性能上的优势, 往往是得不偿失的</span><br><span class="line"></span><br><span class="line">折中方案</span><br><span class="line">用户通过Cookie去猜测</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="http-3"><a href="#http-3" class="headerlink" title="http/3"></a>http/3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">无论是http/1还是http/2, 都是基于TCP协议的, 这意味着有一些由TCP协议带来的问题很难得到解决</span><br><span class="line"></span><br><span class="line">http2的队头阻塞问题</span><br><span class="line">TCP是可靠传输协议, 虽然两个请求在http层面是乱序的, 但是如果前面的请求出现了丢包, 那么TCP协议必须等待重传的宝按照次序读取出来, 这就是http2的队头阻塞问题</span><br></pre></td></tr></table></figure><h3 id="压缩和缓存"><a href="#压缩和缓存" class="headerlink" title="压缩和缓存"></a>压缩和缓存</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">br压缩比gzip压缩的效果更显著, 但是也会增加服务器端处理耗时</span><br><span class="line"></span><br><span class="line">accept-encoding, content-encoding</span><br></pre></td></tr></table></figure><h3 id="内存泄漏和性能"><a href="#内存泄漏和性能" class="headerlink" title="内存泄漏和性能"></a>内存泄漏和性能</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当页面中出现了比较严重的内存泄漏时, 会产出一下两个结果</span><br><span class="line">内存总是不够, 导致垃圾回收频繁被触发</span><br><span class="line">内存中存在大量对象, 导致垃圾回收算法本身执行得更加缓慢</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>脚手架搭建</title>
      <link href="/2022/12/29/jiao-shou-jia-da-jian/"/>
      <url>/2022/12/29/jiao-shou-jia-da-jian/</url>
      
        <content type="html"><![CDATA[<p>开发脚手架的核心目标: 提升研发效率</p><p>项目共通操作</p><ol><li>创建项目 + 通用代码<ul><li>埋点</li><li>HTTP 请求</li><li>工具方法</li><li>组件库</li></ul></li><li>git 操作<ul><li>创建仓库</li><li>代码冲突</li><li>远程代码同步</li><li>创建版本</li><li>发布打 tag</li></ul></li><li>构建 + 发布上线<ul><li>依赖安装和构建</li><li>资源上传 CDN</li><li>域名绑定</li><li>测试/正式服务器</li></ul></li></ol><h2 id="脚手架核心价值"><a href="#脚手架核心价值" class="headerlink" title="脚手架核心价值"></a>脚手架核心价值</h2><ol><li>自动化: 项目重复代码拷贝/git 操作/发布上线操作</li><li>标准化: 项目创建/git flow/发布流程/回滚流程</li><li>数据化: 研发过程系统化、数据化、使得研发过程可量化</li></ol><h2 id="和自动化构建工具的区别"><a href="#和自动化构建工具的区别" class="headerlink" title="和自动化构建工具的区别"></a>和自动化构建工具的区别</h2><blockquote><p>jenkins、travis 等自动化构建工具已经比较成熟了, 为什么还需要自研脚手架?</p><blockquote><p>不满足需求: jenkins、travis 通常在 git hooks 中触发, 需要服务端执行, 无法覆盖研发人员本地的功能, 如: 创建项目自动化, 本地 git 操作自动化</p></blockquote><blockquote><p>定制复杂: jenkins、travis 定制过程需要开发插件, 其过程较为复杂, 需要使用 java 语言, 对前端同学不够友好</p></blockquote></blockquote><h2 id="从使用角度理解什么是脚手架"><a href="#从使用角度理解什么是脚手架" class="headerlink" title="从使用角度理解什么是脚手架"></a>从使用角度理解什么是脚手架</h2><h3 id="脚手架简介"><a href="#脚手架简介" class="headerlink" title="脚手架简介"></a>脚手架简介</h3><p>脚手架本质是一个==操作系统的客户端==, 它通过命令行执行, 比如:</p><blockquote><p>vue create vue-test-app</p></blockquote><p>上述这条命令由 3 个部分组成:</p><ol><li>主命令: <code>vue</code></li><li>commamd: <code>create</code></li><li>command 的 param: <code>vue-test-app</code></li></ol><p>它表示创建一个 vue 项目, 项目的名称是 vue-test-app, 以上是一个较为简单的脚手架命令, 但实际场景往往更为复杂, 比如:</p><p>当前目录已经有文件了, 我们需要覆盖当前目录下的文件, 强制进行安装 vue 项目, 此时我们就可以输入:</p><blockquote><p>vue create vue-test-app –force (–force 可以理解为–force true 的简写)</p></blockquote><p>这里的<code>--force</code>叫做<code>option</code>, 用来辅助脚手架确认在特定场景下用户的选择(可以理解为配置), 还有一种场景:</p><p>通过<code>vue create</code>创建项目时, 会自动执行<code>npm install</code>帮助用户安装依赖, 如果我们希望使用淘宝源来安装, 可以输入命令:</p><blockquote><p>vue create vue-test-app –force -r <a href="https://reqistry.npm.taobao.org/">https://reqistry.npm.taobao.org</a></p></blockquote><p>这里的<code>-r</code>也叫做 option, 它与<code>--force</code>不同的是它使用<code>-</code>, 并且使用简写, 这里的<code>-</code>也可以替换成<code>--reqistry</code></p><blockquote><p>vue create –help 查看支持的所有 options</p></blockquote><h3 id="脚手架执行原理"><a href="#脚手架执行原理" class="headerlink" title="脚手架执行原理"></a>脚手架执行原理</h3><ol><li>在终端中输入<code>vue create vue-test-app</code></li><li>终端解析出<code>vue</code>指令 (which vue /usr/local/bin/vue)</li><li>终端在环境变量中找到<code>vue</code>命令</li><li>终端根据<code>vue</code>命令链接到实际文件<code>vue.js</code></li><li>终端利用<code>node</code>执行<code>vue.js</code></li><li><code>vue.js</code>解析<code>commamd/options</code></li><li>执行完毕, 退出执行</li></ol><h2 id="从应用的角度看如何开发一个脚手架"><a href="#从应用的角度看如何开发一个脚手架" class="headerlink" title="从应用的角度看如何开发一个脚手架"></a>从应用的角度看如何开发一个脚手架</h2><blockquote><p>以 vue-cli 为例</p></blockquote><ol><li>开发<code>npm</code>项目, 该项目中应包含一个<code>bin/vue.js</code>文件, 并将这个项目发布到<code>npm</code></li><li>将<code>npm</code>项目安装到<code>node</code>的<code>lib/node_modules</code></li><li>在<code>node</code>的<code>bin</code>目录下配置<code>vue</code>软链接指向<code>lib/node_modules/@vue/cli/bin/vue.js</code></li></ol><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ul><li>为什么全局安装<code>@vue/cli</code>后会添加的命令为<code>vue</code>?</li></ul><p>在 package.json 文件中, bin { vue: /bin/vue.js } bin 文件 vue 指向 vue.js</p><blockquote><p>npm install -g @vue-cli</p></blockquote><ul><li><p>全局安装<code>@vue-cli</code>时发生了什么?</p><ol><li>npm 把包下载到 node_modules</li><li>解析 package.json, 在 node bin 目录下创建一个软链接, 指向 bin 配置的文件</li></ol></li><li><p>为什么<code>vue</code>指向了一个<code>js</code>文件, 我们却可以直接通过<code>vue</code>命令直接去执行它?</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env node 使用node执行 命令</span><br><span class="line">创建一个软链接 指向vue.js 文件</span><br></pre></td></tr></table></figure><ul><li>为什么说脚手架的本质是操作系统的客户端? 它和我们在 PC 上安装的应用/软件有什么区别?</li></ul><p>node.exe 是一个可执行文件 node ./test.js 的本质是 node -e ‘console.log(‘123’)’</p><p>本质上没有区别, node 没有提供 gui</p><ul><li>如何为 node 脚手架命令创建别名?</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">添加软链接</span><br><span class="line">cd /usr/local/bin</span><br><span class="line">ln -s 地址 启动名</span><br></pre></td></tr></table></figure><ul><li><p>描述脚手架命令执行的全过程</p><ol><li>在环境变量$PATH 中查询命令 相当于执行 which vue</li><li>查询实际链接文件</li><li>通过#!/usr/bin/env node 执行文件</li></ol></li></ul><h2 id="脚手架开发流程"><a href="#脚手架开发流程" class="headerlink" title="脚手架开发流程"></a>脚手架开发流程</h2><ol><li>创建 npm 项目</li><li>创建脚手架入口文件, 最上方添加<code>#!/usr/bin/env node</code></li><li>配置 package.json, 添加 bin 属性</li><li>编写脚手架代码</li><li>将脚手架发布到 npm</li></ol><h3 id="脚手架开发难点"><a href="#脚手架开发难点" class="headerlink" title="脚手架开发难点"></a>脚手架开发难点</h3><ol><li>分包: 将复杂的系统拆分成若干个模块</li><li>命令注册 如: vue create</li><li>参数解析 如–version -h vue command [options] <params></li><li>帮助文档</li><li>命令行交互</li><li>日志打印</li><li>命令行文字变色</li><li>网络通信: HTTP/WebSocket</li><li>文件处理</li></ol><h3 id="脚手架的本地调试"><a href="#脚手架的本地调试" class="headerlink" title="脚手架的本地调试"></a>脚手架的本地调试</h3><ol><li>创建软链接指向本地目录文件</li><li>在当前文件执行 <code>npm link</code></li></ol><h3 id="分包"><a href="#分包" class="headerlink" title="分包"></a>分包</h3><ol><li>npm link 其他包文件</li><li>本地安装包</li></ol><h3 id="脚手架本地-link-标准流程"><a href="#脚手架本地-link-标准流程" class="headerlink" title="脚手架本地 link 标准流程"></a>脚手架本地 link 标准流程</h3><p>链接本地脚手架</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd your-cli-dir</span><br><span class="line">npm link</span><br></pre></td></tr></table></figure><p>链接本地库文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd your-lib-dir</span><br><span class="line">npm link</span><br><span class="line">cd your-cli-dir</span><br><span class="line">npm link your-lib</span><br></pre></td></tr></table></figure><p>取消链接本地库文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd your-lib-dir</span><br><span class="line">npm unlink</span><br><span class="line">cd your-cli-dir</span><br><span class="line"></span><br><span class="line">#link存在</span><br><span class="line">npm unlink your-lib</span><br><span class="line"></span><br><span class="line">#link不存在</span><br><span class="line">rm -rf node_modules</span><br><span class="line">npm install your-lib</span><br></pre></td></tr></table></figure><h3 id="脚手架命令注册和参数解析"><a href="#脚手架命令注册和参数解析" class="headerlink" title="脚手架命令注册和参数解析"></a>脚手架命令注册和参数解析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br><span class="line">const lib = require(&#x27;tut-lib/lib&#x27;)</span><br><span class="line"></span><br><span class="line">// 注册一个命令 tut init</span><br><span class="line">const argv = require(&#x27;process&#x27;).argv</span><br><span class="line">const command = argv[2]</span><br><span class="line">const options = argv.slice(3)</span><br><span class="line">let [option, param] = options</span><br><span class="line">if (option) &#123;</span><br><span class="line">  option = option.replace(/^--/, &#x27;&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lib[command] &amp;&amp; lib[command](&#123; option, param &#125;)</span><br><span class="line"></span><br><span class="line">// 实现参数解析 --version 和 init --name</span><br><span class="line">const versionReg = /^-&#123;1,2&#125;/</span><br><span class="line">if (versionReg.test(command)) &#123;</span><br><span class="line">  const globOption = command.replace(versionReg, &#x27;&#x27;)</span><br><span class="line">  if ([&#x27;version&#x27;, &#x27;V&#x27;].includes(globOption)) &#123;</span><br><span class="line">    fs.readFile(&#x27;./package.json&#x27;, &#x27;utf-8&#x27;, function (err, data) &#123;</span><br><span class="line">      if (err) return</span><br><span class="line">      const &#123; version &#125; = JSON.parse(data)</span><br><span class="line">      console.log(&#x27;version: &#x27;, version)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="脚手架框架"><a href="#脚手架框架" class="headerlink" title="脚手架框架"></a>脚手架框架</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Plop</span><br><span class="line">yeoman-generator -&gt; vscode插件</span><br><span class="line"></span><br><span class="line">Schematics</span><br><span class="line">配合schematics-utilities可以做到语法级别的样板代码生成</span><br><span class="line">引入了虚拟文件系统, 可以保证写入原子性</span><br><span class="line">支持多个schametics之间的组合和管道</span><br><span class="line"></span><br><span class="line">ink</span><br><span class="line">react开发cli应用</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Lerna-学习"><a href="#Lerna-学习" class="headerlink" title="Lerna 学习"></a>Lerna 学习</h2><h3 id="原生脚手架开发痛点分析"><a href="#原生脚手架开发痛点分析" class="headerlink" title="原生脚手架开发痛点分析"></a>原生脚手架开发痛点分析</h3><ul><li><p>痛点一: 重复操作</p><ol><li>多 Package 本地 link</li><li>多 Package 依赖安装</li><li>多 Package 单元测试</li><li>多 Package 代码提交</li><li>多 Package 代码发布</li></ol></li><li><p>痛点二: 版本一致性</p><ol><li>发布时版本一致性</li><li>发布后互相依赖版本升级 (lerna link)</li></ol></li></ul><h3 id="Lerna-简介"><a href="#Lerna-简介" class="headerlink" title="Lerna 简介"></a>Lerna 简介</h3><blockquote><p>Lerna 是一个优化基于 git + npm 的多 Package 项目的管理工具</p></blockquote><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li>大幅减少重复操作</li><li>提升操作的标准化</li></ol><blockquote><p>Lerna 是架构优化的产物, 它揭示了一个架构真理: 项目复杂度提升后, 就需要对项目进行架构优化, 架构优化的主要目标往往都是以效能为核心. lerna 的主仓库必须是私有的</p></blockquote><h3 id="Lerna-开发脚手架流程"><a href="#Lerna-开发脚手架流程" class="headerlink" title="Lerna 开发脚手架流程"></a>Lerna 开发脚手架流程</h3><h4 id="脚手架项目初始化"><a href="#脚手架项目初始化" class="headerlink" title="脚手架项目初始化"></a>脚手架项目初始化</h4><ol><li>初始化 npm 项目</li><li>安装 lerna</li><li>lerna init 初始化项目</li></ol><h4 id="创建-package"><a href="#创建-package" class="headerlink" title="创建 package"></a>创建 package</h4><ol><li>lerna create 创建 package</li><li>lerna add 为指定 package 安装依赖 lerna add package utils/</li><li>lerna link 链接依赖</li><li>lerna init</li></ol><h4 id="脚手架开发和测试"><a href="#脚手架开发和测试" class="headerlink" title="脚手架开发和测试"></a>脚手架开发和测试</h4><ol><li>lerna exec – (–scope + 包名)执行 shell 脚本 在每一个 package 中执行操作</li><li>lerna run (–scoped + 包名) 执行 npm 命令 (可以用来执行单测)</li><li>lerna clean 清空依赖</li><li>lerna bootstrap 重装依赖</li><li>lerna bootstrap –hoist 依赖安装到根目录</li></ol><h4 id="脚手架发布上线"><a href="#脚手架发布上线" class="headerlink" title="脚手架发布上线"></a>脚手架发布上线</h4><blockquote><p>package.json publishConfig{.”access”: “public” }</p></blockquote><ol><li>lerna version bump version (提升版本号)</li><li>lerna changed 查看上版本以来的所有变更</li><li>lerna diff 查看 diff</li><li>lerna publish 项目发布 发布后会给 git 仓库推一个 tag</li></ol><h2 id="脚手架核心流程开发"><a href="#脚手架核心流程开发" class="headerlink" title="脚手架核心流程开发"></a>脚手架核心流程开发</h2><h3 id="core-模块技术方案"><a href="#core-模块技术方案" class="headerlink" title="core 模块技术方案"></a>core 模块技术方案</h3><h4 id="命令执行流程"><a href="#命令执行流程" class="headerlink" title="命令执行流程"></a>命令执行流程</h4><h5 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prepare</span><br><span class="line">检查版本号-&gt;检查node版本-&gt;检查root启动-&gt;检查用户主目录-&gt;检查入参-&gt;检查环境变量-&gt;检查是否为最新版本-&gt;提示更新</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">核心库</span><br><span class="line">import-local</span><br><span class="line">commander</span><br><span class="line">inquirer</span><br><span class="line">工具库</span><br><span class="line">npmlog</span><br><span class="line">fs-extra</span><br><span class="line">semver // 版本匹配/比对</span><br><span class="line">colors // 终端打印不同颜色的文本</span><br><span class="line">path-exists</span><br><span class="line">user-home // 快速拿到用户主目录</span><br><span class="line">minimist // 解析argument参数</span><br><span class="line">dotenv // 拿到环境变量</span><br><span class="line">url-join</span><br><span class="line">root-check // 降级权限</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">&#x27;use strict&#x27;</span><br><span class="line"></span><br><span class="line">module.exports = core</span><br><span class="line"></span><br><span class="line">// require 支持加载的类型 .js .json .node(C++)</span><br><span class="line">// any =&gt; 通过.js进行解析</span><br><span class="line">const semver = require(&#x27;semver&#x27;)</span><br><span class="line">const colors = require(&#x27;colors/safe&#x27;)</span><br><span class="line">const userHome = require(&#x27;user-home&#x27;)</span><br><span class="line">const pathExists = require(&#x27;path-exists&#x27;).sync</span><br><span class="line"></span><br><span class="line">const pkg = require(&#x27;../package.json&#x27;)</span><br><span class="line">const log = require(&#x27;@tut-cli-dev/log&#x27;)</span><br><span class="line">const &#123; getNpmSemverVersion &#125; = require(&#x27;@tut-cli-dev/get-npm-info&#x27;)</span><br><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">const &#123; LOWEST_NODE_VERSION, DEFAULT_CLI_HOME &#125; = require(&#x27;./const&#x27;)</span><br><span class="line"></span><br><span class="line">let args</span><br><span class="line"></span><br><span class="line">async function core(argvs) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    checkPackageVersion()</span><br><span class="line">    checkNodeVersion()</span><br><span class="line">    checkRoot()</span><br><span class="line">    checkUserHome()</span><br><span class="line">    checkInputArgs(argvs)</span><br><span class="line">    checkEnv()</span><br><span class="line">    await checkGlobalUpdate()</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    // NOTICE</span><br><span class="line">    log.error(e.message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function checkPackageVersion() &#123;</span><br><span class="line">  log.notice(&#x27;cli&#x27;, pkg.version)</span><br><span class="line">&#125;</span><br><span class="line">function checkNodeVersion() &#123;</span><br><span class="line">  const currentVersion = process.version</span><br><span class="line">  if (!semver.gte(currentVersion, LOWEST_NODE_VERSION)) &#123;</span><br><span class="line">    throw new Error(</span><br><span class="line">      colors.red(`tut-cli 需要安装$&#123;LOWEST_NODE_VERSION&#125;以上的node版本`)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function checkRoot() &#123;</span><br><span class="line">  const rootCheck = require(&#x27;root-check&#x27;)</span><br><span class="line">  // core: invode process.setuid()</span><br><span class="line">  rootCheck()</span><br><span class="line">  // 管理员为0 使用rootCheck =&gt; 管理员不为0</span><br><span class="line">  // console.log(process.getuid())</span><br><span class="line">&#125;</span><br><span class="line">function checkUserHome() &#123;</span><br><span class="line">  if (!userHome || !pathExists(userHome)) &#123;</span><br><span class="line">    throw new Error(colors.red(&#x27;用户主目录不存在!&#x27;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function checkInputArgs(argvs) &#123;</span><br><span class="line">  const minimist = require(&#x27;minimist&#x27;)</span><br><span class="line">  args = minimist(argvs)</span><br><span class="line">  checkArgs()</span><br><span class="line">  // console.log(&#x27;args: &#x27;, args) // args:  &#123; _: [ &#x27;init&#x27;, &#x27;u&#x27; ], g: true &#125;</span><br><span class="line">&#125;</span><br><span class="line">function checkArgs() &#123;</span><br><span class="line">  if (args.debug) &#123;</span><br><span class="line">    process.env.LOG_LEVEL = &#x27;verbose&#x27;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    process.env.LOG_LEVEL = &#x27;info&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  // NOTICE</span><br><span class="line">  log.level = process.env.LOG_LEVEL</span><br><span class="line">&#125;</span><br><span class="line">function checkEnv() &#123;</span><br><span class="line">  // process.cwd() 返回 Node.js 进程当前工作的目录</span><br><span class="line">  const dotenv = require(&#x27;dotenv&#x27;)</span><br><span class="line">  const dotenvPath = path.resolve(userHome, &#x27;.env&#x27;)</span><br><span class="line">  if (pathExists(dotenvPath)) &#123;</span><br><span class="line">    dotenv.config(&#123; path: dotenvPath &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  createDefaultConfig()</span><br><span class="line">  log.verbose(&#x27;缓存路径&#x27;, process.env.CLI_HOME_PATH)</span><br><span class="line">&#125;</span><br><span class="line">function createDefaultConfig() &#123;</span><br><span class="line">  const cliConfig = &#123; home: userHome &#125;</span><br><span class="line">  if (process.env.CLI_HOME) &#123;</span><br><span class="line">    cliConfig.cliHome = path.join(userHome, process.env.CLI_HOME)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    cliConfig.cliHome = path.join(userHome, DEFAULT_CLI_HOME)</span><br><span class="line">  &#125;</span><br><span class="line">  // BETTER 对环境变量的值处理后生成新的环境变量</span><br><span class="line">  process.env.CLI_HOME_PATH = cliConfig.cliHome</span><br><span class="line">  // return cliConfig</span><br><span class="line">&#125;</span><br><span class="line">async function checkGlobalUpdate() &#123;</span><br><span class="line">  // 1. 获取当前版本号和模块名</span><br><span class="line">  // 2. 调用npmApi, 获取所有版本号 https://registry.npmjs.org/@tut-cli-dev/core</span><br><span class="line">  // 3. 提取所有版本号, 比对当前版本号, 如果当前版本号小于最新版本号, 提示更新</span><br><span class="line">  // 4. 提示用户更新到最新版本</span><br><span class="line">  const currentVersion = pkg.version</span><br><span class="line">  const npmName = pkg.name</span><br><span class="line">  const lastVersion = await getNpmSemverVersion(currentVersion, npmName)</span><br><span class="line">  if (lastVersion &amp;&amp; semver.gt(lastVersion, currentVersion)) &#123;</span><br><span class="line">    log.warn(</span><br><span class="line">      colors.yellow(</span><br><span class="line">        `当前版本号$&#123;currentVersion&#125;不是最新版本号$&#123;lastVersion&#125;, 请更新到最新版本</span><br><span class="line">         更新命令: npm install -g $&#123;npmName&#125;@$&#123;lastVersion&#125;`</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>@get-npm-info</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#x27;use strict&#x27;</span><br><span class="line"></span><br><span class="line">const axios = require(&#x27;axios&#x27;)</span><br><span class="line">const urlJoin = require(&#x27;url-join&#x27;)</span><br><span class="line">const semver = require(&#x27;semver&#x27;)</span><br><span class="line"></span><br><span class="line">function getNpmInfo(npmName, registry) &#123;</span><br><span class="line">  if (!npmName) return null</span><br><span class="line">  const registryUrl = registry || getDefaultRegistry(true)</span><br><span class="line">  const npmInfoUrl = urlJoin(registryUrl, npmName)</span><br><span class="line">  return axios</span><br><span class="line">    .get(npmInfoUrl)</span><br><span class="line">    .then((res) =&gt; &#123;</span><br><span class="line">      if (res.status === 200) &#123;</span><br><span class="line">        return res.data</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return null</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch((err) =&gt; &#123;</span><br><span class="line">      throw Promise.reject(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getDefaultRegistry(isOriginal = false) &#123;</span><br><span class="line">  return isOriginal</span><br><span class="line">    ? &#x27;https://registry.npmjs.org&#x27;</span><br><span class="line">    : &#x27;https://registry.npm.taobao.org&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function getNpmVersions(npmName, registry) &#123;</span><br><span class="line">  const data = await getNpmInfo(npmName, registry)</span><br><span class="line">  if (!data) return []</span><br><span class="line">  return Object.keys(data.versions)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getSemverVersions(baseVersion, versions) &#123;</span><br><span class="line">  versions = versions</span><br><span class="line">    .filter((version) =&gt; &#123;</span><br><span class="line">      return semver.satisfies(version, `^$&#123;baseVersion&#125;`)</span><br><span class="line">    &#125;)</span><br><span class="line">    .sort((a, b) =&gt; semver.gt(b, a))</span><br><span class="line">  return versions</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function getNpmSemverVersion(baseVersion, npmName, registry) &#123;</span><br><span class="line">  const versions = await getNpmVersions(npmName, registry)</span><br><span class="line">  const newVersions = getSemverVersions(baseVersion, versions)</span><br><span class="line">  if (newVersions &amp;&amp; newVersions.length &gt; 0) &#123;</span><br><span class="line">    return newVersions[0]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  getNpmInfo,</span><br><span class="line">  getNpmVersions,</span><br><span class="line">  getNpmSemverVersion</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="命令注册"><a href="#命令注册" class="headerlink" title="命令注册"></a>命令注册</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">registerCommand</span><br><span class="line">注册init命令 -&gt; 注册publish命令 -&gt; 注册clean命令 -&gt; 支持debug</span><br><span class="line"></span><br><span class="line">commander</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br><span class="line"></span><br><span class="line">const utils = require(&#x27;@tut-cli-dev/utils&#x27;)</span><br><span class="line">// 全局安装的包如果本地有安装,优先用本地的</span><br><span class="line">const importLocal = require(&#x27;import-local&#x27;)</span><br><span class="line">const colors = require(&#x27;colors&#x27;)</span><br><span class="line">const commander = require(&#x27;commander&#x27;)</span><br><span class="line">const pkg = require(&#x27;../package.json&#x27;)</span><br><span class="line"></span><br><span class="line">// 获取commanderd单例</span><br><span class="line">// const &#123; program &#125; = commander</span><br><span class="line">// 手动实例化一个commander</span><br><span class="line">const program = new commander.Command()</span><br><span class="line">program</span><br><span class="line">  .name(Object.keys(pkg.bin)[0])</span><br><span class="line">  .usage(&#x27;&lt;command&gt; [options]&#x27;)</span><br><span class="line">  .version(pkg.version)</span><br><span class="line">  .option(&#x27;-d, --debug&#x27;, &#x27;是否启动调试模式&#x27;, false)</span><br><span class="line">  .option(&#x27;-e, --env &lt;envName&gt;&#x27;, &#x27;获取环境变量名称&#x27;)</span><br><span class="line">// commmand api注册命令</span><br><span class="line">// []: 可填项 &lt;&gt;必填项</span><br><span class="line">const clone = program.command(&#x27;clone &lt;source&gt; [destination]&#x27;)</span><br><span class="line">// 这里不能连写 初始化clone(program.command)会返回一个新的command对象</span><br><span class="line">clone</span><br><span class="line">  .description(&#x27;clone a repository&#x27;)</span><br><span class="line">  .option(&#x27;-f, --force&#x27;, &#x27;是否强制克隆&#x27;)</span><br><span class="line">  .action((source, destination, cmdObj) =&gt; &#123;</span><br><span class="line">    // cmdObj 当前command</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">// addCommnad 注册子命令</span><br><span class="line">const service = new commander.Command(&#x27;service&#x27;)</span><br><span class="line">service.description(&#x27;some server options&#x27;)</span><br><span class="line"></span><br><span class="line">service</span><br><span class="line">  .command(&#x27;start [port]&#x27;)</span><br><span class="line">  .description(&#x27;start service at some port&#x27;)</span><br><span class="line">  .action((port) =&gt; &#123;</span><br><span class="line">    console.log(port)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">service</span><br><span class="line">  .command(&#x27;stop&#x27;)</span><br><span class="line">  .description(&#x27;stop service&#x27;)</span><br><span class="line">  .action(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;stop service&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">program.addCommand(service)</span><br><span class="line"></span><br><span class="line">// 高级定制 实现debug 模式</span><br><span class="line">program.on(&#x27;option:debug&#x27;, function () &#123;</span><br><span class="line">  if (this.opts().debug) &#123;</span><br><span class="line">    process.env.LOG_LEVEL = &#x27;verbose&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 高级定制 对未知命令监听</span><br><span class="line">program.on(&#x27;command:*&#x27;, function (unknowCmdList) &#123;</span><br><span class="line">  console.log(colors.red(`未知的命令: $&#123;unknowCmdList.join(&#x27;、&#x27;)&#125;`))</span><br><span class="line">  const availableCommands = program.commands.map((cmd) =&gt; cmd.name())</span><br><span class="line">  console.log(colors.green(`可用的命令: $&#123;availableCommands.join(&#x27;、&#x27;)&#125;`))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 监听所有的命令输入, 处理未定义的命令</span><br><span class="line">// program</span><br><span class="line">//   .arguments(&#x27;[command] [options]&#x27;)</span><br><span class="line">//   .description(&#x27;test command&#x27;, &#123;</span><br><span class="line">//     command: &#x27;command to run&#x27;,</span><br><span class="line">//     options: &#x27;options for command&#x27;</span><br><span class="line">//   &#125;)</span><br><span class="line">//   .action((cmd, env) =&gt; &#123;</span><br><span class="line">//     // console.log(cmd, env)</span><br><span class="line">//   &#125;)</span><br><span class="line"></span><br><span class="line">// 通过独立的的可执行文件实现命令 (注意这里指令描述是作为`.command`的第二个参数)</span><br><span class="line">// 多脚手架串用 tut install init =&gt; tut-i init</span><br><span class="line">program</span><br><span class="line">  .command(&#x27;install [name]&#x27;, &#x27;install package&#x27;, &#123;</span><br><span class="line">    executableFile: &#x27;tut-i&#x27;, // 修改可执行文件名称</span><br><span class="line">    isDefault: false,</span><br><span class="line">    hidden: true</span><br><span class="line">  &#125;)</span><br><span class="line">  .alias(&#x27;i&#x27;) // tut-install</span><br><span class="line"></span><br><span class="line">// 高级定制: 自定义help内容</span><br><span class="line">// program.helpInformation = function () &#123;</span><br><span class="line">//   return &#x27;info&#x27;</span><br><span class="line">// &#125;</span><br><span class="line">// program.on(&#x27;--help&#x27;, function () &#123;</span><br><span class="line">//   console.log(&#x27;info&#x27;)</span><br><span class="line">// &#125;)</span><br><span class="line"></span><br><span class="line">program.parse(process.argv)</span><br><span class="line">// program.outputHelp()</span><br><span class="line">// console.log(program.opts())</span><br><span class="line">// __filename 获取当前目录</span><br><span class="line">// __dirname 获取当前目录的父目录</span><br><span class="line"></span><br><span class="line">// if (importLocal(__filename)) &#123;</span><br><span class="line">// &#125; else &#123;</span><br><span class="line">//   // 去除node路径和bin路径</span><br><span class="line">//   require(&#x27;../lib/index.js&#x27;)(process.argv.slice(2))</span><br><span class="line">// &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="痛点分析"><a href="#痛点分析" class="headerlink" title="痛点分析"></a>痛点分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">core cli</span><br><span class="line">commamds init</span><br><span class="line">models</span><br><span class="line">utils get-npm-info log utils</span><br><span class="line"></span><br><span class="line">问题</span><br><span class="line">1. cli 安装速度慢: 所有package都集成在cli里, 因此当命令较多时, 会减慢cli的安装速度</span><br><span class="line">2. 灵活性差: init 命令只能使用@tut-cli-dev/init, 对于集团公司而言, 每个部门的init命令可能都不相同, 可能需要实现init命令动态化</span><br></pre></td></tr></table></figure><h4 id="流程改进"><a href="#流程改进" class="headerlink" title="流程改进"></a>流程改进</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">脚手架启动阶段 =&gt; commander脚手架初始化 =&gt; 动态加载initCommand =&gt; new initCommand =&gt; Command constructor =&gt; 命令的准备阶段 =&gt; 命令的执行阶段 =&gt; init业务逻辑 =&gt; end</span><br></pre></td></tr></table></figure><p>￼<img "" class="lazyload placeholder" data-original="assets/IMG_6.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="图片"></p><p>￼<img "" class="lazyload placeholder" data-original="assets/IMG_7.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="图片"></p><h3 id="脚手架创建项目流程设计和开发"><a href="#脚手架创建项目流程设计和开发" class="headerlink" title="脚手架创建项目流程设计和开发"></a>脚手架创建项目流程设计和开发</h3><h4 id="脚手架背后的思考"><a href="#脚手架背后的思考" class="headerlink" title="脚手架背后的思考"></a>脚手架背后的思考</h4><ol><li>可拓展: 能够快速复用到不同的团队, 适用不同团队之间的差异</li><li>低成本: 在不改动脚手架源码的情况下, 能够新增模版, 且新增模版的成本很低</li><li>高性能: 控制存储空间, 安装时充分利用 Node 多进程提升安装性能</li></ol><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p><img "" class="lazyload placeholder" data-original="assets/IMG_8.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="图片"></p><p><img "" class="lazyload placeholder" data-original="assets/IMG_9.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="图片"></p><p><img "" class="lazyload placeholder" data-original="assets/IMG_10.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="图片"></p><h4 id="inquirer-命令行交互"><a href="#inquirer-命令行交互" class="headerlink" title="inquirer 命令行交互"></a>inquirer 命令行交互</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">async getProjectInfo() &#123;</span><br><span class="line">    let projectInfo = &#123;&#125;</span><br><span class="line">    // 3. 选择创建项目或组件</span><br><span class="line">    const &#123; type &#125; = await inquirer.prompt(&#123;</span><br><span class="line">      type: &#x27;list&#x27;,</span><br><span class="line">      name: &#x27;type&#x27;,</span><br><span class="line">      message: &#x27;请选择初始化类型&#x27;,</span><br><span class="line">      default: TYPE_PROJECT,</span><br><span class="line">      choices: [</span><br><span class="line">        &#123; name: &#x27;项目&#x27;, value: TYPE_PROJECT &#125;,</span><br><span class="line">        &#123; name: &#x27;组件&#x27;, value: TYPE_COMPONENT &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;)</span><br><span class="line">    log.verbose(&#x27;type&#x27;, type)</span><br><span class="line">    if (type === TYPE_PROJECT) &#123;</span><br><span class="line">      // 4. 获取项目的基本信息</span><br><span class="line">      const project = await inquirer.prompt([</span><br><span class="line">        &#123;</span><br><span class="line">          type: &#x27;input&#x27;,</span><br><span class="line">          name: &#x27;projectName&#x27;,</span><br><span class="line">          message: &#x27;请输入项目名称&#x27;,</span><br><span class="line">          validate: function (v) &#123;</span><br><span class="line">            // 1. 输入的首字符必须为英文字符</span><br><span class="line">            // 2. 尾字符必须为英文或数字, 不能为字符</span><br><span class="line">            // 3. 字符仅仅允许&#x27;-_&#x27;</span><br><span class="line"></span><br><span class="line">            // tip</span><br><span class="line">            const done = this.async()</span><br><span class="line"></span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">              if (</span><br><span class="line">                !/^[a-zA-Z]+(-[a-zA-Z][a-zA-Z0-9]*|_[a-zA-Z][a-zA-Z0-9]*|[a-zA-Z0-9])*$/.test(v)</span><br><span class="line">              ) &#123;</span><br><span class="line">                done(&#x27;请输入合法的项目名称&#x27;)</span><br><span class="line">                return</span><br><span class="line">              &#125;</span><br><span class="line">              done(null, true)</span><br><span class="line">            &#125;, 0)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          type: &#x27;input&#x27;,</span><br><span class="line">          name: &#x27;projectVersion&#x27;,</span><br><span class="line">          message: &#x27;请输入项目版本号&#x27;,</span><br><span class="line">          validate: function (v) &#123;</span><br><span class="line">            const done = this.async()</span><br><span class="line"></span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">              if (!semver.valid(v)) &#123;</span><br><span class="line">                done(&#x27;请输入合法的版本号&#x27;)</span><br><span class="line">                return</span><br><span class="line">              &#125;</span><br><span class="line">              done(null, true)</span><br><span class="line">            &#125;, 0)</span><br><span class="line">          &#125;,</span><br><span class="line">          filter: function (v) &#123;</span><br><span class="line">            if (!!semver.valid(v)) &#123;</span><br><span class="line">              return semver.valid(v)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              return v</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ])</span><br><span class="line">      projectInfo = &#123;</span><br><span class="line">        type,</span><br><span class="line">        ...project</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (type === TYPE_COMPONENT) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return projectInfo</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="脚手架创建项目和组件功能开发"><a href="#脚手架创建项目和组件功能开发" class="headerlink" title="脚手架创建项目和组件功能开发"></a>脚手架创建项目和组件功能开发</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">下载模版</span><br><span class="line">安装依赖</span><br><span class="line">拷贝模版代码至当前目录</span><br><span class="line">依赖安装(white hosue )</span><br><span class="line">const WHITE_COMMAND = [&#x27;npm&#x27;, &#x27;cnpm&#x27;, &#x27;yarn&#x27;, &#x27;pnpm&#x27;]</span><br><span class="line">启动执行命令</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚手架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见数据结构与算法</title>
      <link href="/2022/04/09/shu-ju-jie-gou-yu-suan-fa/"/>
      <url>/2022/04/09/shu-ju-jie-gou-yu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><blockquote><p>数组与链表</p></blockquote><p>数组是连续的存储空间，链表是通过 next 指针连接，内存空间不连续。</p><p>数组：查找快 o(1)，修改慢 o(n)，增删非收尾元素需要移动元素</p><p>链表：查找慢 o(n)，修改快 o(1)，增删非首尾元素，只需要更改 next 的指向即可</p><p>使用 Object 模拟链表</p><h5 id="将一个数组旋转-k-步"><a href="#将一个数组旋转-k-步" class="headerlink" title="将一个数组旋转 k 步"></a>将一个数组旋转 k 步</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function rotate(arr: number[], step: number): number[] &#123;</span><br><span class="line">  let cut = arr.splice(-step)</span><br><span class="line">  console.log(arr)</span><br><span class="line">  return cut.concat(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="用-JS-实现快速排序，并说明时间复杂度"><a href="#用-JS-实现快速排序，并说明时间复杂度" class="headerlink" title="用 JS 实现快速排序，并说明时间复杂度"></a>用 JS 实现快速排序，并说明时间复杂度</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h5 id="判断字符串是否括号匹配"><a href="#判断字符串是否括号匹配" class="headerlink" title="判断字符串是否括号匹配"></a>判断字符串是否括号匹配</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function isValid(s) &#123;</span><br><span class="line">  // 如果为奇数，直接返回false</span><br><span class="line">  if (s.length &amp; 1 === 1) return false</span><br><span class="line">  const stack = []</span><br><span class="line">  for (let i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">    const c = s[i]</span><br><span class="line">    if (&#x27;(&#123;[&#x27;.includes(c)) &#123;</span><br><span class="line">      stack.push(c)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      const t = stack[stack.length - 1]</span><br><span class="line">      if (c === &#x27;)&#x27; &amp;&amp; t === &#x27;(&#x27; || c === &#x27;]&#x27; &amp;&amp; t === &#x27;[&#x27; || c === &#x27;&#125;&#x27; &amp;&amp; t === &#x27;&#123;&#x27;) &#123;</span><br><span class="line">        stack.pop()</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return stack.length === 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="反转单向链表"><a href="#反转单向链表" class="headerlink" title="反转单向链表"></a>反转单向链表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">interface ILinkListNode &#123;</span><br><span class="line">  value: number</span><br><span class="line">  next?: ILinkListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createLinkList(arr: number[]): ILinkListNode &#123;</span><br><span class="line">  const length = arr.length</span><br><span class="line">  if (length == 0) throw new Error(&#x27;arr is empty&#x27;)</span><br><span class="line">  let curNode: ILinkListNode = &#123;</span><br><span class="line">    value: arr[arr.length - 1],</span><br><span class="line">  &#125;</span><br><span class="line">  if (length === 1) return curNode</span><br><span class="line"></span><br><span class="line">  for (let i = length - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">    curNode = &#123;</span><br><span class="line">      value: arr[i],</span><br><span class="line">      next: curNode,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return curNode</span><br><span class="line">&#125;</span><br><span class="line">function reverseList(list: ILinkListNode): ILinkListNode &#123;</span><br><span class="line">  let p1 = null</span><br><span class="line">  let p2: any = list</span><br><span class="line">  while (p2) &#123;</span><br><span class="line">    const next = p2.next</span><br><span class="line">    p2.next = p1</span><br><span class="line">    p1 = p2</span><br><span class="line">    p2 = next</span><br><span class="line">  &#125;</span><br><span class="line">  return p1</span><br><span class="line">&#125;</span><br><span class="line">const arr = [1, 2, 3, 4, 6]</span><br><span class="line">console.log(reverseList(createLinkList(arr)))</span><br></pre></td></tr></table></figure><h5 id="链表和数组，那个实现队列更快？"><a href="#链表和数组，那个实现队列更快？" class="headerlink" title="链表和数组，那个实现队列更快？"></a>链表和数组，那个实现队列更快？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">队列：逻辑结构</span><br><span class="line">数组：连续存储，push很快，shift很慢</span><br><span class="line">链表：非连续存储，add和delete很快，查找很慢</span><br><span class="line">结论：链表实现队列更快</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">链表实现队列</span><br><span class="line">1.单向链表，但要同时记录head和tail</span><br><span class="line">2.要从tail入队，从head出队</span><br><span class="line">3.实时记录length，不可遍历链表获取</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class quene &#123;</span><br><span class="line">  len = 0</span><br><span class="line">  tail = null</span><br><span class="line">  head = null</span><br><span class="line"></span><br><span class="line">  add(item) &#123;</span><br><span class="line">    const newNode = &#123;</span><br><span class="line">      value: item,</span><br><span class="line">      next: null</span><br><span class="line">    &#125;</span><br><span class="line">    if (!this.head) &#123;</span><br><span class="line">      this.head = newNode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const tailNode = this.tail</span><br><span class="line">    if (tailNode) &#123;</span><br><span class="line">      tailNode.next = newNode</span><br><span class="line">    &#125;</span><br><span class="line">    this.tail = newNode</span><br><span class="line">    this.len++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delete() &#123;</span><br><span class="line">    const headNode = this.head</span><br><span class="line">    if (!headNode) return</span><br><span class="line">    if (this.len &lt;= 0) return</span><br><span class="line">    headNode = headNode.next</span><br><span class="line">    this.len--</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get length() &#123;</span><br><span class="line">    return this.len</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="用-js-实现二分查找，并说明时间复杂度"><a href="#用-js-实现二分查找，并说明时间复杂度" class="headerlink" title="用 js 实现二分查找，并说明时间复杂度"></a>用 js 实现二分查找，并说明时间复杂度</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">思路：递归</span><br><span class="line">非递归：性能好</span><br><span class="line">O(logn)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function binarySearch1(arr, target) &#123;</span><br><span class="line">  const length = arr.length</span><br><span class="line">  if (arr.length === 0) return -1</span><br><span class="line">  let startIndex = 0</span><br><span class="line">  let endIndex = length - 1</span><br><span class="line"></span><br><span class="line">  while (startIndex &lt;= endIndex) &#123;</span><br><span class="line">    // const midIndex = Math.floor(startIndex + endIndex / 2)</span><br><span class="line">    let midIndex = (startIndex + endIndex) &gt;&gt;&gt; 1</span><br><span class="line">    let midValue = arr[midIndex]</span><br><span class="line">    if (target &lt; midValue) &#123;</span><br><span class="line">      endIndex = midIndex - 1</span><br><span class="line">    &#125; else if (target &gt; midValue) &#123;</span><br><span class="line">      startIndex = midIndex + 1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return midIndex</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="给一个数组，找出其中和为-n-的两个元素"><a href="#给一个数组，找出其中和为-n-的两个元素" class="headerlink" title="给一个数组，找出其中和为 n 的两个元素"></a>给一个数组，找出其中和为 n 的两个元素</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getElement(arr, target) &#123;</span><br><span class="line">  const bucket = new Map()</span><br><span class="line">  for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    const res = target - arr[i]</span><br><span class="line">    if (res &gt;= target) return -1</span><br><span class="line">    if (bucket.has(res)) &#123;</span><br><span class="line">      return [bucket.get(res), i]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      bucket.set(arr[i], i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="求一个二叉搜索树的第-k-小值"><a href="#求一个二叉搜索树的第-k-小值" class="headerlink" title="求一个二叉搜索树的第 k 小值"></a>求一个二叉搜索树的第 k 小值</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">二叉树的遍历</span><br><span class="line">前序遍历：root left right</span><br><span class="line">中序遍历：left root right</span><br><span class="line">后序遍历：left right root</span><br><span class="line">BST</span><br><span class="line">left (包括其后代)value &lt;= root value</span><br><span class="line">right(包括其后代)value &gt;= root value</span><br></pre></td></tr></table></figure><h5 id="为什么二叉树如此重要，而不是三叉树、四叉树？"><a href="#为什么二叉树如此重要，而不是三叉树、四叉树？" class="headerlink" title="为什么二叉树如此重要，而不是三叉树、四叉树？"></a>为什么二叉树如此重要，而不是三叉树、四叉树？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">二分</span><br><span class="line">二叉树 查找快 增删快</span><br><span class="line">BST如果不平衡，就变成链表 O(logn) =&gt; O(n)</span><br><span class="line">所以少尽量平衡 平衡二叉搜索树BBST 增删改查都是O(logn) 大概等于数的高度</span><br><span class="line">红黑树 一种自平衡二叉树 分为红黑两种颜色，通过颜色转换来维持树的平衡</span><br></pre></td></tr></table></figure><h5 id="堆栈模型"><a href="#堆栈模型" class="headerlink" title="堆栈模型"></a>堆栈模型</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JS执行时 值类型变量存储在栈 引用类型变量存储在堆</span><br><span class="line"></span><br><span class="line">堆：完全二叉树</span><br><span class="line">最大堆：父节点&gt;=子节点</span><br><span class="line">最小堆：父节点&lt;=子节点 (满足其一即可)</span><br><span class="line">逻辑结构vs物理结构</span><br><span class="line">堆，逻辑上是一棵二叉树，物理结构是一个数组(连续空间，节省空间)</span><br><span class="line">堆 VS BST</span><br><span class="line">查询比BST慢</span><br><span class="line">删除比BST快，维持平衡更快 总体上都是O(logn) 树的高度</span><br></pre></td></tr></table></figure><h5 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a>青蛙跳台阶</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">一只青蛙，一次可跳1级，也可以跳2级</span><br><span class="line">问：青蛙跳到n级台阶，总共有多少种方式</span><br><span class="line">斐波那契</span><br><span class="line">function fib(n) &#123;</span><br><span class="line">  if (n &lt;= 0) return 0</span><br><span class="line">  if (n === 1) return 1</span><br><span class="line">  let n1 = 1 // 记录n-1的结果</span><br><span class="line">  let n2 = 0 // 记录n-2的结果</span><br><span class="line">  let res = 0</span><br><span class="line"></span><br><span class="line">  for (let i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">    res = n1 + n2</span><br><span class="line">    n2 = n1</span><br><span class="line">    n1 = res</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="将一个数组中的-0-移动到末尾"><a href="#将一个数组中的-0-移动到末尾" class="headerlink" title="将一个数组中的 0 移动到末尾"></a>将一个数组中的 0 移动到末尾</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">在原数组进行操作</span><br><span class="line">function toTail(arr) &#123;</span><br><span class="line">  const length = arr.length</span><br><span class="line">  if (length === 0) return</span><br><span class="line">  // p1 指向第一个0， p2指向p1后第一个非0</span><br><span class="line">  let p1 = -1</span><br><span class="line">  let p2</span><br><span class="line">  for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">    if (arr[i] === 0) &#123;</span><br><span class="line">      if (p1 &lt; 0) &#123;</span><br><span class="line">        p1 = i</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (arr[i] !== 0 &amp;&amp; p1 &gt;= 0) &#123;</span><br><span class="line">      p2 = i</span><br><span class="line">      arr[p1] ^= arr[p2]</span><br><span class="line">      arr[p2] ^= arr[p1]</span><br><span class="line">      arr[p1] ^= arr[p2]</span><br><span class="line">      p1++</span><br><span class="line">    &#125;</span><br><span class="line">    if (p2 === length) return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="求字符串中连续最多的字符，以及次数"><a href="#求字符串中连续最多的字符，以及次数" class="headerlink" title="求字符串中连续最多的字符，以及次数"></a>求字符串中连续最多的字符，以及次数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function queryStr(str) &#123;</span><br><span class="line">  const res = &#123;</span><br><span class="line">    char: &#x27;&#x27;,</span><br><span class="line">    length: 0</span><br><span class="line">  &#125;</span><br><span class="line">  if (str.length === 0) return res</span><br><span class="line">  const length = str.length</span><br><span class="line">  let compLength = 0</span><br><span class="line">  for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">    compLength = 0</span><br><span class="line"></span><br><span class="line">    for (let j = i; j &lt; length; j++) &#123;</span><br><span class="line">      if (str[i] === str[j]) &#123;</span><br><span class="line">        compLength++</span><br><span class="line">      &#125;</span><br><span class="line">      if (str[i] !== str[j] || j === length - 1) &#123;</span><br><span class="line">        if (compLength &gt; res.length) &#123;</span><br><span class="line">          res.char = str[i]</span><br><span class="line">          res.length = compLength</span><br><span class="line">        &#125;</span><br><span class="line">        // 跳步</span><br><span class="line">        if (i &lt; length - 1) &#123;</span><br><span class="line">          i = j - 1</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个项目脚手架</title>
      <link href="/2022/03/21/shi-xian-yi-ge-xiang-mu-jiao-shou-jia/"/>
      <url>/2022/03/21/shi-xian-yi-ge-xiang-mu-jiao-shou-jia/</url>
      
        <content type="html"><![CDATA[<h3 id="命令行工具的关键依赖"><a href="#命令行工具的关键依赖" class="headerlink" title="命令行工具的关键依赖"></a>命令行工具的关键依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inquier, enquirer, prompts: 可以处理复杂的用户输入, 完成命令行输入交互</span><br><span class="line">chalk, kleur: 使终端可以输出彩色信息文案</span><br><span class="line">ora: 使命令行可以输出好看的Spinners</span><br><span class="line">boxen: 可以在命令行画出Boxes区块</span><br><span class="line">listr: 可以在命令行中画出进度列表</span><br><span class="line">meow, arg: 可以进行更加复杂的命令行参数解析</span><br><span class="line">commander, yargs: 可以进行更加复杂的命令行参数解析</span><br></pre></td></tr></table></figure><h3 id="bin-index-js"><a href="#bin-index-js" class="headerlink" title="bin/index.js"></a>bin/index.js</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">require = require(‘esm’)(module)</span><br><span class="line">require(‘../src/index.js’).cli(process.argv)</span><br></pre></td></tr></table></figure><h3 id="解析处理命令行输入"><a href="#解析处理命令行输入" class="headerlink" title="解析处理命令行输入"></a>解析处理命令行输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">[template]: 支持默认的几种模板类型, 用户可以通过select命令进行选择</span><br><span class="line">--git: 等同于通过git init命令创建一个新的Git项目</span><br><span class="line">--install: 支持自动下载依赖</span><br><span class="line">--yes: 跳过命令行交互, 直接使用默认配置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pnpm i inquirer arg</span><br><span class="line">function parseArgumentsIntoOptions(rawArgs) &#123;</span><br><span class="line">  const args = arg(</span><br><span class="line">    &#123;</span><br><span class="line">      &#x27;--git&#x27;: Boolean,</span><br><span class="line">      &#x27;--yes&#x27;: Boolean,</span><br><span class="line">      &#x27;--install&#x27;: Boolean,</span><br><span class="line">      &#x27;-g&#x27;: &#x27;--git&#x27;,</span><br><span class="line">      &#x27;-y&#x27;: &#x27;--yes&#x27;,</span><br><span class="line">      &#x27;-i&#x27;: &#x27;--install&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      argv: rawArgs.slice(2)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    skipPrompts: args[&#x27;--yes&#x27;] || false,</span><br><span class="line">    git: args[&#x27;--git&#x27;] || false,</span><br><span class="line">    template: args._[0],</span><br><span class="line">    runInstall: args[&#x27;--install&#x27;] || false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function promptForMissingOptions(options) &#123;</span><br><span class="line">  const defaultTemplate = &#x27;JavaScript&#x27;</span><br><span class="line">  if (options.skipPrompts) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      ...options,</span><br><span class="line">      template: options.template || defaultTemplate</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  const questions = []</span><br><span class="line">  if (!options.template) &#123;</span><br><span class="line">    questions.push(&#123;</span><br><span class="line">      type: &#x27;list&#x27;,</span><br><span class="line">      name: &#x27;template&#x27;,</span><br><span class="line">      message: &#x27;Please choose which project template to use&#x27;,</span><br><span class="line">      choices: [&#x27;JavaScript&#x27;, &#x27;TypeScript&#x27;],</span><br><span class="line">      default: defaultTemplate</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  if (!options.git) &#123;</span><br><span class="line">    questions.push(&#123;</span><br><span class="line">      type: &#x27;confirm&#x27;,</span><br><span class="line">      name: &#x27;git&#x27;,</span><br><span class="line">      message: &#x27;Initialize a git repository?&#x27;,</span><br><span class="line">      default: false</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  const answers = await inquierer.prompt(questions)</span><br><span class="line">  return &#123;</span><br><span class="line">    ...options,</span><br><span class="line">    template: options.template || answers.template,</span><br><span class="line">    git: options.git || answers.git</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拷贝模板"><a href="#拷贝模板" class="headerlink" title="拷贝模板"></a>拷贝模板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">ncp包实现跨平台递归拷贝文件, chalk做个性化输出</span><br><span class="line"></span><br><span class="line">import chalk from &#x27;chalk&#x27;</span><br><span class="line">import fs from &#x27;fs&#x27;</span><br><span class="line">import ncp from &#x27;ncp&#x27;</span><br><span class="line">import path from &#x27;path&#x27;</span><br><span class="line">// 该方法的作用是将一个存在回调函数的异步函数转换为返回Promise对象的异步函数，以便更方便地使用async/await语法。</span><br><span class="line">import &#123; promisify &#125; from &#x27;util&#x27;</span><br><span class="line"></span><br><span class="line">// 检查文件或目录是否可访问的方法</span><br><span class="line">const access = promisify(fs.access)</span><br><span class="line">const copy = promisify(ncp)</span><br><span class="line"></span><br><span class="line">async function copyTemplateFiles(options) &#123;</span><br><span class="line">  return copy(options.templateDirectory, options.targetDirectory, &#123;</span><br><span class="line">    clobber: false</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export async function createProject(options) &#123;</span><br><span class="line">  console.log(&#x27;options: &#x27;, options)</span><br><span class="line">  options = &#123;</span><br><span class="line">    ...options,</span><br><span class="line">    // cwd 是 &quot;current working directory&quot; 的缩写。该方法返回一个字符串，它表示当前工作目录的路径。</span><br><span class="line">    targetDirectory: options.targetDirectory || process.cwd()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // import.meta.url：一个字符串，表示当前模块的绝对 URL。</span><br><span class="line">  const currentFileUrl = import.meta.url</span><br><span class="line">  const templateDir = path.resolve(</span><br><span class="line">    new URL(currentFileUrl).pathname,</span><br><span class="line">    &#x27;../../templates&#x27;,</span><br><span class="line">    options.template.toLowerCase()</span><br><span class="line">  )</span><br><span class="line">  options.templateDirectory = templateDir</span><br><span class="line">  console.log(&#x27;templateDir: &#x27;, templateDir)</span><br><span class="line">  try &#123;</span><br><span class="line">    await access(templateDir, fs.constants.R_OK)</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.error(&#x27;%s Invalid template name&#x27;, chalk.red.bold(&#x27;ERROR&#x27;))</span><br><span class="line">    // process.exit() 方法用于直接退出 Node.js 进程。</span><br><span class="line">    process.exit(1)</span><br><span class="line">  &#125;</span><br><span class="line">  await copyTemplateFiles(options)</span><br><span class="line">  console.log(&#x27;%s Project ready&#x27;, chalk.green.bold(&#x27;DONE&#x27;))</span><br><span class="line">  return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="完成-Git-的初始化以及依赖安装工作"><a href="#完成-Git-的初始化以及依赖安装工作" class="headerlink" title="完成 Git 的初始化以及依赖安装工作"></a>完成 Git 的初始化以及依赖安装工作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">execa: 允许在开发中使用类似Git的外部命令</span><br><span class="line">pkg-install: 使用yarn install或npm install命令安装依赖</span><br><span class="line">listr: 给出当前进度</span><br><span class="line"></span><br><span class="line">import chalk from &#x27;chalk&#x27;</span><br><span class="line">import fs from &#x27;fs&#x27;</span><br><span class="line">import ncp from &#x27;ncp&#x27;</span><br><span class="line">import path from &#x27;path&#x27;</span><br><span class="line">// 该方法的作用是将一个存在回调函数的异步函数转换为返回Promise对象的异步函数，以便更方便地使用async/await语法。</span><br><span class="line">import &#123; promisify &#125; from &#x27;util&#x27;</span><br><span class="line">import &#123; execa &#125; from &#x27;execa&#x27;</span><br><span class="line">import Listr from &#x27;listr&#x27;</span><br><span class="line">import &#123; projectInstall &#125; from &#x27;pkg-install&#x27;</span><br><span class="line"></span><br><span class="line">// 检查文件或目录是否可访问的方法</span><br><span class="line">const access = promisify(fs.access)</span><br><span class="line">const copy = promisify(ncp)</span><br><span class="line"></span><br><span class="line">async function copyTemplateFiles(options) &#123;</span><br><span class="line">  return copy(options.templateDirectory, options.targetDirectory, &#123;</span><br><span class="line">    clobber: false</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function initGit(options) &#123;</span><br><span class="line">  const result = await execa(&#x27;git&#x27;, [&#x27;init&#x27;], &#123;</span><br><span class="line">    cwd: options.targetDirectory</span><br><span class="line">  &#125;)</span><br><span class="line">  if (result.failed) &#123;</span><br><span class="line">    return Promise.reject(new Error(&#x27;Failed to initialize git&#x27;))</span><br><span class="line">  &#125;</span><br><span class="line">  return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export async function createProject(options) &#123;</span><br><span class="line">  console.log(&#x27;options: &#x27;, options)</span><br><span class="line">  options = &#123;</span><br><span class="line">    ...options,</span><br><span class="line">    // cwd 是 &quot;current working directory&quot; 的缩写。该方法返回一个字符串，它表示当前工作目录的路径。</span><br><span class="line">    targetDirectory: options.targetDirectory || process.cwd()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // import.meta.url：一个字符串，表示当前模块的绝对 URL。</span><br><span class="line">  const currentFileUrl = import.meta.url</span><br><span class="line">  const templateDir = path.resolve(</span><br><span class="line">    new URL(currentFileUrl).pathname,</span><br><span class="line">    &#x27;../../templates&#x27;,</span><br><span class="line">    options.template.toLowerCase()</span><br><span class="line">  )</span><br><span class="line">  options.templateDirectory = templateDir</span><br><span class="line">  try &#123;</span><br><span class="line">    await access(templateDir, fs.constants.R_OK)</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.error(&#x27;%s Invalid template name&#x27;, chalk.red.bold(&#x27;ERROR&#x27;))</span><br><span class="line">    // process.exit() 方法用于直接退出 Node.js 进程。</span><br><span class="line">    process.exit(1)</span><br><span class="line">  &#125;</span><br><span class="line">  const tasks = new Listr([</span><br><span class="line">    &#123;</span><br><span class="line">      title: &#x27;Copy project files&#x27;,</span><br><span class="line">      task: () =&gt; copyTemplateFiles(options)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      title: &#x27;Initialize git&#x27;,</span><br><span class="line">      task: () =&gt; initGit(options),</span><br><span class="line">      enabled: () =&gt; options.git</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      title: &#x27;Install dependencies&#x27;,</span><br><span class="line">      task: () =&gt;</span><br><span class="line">        projectInstall(&#123;</span><br><span class="line">          cwd: options.targetDirectory</span><br><span class="line">        &#125;),</span><br><span class="line">      skip: () =&gt;</span><br><span class="line">        !options.runInstall ? &#x27;Pass --install to automatically install dependencies&#x27; : undefined</span><br><span class="line">    &#125;</span><br><span class="line">  ])</span><br><span class="line"></span><br><span class="line">  await tasks.run()</span><br><span class="line">  console.log(&#x27;%s Project ready&#x27;, chalk.green.bold(&#x27;DONE&#x27;))</span><br><span class="line">  return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚手架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced JavaScript</title>
      <link href="/2022/01/23/javascript-gao-ji/"/>
      <url>/2022/01/23/javascript-gao-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Advanced-JavaScript"><a href="#Advanced-JavaScript" class="headerlink" title="Advanced JavaScript"></a>Advanced JavaScript</h1><h2 id="JS-Engine"><a href="#JS-Engine" class="headerlink" title="JS Engine"></a>JS Engine</h2><p>Javascript is an interpreted language.</p><p>What is this engine that we speak of well ?</p><p>If I write some code like let’s say cost isHappy equals to true Well we just wrote some javascript</p><p>Now how do we read this or how does the computer read this ?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const isHappy = true</span><br></pre></td></tr></table></figure><p>JS =&gt; engine =&gt; computer</p><h5 id="Who-created-the-first-Javsscript-Engine"><a href="#Who-created-the-first-Javsscript-Engine" class="headerlink" title="Who created the first Javsscript Engine ?"></a>Who created the first Javsscript Engine ?</h5><p>Brendan Eich. =&gt; SpiderMonkey which is what Firefox still</p><h3 id="inside-of-V8-Engine"><a href="#inside-of-V8-Engine" class="headerlink" title="inside of V8 Engine"></a>inside of V8 Engine</h3><p><img "" class="lazyload placeholder" data-original="https://s3.bmp.ovh/imgs/2022/01/97d547a589bf66bb.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20220102213441259"></p><p>It looks something like this we give it a js file and first is does something called lexical analysis which breaks the code into something called tokens to identify their meaning. So that we into know what the code is trying to do and these tokens are formed into what wo call an AST that is an abstract syntax tree. So we pass the code that is we try and figure out how the text is divided up based on Keywords from js and it gets formed into this tree like structure called abstract syntax tree. In once in this form it goes through something called an interpreter profiler compiler and we get some. Code that are CPU you on our computers is going to understand to give it instructions and you can think of this whole process again which we’re going to talk about in more detail coming up as something like this.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function jsengine(code) &#123;</span><br><span class="line">return code.split(/\s+/)</span><br><span class="line">&#125;</span><br><span class="line">code(&#x27;const a = 6&#x27;) //</span><br></pre></td></tr></table></figure><h5 id="What-problem-do-u-see-with-everybody-creating-their-own-engines-in-js"><a href="#What-problem-do-u-see-with-everybody-creating-their-own-engines-in-js" class="headerlink" title="What problem do u see with everybody creating their own engines in js ?"></a>What problem do u see with everybody creating their own engines in js ?</h5><p>V8 is an ECMAScript engine</p><h3 id="interpreters-and-compilers"><a href="#interpreters-and-compilers" class="headerlink" title="interpreters and compilers"></a>interpreters and compilers</h3><p>In programming there are generally two ways of translating to machine language or something that our computers can understand and we’re going to talk about here actually applies to most programming languages not just JS Python Java C++ any language u can think of is going to use some of these concepts. So it’s very important let’s start with the first one the interpreter. With an interpreter, what we do is we translate and read the files line by line on the fly. Let’s have a look at how this work.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line">return a + b</span><br><span class="line">&#125;</span><br><span class="line">for (let i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">sum(5, 4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If we give this file to an interpreter the translation happens line by line on the fly and this is how u think the code should be run right? Because interpreting code simply means taking a set of instructions like we have over here and returning an answer and doing something with that code.</p><p>But what about a compiler?</p><p>A compiler I like an interpreter doesn’t translate on the fly. What it does is it works ahead of time to create a translation of what code we’ve just written and it compiles down to usually a language that can be understood by our machines.</p><p>You see the definition itself is actually a little bit fuzzy in some respects all languages have to be interpreted and compiled because it has to run it has to be interpreted and it also has to most likely get translated into something low level like machine code for example.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// JS</span><br><span class="line">let result = 1 + obj.x</span><br><span class="line"></span><br><span class="line">// V8 bytecode</span><br><span class="line">LdaSmi [1]</span><br><span class="line">Star r0</span><br><span class="line">LdaNamedProperty a0, [0], [4] Add r0, [6]</span><br><span class="line"></span><br><span class="line">// Machine code ...</span><br></pre></td></tr></table></figure><p>First, <strong>interpreters are quick to get up and running right</strong> because if we go to our example with an interpreter We don’t have to convert this into an another language like language X like I showed.</p><p>But there’s a con with using an interpreter and this is same problem that Google had back in to day when they had Google Maps running. a lot of js but it’ll get slower and slower and slower because the problem with <strong>interpreter is that when you’re running the same code more than once. For example if you’re in a loop like this one over here where we’re running this piece of code over and over even though it gives us the same result it can get really really slow</strong> the complier actually helps us here. It takes a little bit more time to start up because it has to go through that compilation step at the beginning go through our code understand it and spit it out into a another language but the complier will be smart enough that when it sees code like this and this is obviously a simplified version of it but if he sees code like this that we just loop over and it has the same inputs returning the same outputs. Well it can actually just simplified this code and instead of calling this function multiple timers can just replace this function with something like nine because we know that we want to return nine because <strong>a compiler doesn’t need to repeat the translation for each pass through in that loop the code generated from it is actually faster and these sort of edits that compliers do are called optimization</strong></p><p>so let’s go back to that question interpreter or complier which one is better.</p><p><strong>They both have their pros and cons complier obviously takes a little bit longer to get up and running but the code is going to eventually run faster, interpreter that is really fast to get up and running but unfortunately doesn’t do any optimizations.</strong></p><h5 id="Is-there-a-way-that-we-can-get-the-best-of-both-worlds-and-this-is-what-some-engineers-came-up-with-in-late-2000-and-if-we-use-Google-as-our-example-with-the-V8-engine-what-if-we-combine-the-best-of-both"><a href="#Is-there-a-way-that-we-can-get-the-best-of-both-worlds-and-this-is-what-some-engineers-came-up-with-in-late-2000-and-if-we-use-Google-as-our-example-with-the-V8-engine-what-if-we-combine-the-best-of-both" class="headerlink" title="Is there a way that we can get the best of both worlds and this is what some engineers came up with in late 2000 and if we use Google as our example with the V8 engine what if we combine the best of both ?"></a>Is there a way that we can get the best of both worlds and this is what some engineers came up with in late 2000 and if we use Google as our example with the V8 engine what if we combine the best of both ?</h5><p><strong>JIT compiler or just in timer Compiler</strong> and this is exactly what browser started doing browsers started mixing compliers specifically these JIT compilers for just in time compiler to make the engines faster. So let’s see how V8 engine does this.</p><p>This old man that’s checking out our code in this profiler also called a monitor, monitors and watches our code as it runs and makes notes on how we can optimize this code sch as how many times it is being run. What types are used and how we can possibly optimize this and using this profiler as the code is running through our interpreter which tells our browser what to do if the same lines of code are run a few times. We actually pass off some of this code to the compiler or a JIT compiler adjust in time compiler because as the code is running, the interpreter is going to say here’s some code for u to optimize passes it off to the compiler and the compiler as the application is running takes a code and compiled it or modifies it.</p><p><strong>the compiler is imperfect it can make mistakes and it can try to optimize code that actually does the opposite. And if it makes a mistake and it does something unexpected it does something called D optimization which takes even longer time to reverted back to the interpreter.</strong></p><h3 id="compare-with-other-languages"><a href="#compare-with-other-languages" class="headerlink" title="compare with other languages"></a>compare with other languages</h3><p>.exe mostly be created by C++.</p><h5 id="Is-Js-an-interpreted-language"><a href="#Is-Js-an-interpreted-language" class="headerlink" title="Is Js an interpreted language ?"></a>Is Js an interpreted language ?</h5><p>not technically, technically it depends on the implementation.</p><p>In order to help the js engine we want to be really really careful with these on the left:</p><ul><li>eval()</li><li>arguments</li><li>for in (keys instance of)</li><li>with</li><li>delete</li><li>inline-caching</li><li>hidden classes</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// inline-caching</span><br><span class="line">function findUser(user) &#123;</span><br><span class="line">  return `found $&#123;user.firstName&#125; $&#123;user.lastName&#125;`</span><br><span class="line">&#125;</span><br><span class="line">const userData = &#123;</span><br><span class="line">  firstName: &#x27;W&#x27;,</span><br><span class="line">  lastName: &#x27;Q&#x27;</span><br><span class="line">&#125;</span><br><span class="line">console.log(findUser(userData));</span><br><span class="line"></span><br><span class="line">// hidden classes</span><br><span class="line">function Animal(x, y) &#123;</span><br><span class="line">  // should add properties a and b here</span><br><span class="line">  this.x = x;</span><br><span class="line">  this.y = y</span><br><span class="line">&#125;</span><br><span class="line">const obj1 = new Animal(&#x27;aa&#x27;, &#x27;bb&#x27;)</span><br><span class="line">const obj2 = new Animal(&#x27;cc&#x27;, &#x27;dd&#x27;)</span><br><span class="line">obj1.a = 30;</span><br><span class="line">obj1.b = 100</span><br><span class="line">obj2.a = 100</span><br><span class="line">obj2.b = 30</span><br><span class="line"></span><br><span class="line">delete obj1.x // if I delete the property here of the object well again I change the hitting classes so that they don&#x27;t match up anymore</span><br></pre></td></tr></table></figure><h5 id="Why-not-just-use-machine-code-from-the-beginning"><a href="#Why-not-just-use-machine-code-from-the-beginning" class="headerlink" title="Why not just use machine code from the beginning ?"></a>Why not just use machine code from the beginning ?</h5><p>You see if javascript were compile then either compilation would have to be super fast because remember. our js files get send from the server to the browser. So the compiling has to happen on the browser or the competing browsers that is Firefox.</p><h2 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h2><p>We have the standard binary executable format called WebAssembly and this is what we didn’t have in nineteen ninety five we didn’t have the competing browsers agreeing on this format where we can compiler code all the way down to WebAssembly. This exectable format so that it runs really fast on the browser instead of having to go through that entire js engine proess.</p><h2 id="Call-Stack-and-Memory-Heap"><a href="#Call-Stack-and-Memory-Heap" class="headerlink" title="Call Stack and Memory Heap"></a>Call Stack and Memory Heap</h2><p><strong>Call Stack =&gt; first in last out</strong></p><p>(anonymous) =&gt; global anonymous function</p><h3 id="garbage-collection"><a href="#garbage-collection" class="headerlink" title="garbage collection"></a>garbage collection</h3><p>js automatically frees up this memory that we no longer use and will collect out garbage.</p><p>Mark and sweep</p><p><strong>keep in mind that the execution of the loop also aided in the crash</strong></p><p><strong>memory leaks are pieces of memory that the application have used in the past but it’s not needed any longer but has not yet been returned back to us to the poor free memory.</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">global variale</span><br><span class="line">var a = 1</span><br><span class="line">&lt;script&gt;var z = 1&lt;/script&gt;</span><br><span class="line">&lt;script&gt;var zz = 2&lt;/script&gt;</span><br><span class="line">&lt;script&gt;var z = 4&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">event listener</span><br><span class="line">var element = deocument.getElementById(&#x27;button&#x27;)</span><br><span class="line">element.addEventListener(&#x27;click&#x27;, onclick)</span><br><span class="line"></span><br><span class="line">setinterval</span><br><span class="line">setInterval(() =&gt; &#123;</span><br><span class="line">// referencing objects...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="JS-Runtime"><a href="#JS-Runtime" class="headerlink" title="JS Runtime"></a>JS Runtime</h2><p>when Call Stack meet Web API(like setimeout, fetch) , I’m going to just send it off to the web API so this gets moved away from the call Stack and gets send to the Web API.</p><p><img "" class="lazyload placeholder" data-original="https://s3.bmp.ovh/imgs/2022/01/6183205935f89b97.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20220103105252517"></p><h2 id="Execution-Context"><a href="#Execution-Context" class="headerlink" title="Execution Context"></a>Execution Context</h2><p><img "" class="lazyload placeholder" data-original="https://s3.bmp.ovh/imgs/2022/01/b010bdc9a5d6093d.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20220103141108251"></p><p>this =&gt; window(Global Object)</p><h2 id="Hoisting"><a href="#Hoisting" class="headerlink" title="Hoisting"></a>Hoisting</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var favouriteFood = &#x27;grapes&#x27;;</span><br><span class="line"></span><br><span class="line">var foodThouts = function () &#123;</span><br><span class="line">  console.log(&quot;Original favourite food &quot; + favouriteFood);</span><br><span class="line">  var favouriteFood = &#x27;sushi&#x27;</span><br><span class="line">  console.log(&quot;New favourite food &quot; + favouriteFood);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foodThouts()</span><br><span class="line">// Original favourite food undefined</span><br><span class="line">New favourite food sushi</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x27;use strict&#x27;</span><br><span class="line">function weird() &#123;</span><br><span class="line">      dd = &#x27;xx&#x27;</span><br><span class="line">      return dd</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Block-scope"><a href="#Block-scope" class="headerlink" title="Block scope"></a>Block scope</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (2 &gt; 1) &#123;</span><br><span class="line">var secret = &#x27;321&#x27;</span><br><span class="line">&#125;</span><br><span class="line">if (2 &gt; 1) &#123;</span><br><span class="line">let secret = &#x27;123&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function loop() &#123;</span><br><span class="line">  for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&#x27;final&#x27;, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loop() // 0 1 2 3 4 final 5</span><br><span class="line"></span><br><span class="line">function loop() &#123;</span><br><span class="line">  for (let i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&#x27;final&#x27;, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loop() // 0 1 2 3 4 error</span><br></pre></td></tr></table></figure><h2 id="this-Keyword"><a href="#this-Keyword" class="headerlink" title="this Keyword"></a>this Keyword</h2><p><strong><code>this</code> is the object that the function is a property of.</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">a() // window &lt;=&gt; window.a()</span><br><span class="line">function a() &#123;</span><br><span class="line">&#x27;use strict&#x27;</span><br><span class="line">console.log(this)</span><br><span class="line">&#125; // undefined</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 1. gives methods acess to their object</span><br><span class="line">// 2. execute same code for multiple object</span><br><span class="line">const obj = &#123;</span><br><span class="line">  name: &#x27;Billy&#x27;,</span><br><span class="line">  sing() &#123;</span><br><span class="line">    return &#x27;lalala&#x27; + this.name</span><br><span class="line">  &#125;,</span><br><span class="line">  singAgain() &#123;</span><br><span class="line">    return this.sing() + &#x27;!&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.singAgain());</span><br><span class="line"></span><br><span class="line">function importantPerson() &#123;</span><br><span class="line">  console.log(this.name + &#x27;!&#x27;); // change once</span><br><span class="line">&#125;</span><br><span class="line">var name = &#x27;Sunny&#x27;</span><br><span class="line">const obj1 = &#123;</span><br><span class="line">  name: &#x27;Cassy&#x27;,</span><br><span class="line">  importantPerson</span><br><span class="line">&#125;</span><br><span class="line">const obj2 = &#123;</span><br><span class="line">  name: &#x27;Jacob&#x27;,</span><br><span class="line">  importantPerson</span><br><span class="line">&#125;</span><br><span class="line">obj1.importantPerson()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const a = function () &#123;</span><br><span class="line">  console.log(&#x27;a&#x27;, this);</span><br><span class="line">  const b = function () &#123;</span><br><span class="line">    console.log(&#x27;b&#x27;, this);</span><br><span class="line">    const c = &#123;</span><br><span class="line">      hi() &#123;</span><br><span class="line">        console.log(&#x27;c&#x27;, this);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.hi()</span><br><span class="line">  &#125;</span><br><span class="line">  b()</span><br><span class="line">&#125;</span><br><span class="line">a() // window.a(b(c.hi()))  b() =&gt; window</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  name: &#x27;Billy&#x27;,</span><br><span class="line">  sing() &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    const anotherFunc = () =&gt; &#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // const anotherFunc = function()&#123;&#125; // window</span><br><span class="line">    return anotherFunc</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.sing()() // obj obj</span><br></pre></td></tr></table></figure><h2 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call, apply, bind"></a>call, apply, bind</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const wizard = &#123;</span><br><span class="line">  name: &#x27;Merlin&#x27;,</span><br><span class="line">  health: 50,</span><br><span class="line">  heal() &#123;</span><br><span class="line">    return this.health = 100</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const archer = &#123;</span><br><span class="line">  name: &#x27;Robin&#x27;,</span><br><span class="line">  health: 30</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wizard.heal.call(archer)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function multiply(a, b) &#123;</span><br><span class="line">  return a * b</span><br><span class="line">&#125;</span><br><span class="line">let multiplyByTwo = multiply.bind(this, 2)</span><br><span class="line">let multiplyByTen = multiply.bind(this, 10)</span><br><span class="line"></span><br><span class="line">console.log(multiplyByTwo(4)); // 8</span><br><span class="line">console.log(multiplyByTen(4)); // 40</span><br></pre></td></tr></table></figure><h2 id="Type-Coercion"><a href="#Type-Coercion" class="headerlink" title="Type Coercion"></a>Type Coercion</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.is(+0, -0) // false</span><br></pre></td></tr></table></figure><h2 id="First-class-Citizens"><a href="#First-class-Citizens" class="headerlink" title="First class Citizens"></a>First class Citizens</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var stuff = function() &#123;&#125;</span><br><span class="line"></span><br><span class="line">function a(fn) &#123;</span><br><span class="line">fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function b() &#123;</span><br><span class="line">return function c() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HOF"><a href="#HOF" class="headerlink" title="HOF"></a>HOF</h2><p>Higher order function are simply a function that can take a function as an argument or a function that returns a function.</p><h2 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h2><p>We have these things called closures in Js because of two things that we get. One is the fact that in Js function are a first citizen. We can pass functions around like data like any other type in Js. We alse have this idea of lexical scope that is the Js engine knows based on where our code is written we even run the code. Each function has access to and closure is simply that a combination of function and the lexical environment from which it was declared. Closures allow a function to access variables from an enclosing scope or environment even after it leaves the scope in which it was declared.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">  let grandpa = &#x27;grandpa&#x27;</span><br><span class="line">  return function b() &#123;</span><br><span class="line">    let father = &#x27;father&#x27;</span><br><span class="line">    return function c() &#123;</span><br><span class="line">      let son = &#x27;son&#x27;</span><br><span class="line">      return `$&#123;grandpa&#125; $&#123;father&#125; $&#123;son&#125;`</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a()()()</span><br></pre></td></tr></table></figure><p><strong>Js engine is going to keep any thing that’s still being referenced</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function callMe() &#123;</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    console.log(call)</span><br><span class="line">  &#125;, 2000)</span><br><span class="line">  const call = &quot;Hi!&quot;</span><br><span class="line">&#125; // will run &#x27;Hi&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Memory efficient</span><br><span class="line">function heavyDuty(index) &#123;</span><br><span class="line">  const bigArray = new Array(7000).fill(&#x27;🤣&#x27;)</span><br><span class="line">  console.log(&#x27;created&#x27;) // run 4times</span><br><span class="line">  return bigArray[index]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">heavyDuty(688)</span><br><span class="line">heavyDuty(688)</span><br><span class="line">heavyDuty(688)</span><br><span class="line">heavyDuty(688)</span><br><span class="line"></span><br><span class="line">function heavyDuty2() &#123;</span><br><span class="line">  const bigArray = new Array(7000).fill(&#x27;🤣&#x27;)</span><br><span class="line">  console.log(&#x27;created Again&#x27;) // run one time</span><br><span class="line">  return function(index) &#123;</span><br><span class="line">    return bigArray[index]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const getHeavyDuty = heavyDuty2()</span><br><span class="line">getHeavyDuty(688)</span><br><span class="line">getHeavyDuty(788)</span><br><span class="line">getHeavyDuty(888)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Encapsulation</span><br><span class="line">const makeNuclearButton = () =&gt; &#123;</span><br><span class="line">  let timeWithoutDestruction = 0</span><br><span class="line">  const passTime = () =&gt; timeWithoutDestruction++</span><br><span class="line">  const totalPeaceTime = () =&gt; timeWithoutDestruction</span><br><span class="line">  const launch = () =&gt; &#123;</span><br><span class="line">    timeWithoutDestruction = -1</span><br><span class="line">    return &#x27;💥&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  setInterval(passTime, 1000)</span><br><span class="line">  return &#123;</span><br><span class="line">    // launch, hide for safe</span><br><span class="line">    totalPeaceTime</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const ohno = makeNuclearButton()</span><br><span class="line">ohno.totalPeaceTime()</span><br><span class="line">// hiding of information that is unnecessary to be seen by the outside world or manipulated</span><br></pre></td></tr></table></figure><h2 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">let dragon = &#123;</span><br><span class="line">  name: &#x27;Tanya&#x27;,</span><br><span class="line">  fire: true,</span><br><span class="line">  fight() &#123;</span><br><span class="line">    return 5</span><br><span class="line">  &#125;,</span><br><span class="line">  sing() &#123;</span><br><span class="line">    if (this.fire) &#123;</span><br><span class="line">      return `i am $&#123;this.name&#125;`</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let lizard = &#123;</span><br><span class="line">  name: &#x27;Kiki&#x27;,</span><br><span class="line">  fight() &#123;</span><br><span class="line">    return 1</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const singLizard = dragon.sing.bind(lizard)</span><br><span class="line">singLizard() // nothing</span><br><span class="line"></span><br><span class="line">lizard.__proto__ = dragon</span><br><span class="line">lizard.fire // true</span><br><span class="line">dragon.isPrototypeOf(lizard) // true</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let human = &#123;</span><br><span class="line">  mortal:true,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">let socrates = Object.create(humnan) // replace __proto__</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typeof Function</span><br><span class="line">&#x27;function&#x27;</span><br><span class="line">typeof Array</span><br><span class="line">&#x27;function&#x27;</span><br><span class="line">typeof Object</span><br><span class="line">&#x27;function&#x27; // Object.constructor</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React的使用</title>
      <link href="/2021/07/12/react-shi-yong/"/>
      <url>/2021/07/12/react-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="React-的三大特性："><a href="#React-的三大特性：" class="headerlink" title="React 的三大特性："></a>React 的三大特性：</h2><ul><li><code>数据驱动 -&gt; 单向数据流</code></li><li><code>函数式编程 = 组件化 + JSX</code></li><li><code>虚拟 DOM -&gt; 跨平台</code></li></ul><h4 id="setState是同步还是异步？"><a href="#setState是同步还是异步？" class="headerlink" title="setState是同步还是异步？"></a>setState是同步还是异步？</h4><p><strong>异步</strong>npm</p><p>可能会执行多次setState</p><p>无法规定、限制用户如何使用setState</p><p>没必要每次setState都要重新渲染，考虑性能</p><p>即便是每次重新渲染，用户也看不到中间的效果(js单线程)异步</p><p><strong>setState的过程</strong></p><p>每个组件都有一个renderComponent方法</p><p>执行renderComponent会重新执行实例的render</p><p>patch(oldVnode, newVnode)</p><h2 id="React的基本使用"><a href="#React的基本使用" class="headerlink" title="React的基本使用"></a>React的基本使用</h2><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="bind-this"><a href="#bind-this" class="headerlink" title="bind this"></a>bind this</h4><p>this默认是undefined 需要改变this指向</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.handler = this.handler.bind(this)</span><br></pre></td></tr></table></figure><p>也可以使用箭头函数</p><h4 id="关于event参数"><a href="#关于event参数" class="headerlink" title="关于event参数"></a>关于event参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">clickHandler2 = (e) =&gt; &#123;</span><br><span class="line">  console.log(e);</span><br><span class="line">  e.nativeEvent(); // 原生event 所有的事件挂载到document</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">  console.log(e.target); // 指向当前元素, 即当前元素触发 </span><br><span class="line">  console.log(e.currentTarget); // 指向当前元素，假象！  null</span><br><span class="line">  // 注意，event其实是React封装的。可以看__proto__.constructor 是 SyntheticBaseEvent 组合事件</span><br><span class="line">  // 原生event的__proto__.constructor是MouseEvent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><h4 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h4><p>input textarea select用value</p><p>checkbox radio 用checked</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;label htmlFor=&quot;inputName&quot;&gt;Name&lt;/label&gt;</span><br><span class="line">  &lt;input id=&quot;inputName&quot; value=&#123;this.state.name&#125; onChange=&#123;this.changeHandle&#125;&gt;&lt;/input&gt;</span><br><span class="line">  &lt;p&gt;&#123;this.state.name&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h4><p><strong>ref</strong></p><p><strong>defaultValue defaultChecked</strong></p><p><strong>手动操作DOM元素</strong></p><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>必须手动操作DOM元素，setState实现不了</p><p>文件上传 <input type="file"></p><p>某些富文本编辑器，需要传入DOM元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export class UncontrolledDemo extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      name: &#x27;xx&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    this.nameInputRef = React.createRef()</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;/* 没有onChange事件</span><br><span class="line">        state 并不会随着变化 */&#125;</span><br><span class="line">        &lt;input defaultValue=&#123;this.state.name&#125; ref=&#123;this.nameInputRef&#125;&gt;&lt;/input&gt;</span><br><span class="line">        &lt;p&gt;&#123;this.state.name&#125;&lt;/p&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.alertName&#125;&gt;click me&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  alertName = () =&gt; &#123;</span><br><span class="line">    console.log(this.nameInputRef);</span><br><span class="line">    const e = this.nameInputRef.current // 通过ref获取DOM节点</span><br><span class="line">    alert(e.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="父子组件通讯"><a href="#父子组件通讯" class="headerlink" title="父子组件通讯"></a>父子组件通讯</h3><p>props传递数据</p><p>props传递函数</p><h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><h4 id="不可变值-函数式编程，纯函数"><a href="#不可变值-函数式编程，纯函数" class="headerlink" title="不可变值(函数式编程，纯函数)"></a>不可变值(函数式编程，纯函数)</h4><h4 id="可能是异步更新"><a href="#可能是异步更新" class="headerlink" title="可能是异步更新"></a>可能是异步更新</h4><h4 id="可能会被合并"><a href="#可能会被合并" class="headerlink" title="可能会被合并"></a>可能会被合并</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export class StateDemo extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">    // state 要定义在构造函数中</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  clickHandle = () =&gt; &#123;</span><br><span class="line">    // 不要直接修改state，使用不可变数据</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      count: this.state.count + 1</span><br><span class="line">    &#125;, () =&gt; &#123;</span><br><span class="line">      console.log(this.state.count); // 回调函数</span><br><span class="line">    &#125;)</span><br><span class="line">    // setTimeout 中setState是同步的</span><br><span class="line">    // setTimeout(() =&gt; &#123;</span><br><span class="line">    //   this.setState(&#123;</span><br><span class="line">    //     count: this.state.count + 1</span><br><span class="line">    //   &#125;)</span><br><span class="line">    //   console.log(this.state.count);</span><br><span class="line">    // &#125;)</span><br><span class="line">    // 自定义DOM事件，setState同步</span><br><span class="line">    </span><br><span class="line">    console.log(this.state.count); // 异步，拿不到最新值</span><br><span class="line">  &#125;</span><br><span class="line">  // 操作数组时、对象的常用形式</span><br><span class="line">  // this.setState(&#123;</span><br><span class="line">  //   list1: [...this.state.list, 100], // 追加</span><br><span class="line">  //   list2: this.state.list.slice(0, 3), // 截取</span><br><span class="line">  //   list3: this.state.list.filter(item =&gt; item &gt; 10),</span><br><span class="line">  // &#125;)</span><br><span class="line">  // this.setState(&#123;</span><br><span class="line">  //   obj1: Object.assign(&#123;&#125;, this.state.obj, &#123;a: 100&#125;),</span><br><span class="line">  //   obj2: &#123;...this.state.obj, a: 100&#125;</span><br><span class="line">  // &#125;)</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;this.state.count&#125;&lt;/p&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.clickHandle&#125;&gt;click me&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h3><p><strong>装载阶段</strong></p><p>constructor componentDidMount</p><p><strong>更新阶段</strong></p><p>render shouldComponentUpdate componentDidUpdate</p><p><strong>卸载阶段</strong></p><p>componentWillUnmount</p><h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function List(props) &#123;</span><br><span class="line">const &#123; list &#125; = this.props</span><br><span class="line">return ()</span><br><span class="line">&#125;</span><br><span class="line">纯函数，输入props，输出JSX</span><br><span class="line">没有实例，没有生命周期，没有state</span><br><span class="line">不能扩展其他方法</span><br></pre></td></tr></table></figure><h3 id="Portals"><a href="#Portals" class="headerlink" title="Portals"></a>Portals</h3><p>组件默认会按照既定层次嵌套渲染</p><p>让组件渲染到父组件以外</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return ReactDOM.createPortal(</span><br><span class="line">    &lt;div className=&quot;modal&quot;&gt;&#123;this.props.children&#125;&lt;/div&gt;,</span><br><span class="line">    document.body</span><br><span class="line">  )</span><br><span class="line">&#125; // 使用Portals渲染到body上，fixed元素要放在body上，有更好的浏览器兼容性</span><br></pre></td></tr></table></figure><h5 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h5><p>父组件设置了overflow：hidden</p><p>父组件z-index值太小</p><p>fixed元素要放在body第一层级</p><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>公共信息传递给每个组件 非父子组件通讯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const ThemeContext = React.createContext(&#x27;light&#x27;)</span><br><span class="line"></span><br><span class="line">export class ContextDemo extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      theme: &#x27;light&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;ThemeContext.Provider value=&#123;this.state.theme&#125;&gt;</span><br><span class="line">        &lt;Toolbar /&gt;</span><br><span class="line">        &lt;div&gt;&#123;this.state.theme&#125;&lt;/div&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.changeTheme&#125;&gt;click me&lt;/button&gt;</span><br><span class="line">      &lt;/ThemeContext.Provider&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  changeTheme = () =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      theme: this.state.theme === &#x27;light&#x27; ? &#x27;dark&#x27; : &#x27;light&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Toolbar extends Component &#123;</span><br><span class="line">  static contextType = ThemeContext // es6 写法</span><br><span class="line">  render() &#123;</span><br><span class="line">    const theme = this.context // React会向上找最近的theme provider</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;123&#123;theme&#125;&lt;/div&gt;</span><br><span class="line">        &lt;ThemeLink /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Toolbar.contextType = ThemeContext // 指定conteType</span><br><span class="line"></span><br><span class="line">function ThemeLink (props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;ThemeContext.Consumer&gt;</span><br><span class="line">      &#123;value =&gt; value&#125;</span><br><span class="line">    &lt;/ThemeContext.Consumer&gt;</span><br><span class="line">  )</span><br><span class="line">&#125; // 函数组件写法</span><br></pre></td></tr></table></figure><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>import()</p><p>React.lazy</p><p>React.Suspense</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const ContextDemo  = React.lazy(() =&gt; import(&#x27;./components/todo/Demo/ContextDemo&#x27;))</span><br><span class="line"></span><br><span class="line">      &lt;React.Suspense fallback=&#123;&lt;div&gt;loading&lt;/div&gt;&#125;&gt;</span><br><span class="line">      &lt;ContextDemo /&gt;</span><br><span class="line">      &lt;/React.Suspense&gt;</span><br></pre></td></tr></table></figure><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>shouldComponentUpdate(SCU)</p><p>PureComponent 和 React.memo</p><p>不可变值 immutable.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">if (nextState.count !== this.state.count) &#123;</span><br><span class="line">return true // 可以渲染</span><br><span class="line">&#125;</span><br><span class="line">return false // 不可渲染</span><br><span class="line">&#125;</span><br><span class="line">// 默认父组件更新，子组件无条件更新</span><br><span class="line">// SCU一定要每次都用吗? 需要的时候才优化</span><br><span class="line">// SCU一定要配合不可变值</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PureComponent ,SCU中实现了浅比较</span><br><span class="line">memo函数组件中的PureComponent</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Pure extends React.PureComponent &#123;&#125;</span><br><span class="line">export React.memo(MyComponent, ateEqual)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">immutable.js</span><br><span class="line">彻底拥抱不可变值</span><br><span class="line">基于共享数据(不是深拷贝)，速度快</span><br></pre></td></tr></table></figure><h3 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h3><h4 id="关于组件公共逻辑的抽离"><a href="#关于组件公共逻辑的抽离" class="headerlink" title="关于组件公共逻辑的抽离"></a>关于组件公共逻辑的抽离</h4><h5 id="高阶组件HOC"><a href="#高阶组件HOC" class="headerlink" title="高阶组件HOC"></a>高阶组件HOC</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 高阶组件并不是一种功能，而是一种模式</span><br><span class="line">const HOCFactory = (Component) =&gt; &#123;</span><br><span class="line">const HOC extends React.Component &#123;</span><br><span class="line">//在此处定义多个组件的公共逻辑</span><br><span class="line">render() &#123;</span><br><span class="line">return &lt;Component &#123;...this.props&#125; /&gt; // 返回拼装的结果</span><br><span class="line">&#125;</span><br><span class="line">return HOC</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">const EnhancedComponent1 = HOCFactory(WrappedComponent1)</span><br><span class="line">const EnhancedComponent2 = HOCFactory(WrappedComponent2)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const withMouse = (Component) =&gt; &#123;</span><br><span class="line">  class withMouseComponent extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">      super(props)</span><br><span class="line">      this.state = &#123;</span><br><span class="line">        x: 0,</span><br><span class="line">        y: 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleMouseMove = (e) =&gt; &#123;</span><br><span class="line">      console.log(e);</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        x: e.clientX,</span><br><span class="line">        y: e.clientY</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return ( &lt;div style = &#123;&#123;height: &#x27;500px&#x27;&#125;&#125; onMouseMove=&#123;this.handleMouseMove&#125; &gt; </span><br><span class="line">      &#123;/* 传递所有props 增加mouse属性 */ &#125;</span><br><span class="line">          &lt;Component &#123;...this.props&#125; mouse=&#123;this.state&#125; /&gt; </span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return withMouseComponent</span><br><span class="line">&#125;</span><br><span class="line">const App = (props) =&gt; &#123;</span><br><span class="line">  const &#123;x, y&#125; = props.mouse</span><br><span class="line">  return (</span><br><span class="line">    &lt;div style=&#123;&#123;height: &#x27;500px&#x27;&#125;&#125;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;x&#125;, &#123;y&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">export default withMouse(App)</span><br></pre></td></tr></table></figure><h5 id="Render-Props"><a href="#Render-Props" class="headerlink" title="Render Props"></a>Render Props</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Render Props 的核心思想</span><br><span class="line">// 通过一个函数将class组件的state作为props传递给纯函数组件</span><br><span class="line">class Factory extends React.component &#123;</span><br><span class="line">constructor(props) &#123;</span><br><span class="line">super(props)</span><br><span class="line">this.state = &#123;</span><br><span class="line">// state 即多个组件的公共逻辑的数据</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 修改state</span><br><span class="line">render() &#123;</span><br><span class="line">return &lt;div&gt;&#123;this.props.render(this.state)&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const App = () =&gt; &#123;</span><br><span class="line">&lt;Factory render=&#123;</span><br><span class="line">// render 是一个函数组件</span><br><span class="line">(props)) =&gt; &lt;P&gt; &#123;props.a&#125; &#123;props.b&#125; &lt;/p&gt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &quot;react&quot;;</span><br><span class="line">class Mouse extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">    this.state = &#123;x: 0, y: 0&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  handleMouseMove = (e) =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x: e.clientX,</span><br><span class="line">      y: e.clientY</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div style=&#123;&#123;height: &#x27;500px&#x27;&#125;&#125; onMouseMove=&#123;this.handleMouseMove&#125;&gt;</span><br><span class="line">        &#123;/* 将当前state作为props，传递给render(render是一个纯函数) */&#125;</span><br><span class="line">        &#123;this.props.render(this.state)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const App = (props) =&gt; (</span><br><span class="line">  &lt;div style=&#123;&#123;height: &#x27;500px&#x27;&#125;&#125;&gt;</span><br><span class="line">    &lt;p&gt;&#123;props.a&#125;&lt;/p&gt;</span><br><span class="line">    &lt;Mouse render=&#123;(&#123;x, y&#125;) =&gt; &lt;h1&gt; &#123;x&#125;, &#123;y&#125; &lt;/h1&gt;&#125; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">)</span><br><span class="line">export default App</span><br></pre></td></tr></table></figure><h3 id="Redux的使用"><a href="#Redux的使用" class="headerlink" title="Redux的使用"></a>Redux的使用</h3><h4 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h4><h5 id="单一数据源"><a href="#单一数据源" class="headerlink" title="单一数据源"></a>单一数据源</h5><p>整个应用的 state被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个store中。</p><h5 id="State-是只读的"><a href="#State-是只读的" class="headerlink" title="State 是只读的"></a>State 是只读的</h5><p>唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</p><h5 id="使用纯函数来执行修改"><a href="#使用纯函数来执行修改" class="headerlink" title="使用纯函数来执行修改"></a>使用纯函数来执行修改</h5><p>为了描述 action 如何改变 state tree ，你需要编写 reducer</p><h4 id="单项数据流"><a href="#单项数据流" class="headerlink" title="单项数据流"></a>单项数据流</h4><p>dispatch(action)</p><p>reducer =&gt; newState</p><p>subscribe 触发通知</p><h4 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h4><p>&lt; Provider&gt; </p><p>mapStateToProps mapDispatchToProps</p><h4 id="异步action"><a href="#异步action" class="headerlink" title="异步action"></a>异步action</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 同步action</span><br><span class="line">export const addTodo = text =&gt; &#123;</span><br><span class="line">return &#123;</span><br><span class="line">type: &#x27;x&#x27;,</span><br><span class="line">text</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 异步action</span><br><span class="line">import &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;</span><br><span class="line">import thunk from &#x27;redux-thunk&#x27;</span><br><span class="line">import rootReducer from &#x27;./reducers/index&#x27;</span><br><span class="line">const store = createStore(rootReducer, applyMiddleware(thunk))</span><br><span class="line">export const addTodoAsync = text =&gt; &#123;</span><br><span class="line">return (dispatch) =&gt; &#123;</span><br><span class="line">fetch(url).then(res =&gt; dispatch(addTodo(res.text)))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button(callback) =&gt; dispatch(action) =&gt; reducer(state) =&gt; view</span><br></pre></td></tr></table></figure><h4 id="redux数据流图"><a href="#redux数据流图" class="headerlink" title="redux数据流图"></a>redux数据流图</h4><p><img "https://gimg2.baidu.com/image_search/http%3A%2F%2Fimage.mamicode.com%2Finfo%2F201912%2F20191203142453280400.png&refer=http%3A%2F%2Fimage.mamicode.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1628914849&t=d2e6599519536f4b2e22059cde1102f2" alt="img"></p><h2 id="React原理"><a href="#React原理" class="headerlink" title="React原理"></a>React原理</h2><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>纯函数</p><p>不可变值</p><h3 id="合成事件"><a href="#合成事件" class="headerlink" title="合成事件"></a>合成事件</h3><p>所有事件挂载到document</p><p>event不是原生的，是SyntheticEvent合生事件对象</p><p>更好的兼容性和跨平台</p><h3 id="setState-batchUpdate"><a href="#setState-batchUpdate" class="headerlink" title="setState batchUpdate"></a>setState batchUpdate</h3><p>有时异步(普通使用)，有时同步(setTimeout, DOM事件)</p><p>有时合并(对象模式)，有时不合并(函数模式)</p><p>setState看是否命中batchUpdate 判断isBatchingUpdates</p><h3 id="组件之间如何通讯？"><a href="#组件之间如何通讯？" class="headerlink" title="组件之间如何通讯？"></a>组件之间如何通讯？</h3><p>父子组件props</p><p>Redux Context</p><h3 id="JSX本质"><a href="#JSX本质" class="headerlink" title="JSX本质"></a>JSX本质</h3><p>createElement</p><p>执行返回vnode</p><h3 id="shouldComponentUpdate用途"><a href="#shouldComponentUpdate用途" class="headerlink" title="shouldComponentUpdate用途"></a>shouldComponentUpdate用途</h3><p>性能优化</p><p>配合不可变值，一起使用，否则会出错</p><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>返回一个新值，没有副作用</p><p>重点：不可变值</p><p>如arr1 = arr,slice()</p><h3 id="函数组件和class组件的区别"><a href="#函数组件和class组件的区别" class="headerlink" title="函数组件和class组件的区别"></a>函数组件和class组件的区别</h3><p>纯函数，输入props，输出JSX</p><p>没有实例，没有生命周期，没有state</p><p>不能扩展其他方法</p><h3 id="什么是受控组件？"><a href="#什么是受控组件？" class="headerlink" title="什么是受控组件？"></a>什么是受控组件？</h3><p>表单的值，受state控制</p><p>需要自行监听onChange事件，更新state</p><p>对比非受控组件</p><h3 id="多个组件有公共逻辑，如何抽离？"><a href="#多个组件有公共逻辑，如何抽离？" class="headerlink" title="多个组件有公共逻辑，如何抽离？"></a>多个组件有公共逻辑，如何抽离？</h3><p>高阶组件</p><p>Render Props</p><h3 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h3><p>实现了浅比较的shouldComponentUpdate</p><p>优化性能</p><p>但要结合不可变值使用</p><h3 id="React性能优化"><a href="#React性能优化" class="headerlink" title="React性能优化"></a>React性能优化</h3><p>渲染列表加key</p><p>自定义事件、DOM事件及时销毁</p><p>合理使用异步组件</p><p>减少函数bind this的次数</p><p>合理使用SCU PureComponent和memo</p><p>图片懒加载</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-admin 后台系统总结</title>
      <link href="/2021/07/09/vue-admin-hou-tai-xi-tong-zong-jie/"/>
      <url>/2021/07/09/vue-admin-hou-tai-xi-tong-zong-jie/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create vue-admin</span><br></pre></td></tr></table></figure><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><p>npm i es-lint</p><p>导入vue.config.js</p><p>创建styles文件夹并导入normalize.css</p><h2 id="登录页面"><a href="#登录页面" class="headerlink" title="登录页面"></a>登录页面</h2><h3 id="使用elementui"><a href="#使用elementui" class="headerlink" title="使用elementui"></a>使用elementui</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i element-ui -S </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main.js</span><br><span class="line">import ElementUI from &#x27;element-ui&#x27;;</span><br><span class="line">import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;</span><br><span class="line">Vue.use(ElementUI);</span><br></pre></td></tr></table></figure><h3 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-form :model=&quot;ruleForm&quot; status-icon :rules=&quot;rules&quot; ref=&quot;ruleForm&quot; label-width=&quot;100px&quot; class=&quot;demo-ruleForm&quot;&gt;</span><br><span class="line">  &lt;el-form-item label=&quot;密码&quot; prop=&quot;pass&quot;&gt;</span><br><span class="line">    &lt;el-input type=&quot;password&quot; v-model=&quot;ruleForm.pass&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">  &lt;/el-form-item&gt;</span><br><span class="line">  &lt;el-form-item label=&quot;确认密码&quot; prop=&quot;checkPass&quot;&gt;</span><br><span class="line">    &lt;el-input type=&quot;password&quot; v-model=&quot;ruleForm.checkPass&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">  &lt;/el-form-item&gt;</span><br><span class="line">  &lt;el-form-item label=&quot;年龄&quot; prop=&quot;age&quot;&gt;</span><br><span class="line">    &lt;el-input v-model.number=&quot;ruleForm.age&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">  &lt;/el-form-item&gt;</span><br><span class="line">  &lt;el-form-item&gt;</span><br><span class="line">    &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(&#x27;ruleForm&#x27;)&quot;&gt;提交&lt;/el-button&gt;</span><br><span class="line">    &lt;el-button @click=&quot;resetForm(&#x27;ruleForm&#x27;)&quot;&gt;重置&lt;/el-button&gt;</span><br><span class="line">  &lt;/el-form-item&gt;</span><br><span class="line">&lt;/el-form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      var checkAge = (rule, value, callback) =&gt; &#123;</span><br><span class="line">        if (!value) &#123;</span><br><span class="line">          return callback(new Error(&#x27;年龄不能为空&#x27;));</span><br><span class="line">        &#125;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          if (!Number.isInteger(value)) &#123;</span><br><span class="line">            callback(new Error(&#x27;请输入数字值&#x27;));</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            if (value &lt; 18) &#123;</span><br><span class="line">              callback(new Error(&#x27;必须年满18岁&#x27;));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              callback();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">      &#125;;</span><br><span class="line">      var validatePass = (rule, value, callback) =&gt; &#123;</span><br><span class="line">        if (value === &#x27;&#x27;) &#123;</span><br><span class="line">          callback(new Error(&#x27;请输入密码&#x27;));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          if (this.ruleForm.checkPass !== &#x27;&#x27;) &#123;</span><br><span class="line">            this.$refs.ruleForm.validateField(&#x27;checkPass&#x27;);</span><br><span class="line">          &#125;</span><br><span class="line">          callback();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      var validatePass2 = (rule, value, callback) =&gt; &#123;</span><br><span class="line">        if (value === &#x27;&#x27;) &#123;</span><br><span class="line">          callback(new Error(&#x27;请再次输入密码&#x27;));</span><br><span class="line">        &#125; else if (value !== this.ruleForm.pass) &#123;</span><br><span class="line">          callback(new Error(&#x27;两次输入密码不一致!&#x27;));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          callback();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      return &#123;</span><br><span class="line">        ruleForm: &#123;</span><br><span class="line">          pass: &#x27;&#x27;,</span><br><span class="line">          checkPass: &#x27;&#x27;,</span><br><span class="line">          age: &#x27;&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        rules: &#123;</span><br><span class="line">          pass: [</span><br><span class="line">            &#123; validator: validatePass, trigger: &#x27;blur&#x27; &#125;</span><br><span class="line">          ],</span><br><span class="line">          checkPass: [</span><br><span class="line">            &#123; validator: validatePass2, trigger: &#x27;blur&#x27; &#125;</span><br><span class="line">          ],</span><br><span class="line">          age: [</span><br><span class="line">            &#123; validator: checkAge, trigger: &#x27;blur&#x27; &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      submitForm(formName) &#123;</span><br><span class="line">        this.$refs[formName].validate((valid) =&gt; &#123;</span><br><span class="line">          if (valid) &#123;</span><br><span class="line">            alert(&#x27;submit!&#x27;);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            console.log(&#x27;error submit!!&#x27;);</span><br><span class="line">            return false;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      resetForm(formName) &#123;</span><br><span class="line">        this.$refs[formName].resetFields();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">邮箱验证规则</span><br><span class="line">let reg = /^([a-zA-Z0-9]+[_|_|\-|.]?)*[a-zA-Z0-9]+@([a-zA-Z0-9]+[_|_|.]?)*[a-zA-Z0-9]+\.[a-zA-Z]&#123;2,3&#125;$/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">密码验证</span><br><span class="line">标签上添加minlength=&quot;6&quot; maxlength=&quot;20&quot; 输入限制 最小6位，最大29位</span><br><span class="line">只能输入6-20个字母+数字</span><br><span class="line">let reg = /^(?!\D+$)(?![^a-zA-Z]+$)\S&#123;6,20&#125;$/</span><br><span class="line">value = this.ruleForm.password = stripscript(value)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">./utils/validate.js</span><br><span class="line"></span><br><span class="line">过滤特殊字符</span><br><span class="line">export function stripscript(s) &#123;</span><br><span class="line">    var pattern = new RegExp(&quot;[`~!@#$^&amp;*()=|&#123;&#125;&#x27;:;&#x27;,\\[\\].&lt;&gt;/?~！@#￥……&amp;*（）&amp;—|&#123;&#125;【】‘；：”“&#x27;。，、？]&quot;)</span><br><span class="line">    var rs = &quot;&quot;;</span><br><span class="line">    for (var i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">            rs = rs + s.substr(i, 1).replace(pattern, &#x27;&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    return rs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 验证用户名</span><br><span class="line">export function validateEmail(value) &#123;</span><br><span class="line">  let reg = /^([a-zA-Z0-9]+[_|_|\-|.]?)*[a-zA-Z0-9]+@([a-zA-Z0-9]+[_|_|.]?)*[a-zA-Z0-9]+\.[a-zA-Z]&#123;2,3&#125;$/</span><br><span class="line">  return reg.test(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 验证密码</span><br><span class="line">export function validatePass(value) &#123;</span><br><span class="line">  let reg = /^(?!\D+$)(?![^a-zA-Z]+$)\S&#123;6,20&#125;$/</span><br><span class="line">  return reg.test(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vue2-0-gt-vue3-0"><a href="#vue2-0-gt-vue3-0" class="headerlink" title="vue2.0 =&gt;vue3.0"></a>vue2.0 =&gt;vue3.0</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">安装依赖</span><br><span class="line">npm install @vue/composition-api --save</span><br><span class="line"></span><br><span class="line">Main.js：</span><br><span class="line">import VueCompositionApi from &#x27;@vue/composition-api&#x27;; Vue.use(VueCompositionApi);</span><br></pre></td></tr></table></figure><p>vue3.0对vue的主要3个特点：<strong>响应式、模板、对象式的组件声明方式</strong>，进行了全面的更改，底层的实现和上层的api都有了明显的变化，基于Proxy重新实现了响应式，基于treeshaking内置了更多功能，提供了类式的组件声明方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2.x生命周期选项和Composition API之间的映射</span><br><span class="line">beforeCreate -&gt;使用 setup()</span><br><span class="line">created -&gt;使用 setup()</span><br><span class="line">beforeMount - &gt; onBeforeMount</span><br><span class="line">mounted - &gt; onMounted</span><br><span class="line">methods -&gt; 去除，普通方式写方法</span><br><span class="line">beforeUpdate - &gt; onBeforeUpdate</span><br><span class="line">updated - &gt; onUpdated</span><br><span class="line">beforeDestroy - &gt; onBeforeUnmount</span><br><span class="line">destroyed - &gt; onUnmounted</span><br><span class="line">errorCaptured - &gt; onErrorCaptured</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Reactive（声明单一对象时使用）</strong></p><p>取得一个对象并返回原始对象的响应数据处理。</p><p>const obj = reactive({ count: 0 })</p><p><strong>ref（声明基础数据类型变量时使用）</strong></p><p>内部值并返回一个响应性且可变的ref对象。ref对象具有.value指向内部值的单个属性。</p><p>const number = ref(0);</p><p>获取值方式：number.value</p><p><strong>isRef</strong> <strong>和</strong> <strong>toRefs</strong></p><p>检查一个对象是否是ref对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const unwrapped = isRef(foo) ? foo.value : foo;</span><br><span class="line">function useMousePosition() &#123;</span><br><span class="line">  const pos = reactive(&#123;</span><br><span class="line">   x: 0,</span><br><span class="line">   y: 0</span><br><span class="line">  &#125;);</span><br><span class="line">  return toRefs(pos);</span><br><span class="line">&#125;</span><br><span class="line">const &#123; x, y &#125; = useMousePosition();</span><br></pre></td></tr></table></figure><p>toRefs将reactive对象转换为普通对象，保证对象解构或拓展运算符不会丢失原有响应式对象的响应。</p><p><strong>watch</strong> <strong>侦听器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const count = ref(100);</span><br><span class="line">watch(()=&gt;count.vlaue,()=&gt;&#123;</span><br><span class="line">  console.log(&#x27;count数值发生变化了&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">count.value = 200; // count重新赋值，watch则被执行</span><br></pre></td></tr></table></figure><p><strong>Computed</strong></p><p>可传入get和set，用于定义可更改的计算属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const count = ref(1);</span><br><span class="line">const plusOne = computed(&#123;</span><br><span class="line">    get: () =&gt; count.value + 1,</span><br><span class="line">    set: val =&gt; &#123; count.value = val - 1 &#125;</span><br><span class="line">&#125;);</span><br><span class="line">plusOne.value = 1;</span><br><span class="line">console.log(count.value); // 0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> import &#123; reactive &#125; from &#x27;@vue/composition-api&#x27;</span><br><span class="line"> setup(props, context) &#123;</span><br><span class="line">   // 这里放置data数据，生命周期，自定义的函数</span><br><span class="line"> &#125;,</span><br><span class="line"> setup(props, &#123; refs &#125;) &#123;</span><br><span class="line">// 解构写法</span><br><span class="line">context.attrs</span><br><span class="line">context.slots</span><br><span class="line">context.parent</span><br><span class="line">context.root // 根组件</span><br><span class="line">context.refs</span><br><span class="line">function aaa() &#123;</span><br><span class="line">  reuturn &#123;</span><br><span class="line">attrs: 0,</span><br><span class="line">slots: 1,</span><br><span class="line">parent: 2,</span><br><span class="line">root: 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let &#123; attrs: qq, slots, parent, root &#125; = aaa()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.request(&#123;</span><br><span class="line">  method: &#x27;post&#x27;,</span><br><span class="line">  timeout: 3000,</span><br><span class="line">  url: &#x27;/user&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &#x27;x&#x27;,</span><br><span class="line">    lastName: &#x27;y&#x27;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="axios拦截器"><a href="#axios拦截器" class="headerlink" title="axios拦截器"></a>axios拦截器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">utils request.js</span><br><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line"></span><br><span class="line">// 创建axios, 赋给变量</span><br><span class="line">const service = axios.create()</span><br><span class="line">// 添加请求拦截器</span><br><span class="line">service.interceptors.request.use(function (config) &#123;</span><br><span class="line">  // 在发送请求之前做些什么</span><br><span class="line">  // 请求头 后台需要前端传相关的参数</span><br><span class="line">  return config</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">  // 对请求错误做些什么</span><br><span class="line">  return Promise.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 添加响应拦截器</span><br><span class="line">service.interceptors.response.use(function (config) &#123;</span><br><span class="line">  // 在对响应数据做些什么</span><br><span class="line">  return config</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">  // 对响应错误做些什么</span><br><span class="line">  return Promise.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default service</span><br></pre></td></tr></table></figure><h3 id="vue-的环境变量"><a href="#vue-的环境变量" class="headerlink" title="vue 的环境变量"></a>vue 的环境变量</h3><p>你可以在你的项目根目录中放置下列文件来指定环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">env</span>                <span class="comment"># 在所有的环境中被载入</span></span><br><span class="line">.env.local          <span class="comment"># 在所有的环境中被载入，但会被 git 忽略</span></span><br><span class="line">.<span class="built_in">env</span>.[mode]         <span class="comment"># 只在指定的模式中被载入</span></span><br><span class="line">.<span class="built_in">env</span>.[mode].<span class="built_in">local</span>   <span class="comment"># 只在指定的模式中被载入，但会被 git 忽略</span></span><br></pre></td></tr></table></figure><p><strong>模式</strong>是 Vue CLI 项目中一个重要的概念。默认情况下，一个 Vue CLI 项目有三个模式：</p><ul><li><code>development</code> 模式用于 <code>vue-cli-service serve</code></li><li><code>test</code> 模式用于 <code>vue-cli-service test:unit</code></li><li><code>production</code> 模式用于 <code>vue-cli-service build</code> 和 <code>vue-cli-service test:e2e</code></li></ul><p>你可以通过传递 <code>--mode</code> 选项参数为命令行覆写默认的模式。例如，如果你想要在构建命令中使用开发环境变量：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue-cli-service build --mode development</span><br></pre></td></tr></table></figure><p>当运行 <code>vue-cli-service</code> 命令时，所有的环境变量都从对应的<a href="https://cli.vuejs.org/zh/guide/mode-and-env.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境文件</a>中载入。如果文件内部不包含 <code>NODE_ENV</code> 变量，它的值将取决于模式，例如，在 <code>production</code> 模式下被设置为 <code>&quot;production&quot;</code>，在 <code>test</code> 模式下被设置为 <code>&quot;test&quot;</code>，默认则是 <code>&quot;development&quot;</code>。</p><p><code>NODE_ENV</code> 将决定您的应用运行的模式，是开发，生产还是测试，因此也决定了创建哪种 webpack 配置。</p><p>例如通过将 <code>NODE_ENV</code> 设置为 <code>&quot;test&quot;</code>，Vue CLI 会创建一个优化过后的，并且旨在用于单元测试的 webpack 配置，它并不会处理图片以及一些对单元测试非必需的其他资源。</p><p>同理，<code>NODE_ENV=development</code> 创建一个 webpack 配置，该配置启用热更新，不会对资源进行 hash 也不会打出 vendor bundles，目的是为了在开发的时候能够快速重新构建。</p><p>当你运行 <code>vue-cli-service build</code> 命令时，无论你要部署到哪个环境，应该始终把 <code>NODE_ENV</code> 设置为 <code>&quot;production&quot;</code> 来获取可用于部署的应用程序。</p><p>NODE_ENV</p><p>如果在环境中有默认的 <code>NODE_ENV</code>，你应该移除它或在运行 <code>vue-cli-service</code> 命令的时候明确地设置 <code>NODE_ENV</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.env.development</span><br><span class="line">VUE_APP_ABC = 111 // 格式为VUE_APP_title</span><br><span class="line"></span><br><span class="line">console.log(process.env.VUE_APP_ABC) // 111</span><br></pre></td></tr></table></figure><p><strong>请注意，只有 <code>NODE_ENV</code>，<code>BASE_URL</code> 和以 <code>VUE_APP_</code> 开头的变量将通过 <code>webpack.DefinePlugin</code> 静态地嵌入到<em>客户端侧</em>的代码中。这是为了避免意外公开机器上可能具有相同名称的私钥。</strong></p><h3 id="跨域-设置代理proxy"><a href="#跨域-设置代理proxy" class="headerlink" title="跨域 设置代理proxy"></a>跨域 设置代理proxy</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vue.config.js</span><br><span class="line">proxy: &#123;</span><br><span class="line">  [process.env.VUE_APP_API]: &#123;</span><br><span class="line">    target: &#x27;http://www.web-jshtml.cn/productapi&#x27;,</span><br><span class="line">    changeOrigin: true,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">      [&#x27;^&#x27; + process.env.VUE_APP_API]: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, // 设置代理</span><br></pre></td></tr></table></figure><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/192669/13/11737/857084/60e91529E7bc30eb7/2f6729ec49479923.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="5、测试用例"></p><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/189951/15/12681/109277/60e91531E9aca2602/38ec3bdc82d040d5.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="6、程序流程图"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 添加响应拦截器</span><br><span class="line">import &#123; Message &#125; from &#x27;element-ui&#x27;</span><br><span class="line"></span><br><span class="line">service.interceptors.response.use(function (response) &#123;</span><br><span class="line">  // 在对响应数据做些什么</span><br><span class="line">  let data = response.data</span><br><span class="line">  if (data.resCode !== 0) &#123;</span><br><span class="line">    Message.error(data.message) // 在js文件需要单独引入</span><br><span class="line">    return Promise.reject(data)</span><br><span class="line">  &#125;</span><br><span class="line">  return data // 等价于 Promise.resolve(data)</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">  // 对响应错误做些什么</span><br><span class="line">  return Promise.reject(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 获取验证码</span><br><span class="line">const handleGetSms = (async () =&gt; &#123;</span><br><span class="line">  if (ruleForm.username === &#x27;&#x27;) &#123;</span><br><span class="line">    root.$message.error(&#x27;用户名不能为空&#x27;)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  if (!validateEmail(ruleForm.username)) &#123;</span><br><span class="line">    root.$message.error(&#x27;用户名格式错误，请重新输入&#x27;)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  loginButtonState.value = false</span><br><span class="line">  let data = await getSms(&#123; username: ruleForm.username &#125;)</span><br><span class="line">  root.$message.success(data.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// login.js</span><br><span class="line">import service from &#x27;@/utils/request.js&#x27;</span><br><span class="line">// 获取验证码接口</span><br><span class="line">export function getSms (data) &#123;</span><br><span class="line">  return service.request(&#123;</span><br><span class="line">    method: &#x27;post&#x27;,</span><br><span class="line">    url: &#x27;/getSms/&#x27;,</span><br><span class="line">    data</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">自动聚焦</span><br><span class="line">&lt;lable for=&quot;xx&quot;&gt;&lt;/lable&gt;</span><br><span class="line">&lt;input id=&quot;xx&quot; /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 重置表单</span><br><span class="line">refs[&#x27;ruleForm&#x27;].resetFields()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">设计 计时setInterval 超时timeout 功能</span><br><span class="line">    const handleGetSms = (() =&gt; &#123;</span><br><span class="line">      if (ruleForm.username === &#x27;&#x27;) &#123;</span><br><span class="line">        root.$message.error(&#x27;用户名不能为空&#x27;)</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      if (!validateEmail(ruleForm.username)) &#123;</span><br><span class="line">        root.$message.error(&#x27;用户名格式错误，请重新输入&#x27;)</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      codeButtonState.status = true</span><br><span class="line">      codeButtonState.text = &#x27;发送中&#x27;</span><br><span class="line">      let requestData = &#123;</span><br><span class="line">        username: ruleForm.username,</span><br><span class="line">        module: menuTab[0].current ? &#x27;login&#x27; : &#x27;register&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(async () =&gt; &#123;</span><br><span class="line">        let data = await getSms(requestData)</span><br><span class="line">        root.$message.success(data.message)</span><br><span class="line">        loginButtonState.value = false</span><br><span class="line">        // 调用定时器，倒计时60s</span><br><span class="line">        countDown(60)</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">    // 倒计时</span><br><span class="line">    const countDown = ((value) =&gt; &#123;</span><br><span class="line">      let time = value</span><br><span class="line">      // 判断是否有定时器，如果有则清除</span><br><span class="line">      if (timer.value) clearInterval(tiner.value)</span><br><span class="line">      timer.value = setInterval (() =&gt; &#123;</span><br><span class="line">        codeButtonState.text = --time</span><br><span class="line">        if (time === 0) &#123;</span><br><span class="line">          clearInterval(timer.value)</span><br><span class="line">          codeButtonState.text = &#x27;再次获取&#x27;</span><br><span class="line">          loginButtonState.value = true</span><br><span class="line">          codeButtonState.status = false</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 注册请求</span><br><span class="line">export function postRegister (data) &#123;</span><br><span class="line">  return service.request(&#123;</span><br><span class="line">    method: &#x27;post&#x27;,</span><br><span class="line">    url: &#x27;/register/&#x27;,</span><br><span class="line">    data</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 注册表单提交</span><br><span class="line">const submitForm = ((formName) =&gt; &#123;</span><br><span class="line">  refs[formName].validate((valid) =&gt; &#123;</span><br><span class="line">    if (valid) &#123;</span><br><span class="line">      let data = &#123;</span><br><span class="line">        username: ruleForm.username,</span><br><span class="line">        password: ruleForm.password,</span><br><span class="line">        code: ruleForm.code</span><br><span class="line">      &#125;</span><br><span class="line">      postRegister(data)</span><br><span class="line">      .then((responce) =&gt; &#123;</span><br><span class="line">        let data = responce.data</span><br><span class="line">        root.$message.success(data.message)</span><br><span class="line">        // 模拟注册成功</span><br><span class="line">        toggleMenu(menuTab[0])</span><br><span class="line">        clearCountDown()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      root.$message.error(&#x27;error submit&#x27;)</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 清除倒计时</span><br><span class="line">    const clearCountDown = (() =&gt; &#123;</span><br><span class="line">      codeButtonState.state = false,</span><br><span class="line">      codeButtonState.text = &#x27;获取验证码&#x27;</span><br><span class="line">      clearInterval(timer.value)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h2 id="密码加密"><a href="#密码加密" class="headerlink" title="密码加密"></a>密码加密</h2><h3 id="js-sha1"><a href="#js-sha1" class="headerlink" title="js-sha1"></a>js-sha1</h3><p><code>sha1</code>和<code>md5</code>加密是不可逆的 加密后无法解密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i js-sha1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sha1 from &#x27;js-sha1&#x27;</span><br><span class="line"></span><br><span class="line">password: sha1(ruleForm.password),</span><br></pre></td></tr></table></figure><h3 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h3><p>在前端先加密一次</p><p>后台接收到字符串再次加密</p><p>最后新的字符串写入数据库</p><h2 id="后台页面搭建"><a href="#后台页面搭建" class="headerlink" title="后台页面搭建"></a>后台页面搭建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">router.js</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/console&#x27;,</span><br><span class="line">    name: &#x27;console&#x27;,</span><br><span class="line">    component: () =&gt; import(&#x27;../views/Console&#x27;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue router"></a>vue router</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">router-link</span><br><span class="line">// 不带参数</span><br><span class="line">&lt;router-link :to: &quot;&#123; name: &#x27;xx&#x27; &#125;&quot;&gt;</span><br><span class="line">&lt;router-link :to: &quot;&#123; path: &#x27;/xx&#x27; &#125;&quot;&gt;</span><br><span class="line">&lt;a href=&quot;xx&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// 带参数</span><br><span class="line">&lt;router-link :to: &quot;&#123; name: &#x27;xx&#x27;, params: &#123;id: 1&#125; &#125;&quot;&gt;</span><br><span class="line">// 路由配置 path: &quot;/xx/:id&quot; 或者 path: &#x27;/xx:id&#x27;</span><br><span class="line">// url的参数不可见，刷新后参数会消失</span><br><span class="line"></span><br><span class="line">&lt;router-link :to: &quot;&#123; path: &#x27;/xx&#x27;, query: &#123; id: 1 &#125;&#125;&quot;&gt;</span><br><span class="line">// 路由可不配置</span><br><span class="line">// url带的参数是可见的，刷新后参数不会消失</span><br><span class="line">// query 传递的参数不能是对象</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push() 函数里面调用</span><br><span class="line">// 不带参数</span><br><span class="line">this.$router.push( &#123;name: &#x27;xx&#x27;&#125; )</span><br><span class="line">this.$router.push( &#123;path: &#x27;/xx&#x27;&#125; )</span><br><span class="line"></span><br><span class="line">// query 传参</span><br><span class="line">this.$router.push(&#123;</span><br><span class="line">path: &#x27;/xx&#x27;,</span><br><span class="line">query: &#123; id: 1 &#125;</span><br><span class="line">&#125;) </span><br><span class="line">// url 带的参数是可见的，刷新后参数不会消失</span><br><span class="line"></span><br><span class="line">// params 传参</span><br><span class="line">this.$router.push(&#123;</span><br><span class="line">name: &#x27;xx&#x27;,</span><br><span class="line">params: &#123; id: 1 &#125;</span><br><span class="line">&#125;) </span><br><span class="line">// 路由配置 path: &quot;/xx/:id&quot; 或者 path: &#x27;/xx:id&#x27;</span><br><span class="line">// url的参数不可见，刷新后参数会消失</span><br><span class="line">// 不配置path,刷新页面参数消失</span><br><span class="line">// 配置path，刷新页面id保留</span><br><span class="line"></span><br><span class="line">// query 和 params 区别</span><br><span class="line">query 跳转配合路由path属性，传参为明文，url上参数可见，刷新后参数不会消失</span><br><span class="line">params 跳转配合路由name属性，传参为密文，url上参数不可见，刷新后参数会消失</span><br></pre></td></tr></table></figure><h3 id="导航菜单设置"><a href="#导航菜单设置" class="headerlink" title="导航菜单设置"></a>导航菜单设置</h3><p>使用elementui导航菜单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-menu</span><br><span class="line">  default-active=&quot;1-4-1&quot;</span><br><span class="line">  class=&quot;el-menu-vertical-demo&quot;</span><br><span class="line">  @open=&quot;handleOpen&quot;</span><br><span class="line">  @close=&quot;handleClose&quot;</span><br><span class="line">  :collapse=&quot;isCollapse&quot;</span><br><span class="line">  background-color=&quot;transparent&quot;</span><br><span class="line">  text-color=&quot;#fff&quot;</span><br><span class="line">  active-text-color=&quot;#fff&quot;</span><br><span class="line">  router // 启用时以:index的参数为path进行跳转</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//使用route属性meta携带参数传参</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/&#x27;,</span><br><span class="line">    redirect: &#x27;/console&#x27;,</span><br><span class="line">    hidden: true,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      name:</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">//接收参数</span><br><span class="line">const routes = this.$router.options.routes</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// vue中如果想同时使用v-for 和 v-if， 可以使用computed 或者 &lt; template&gt;标签 vue中template没有实际意义</span><br><span class="line">      &lt;template v-for=&quot;(item, index) in routes&quot;&gt;</span><br><span class="line">        &lt;el-submenu</span><br><span class="line">          :index=&quot;index&quot;</span><br><span class="line">          v-if=&quot;!item.hidden&quot;</span><br><span class="line">          :key=&quot;item.id&quot;</span><br><span class="line">        &gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 修改element全局样式需要单独修改</span><br><span class="line">// elementui.scss</span><br><span class="line">.el-submenu .el-menu-item.is-active &#123;</span><br><span class="line">  background-color: #f56c6c !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="svg-icon制作"><a href="#svg-icon制作" class="headerlink" title="svg-icon制作"></a>svg-icon制作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在路由中配置meta.icon</span><br><span class="line">&lt;i :class=&quot;item.meta.icon&quot;&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 在vue中全局定义组件 需要引入vue的complile版本</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg :class=&quot;svgClass&quot; aria-hidden=&quot;true&quot;&gt;</span><br><span class="line">  &lt;use :xlink:href=&quot;name&quot;&gt;&lt;/use&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 解析svg</span><br><span class="line">const req = require.context(&#x27;./svg&#x27;, false, /\.svg$/)</span><br><span class="line">const requireAll = requireContext =&gt; &#123;</span><br><span class="line">  return requireContext.keys().map(requireContext)</span><br><span class="line">&#125;</span><br><span class="line">requireAll(req)</span><br><span class="line"></span><br><span class="line">// require.context(‘./svg’, false, /\.svg$/) 参数说明：</span><br><span class="line">// 第一个：目录</span><br><span class="line">// 第二个：是否遍历子级目录</span><br><span class="line">// 第三个：定义遍历文件规则</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// vue.config.js</span><br><span class="line">  chainWebpack: (config) =&gt; &#123;</span><br><span class="line">    const svgRule = config.module.rule(&quot;svg&quot;);</span><br><span class="line">    svgRule.uses.clear();</span><br><span class="line">    svgRule</span><br><span class="line">      .use(&quot;svg-sprite-loader&quot;)</span><br><span class="line">      .loader(&quot;svg-sprite-loader&quot;)</span><br><span class="line">      .options(&#123;</span><br><span class="line">        symbolId: &quot;icon-[name]&quot;,</span><br><span class="line">        include: [&quot;./src/icons&quot;]</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install svg-sprite-loader -S</span><br></pre></td></tr></table></figure><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p>state： 是存储的单一状态，是存储的基本数据</p><p>getters：getters是store的计算属性，对state的加工，是派生出来的数据。</p><p>mutations：对数据进行计算的方法全部写在里面（类似computed） 在页面中触发时使用</p><p>this.$store.commit(‘mutationName’)触发Mutations方法改变state的值</p><p>actions：action的功能和mutation是类似的，都是去变更store里的state，不过action和mutation有两点不同：</p><p>1、action主要处理的是异步的操作，mutation必须同步执行，而action就不受这样的限制，也就是说action中我们既可以处理同步（视图触发Action，Action再触发Mutation），也可以处理异步的操作</p><p>2、action改变状态，最后是通过提交mutation</p><p>this.$store.dispatch(actionName)</p><p>3、角色定位基于流程顺序，二者扮演不同的角色。</p><p>Mutation：专注于修改State，理论上是修改State的唯一途径。</p><p>Action：业务代码、异步请求。</p><h3 id="菜单导航收起"><a href="#菜单导航收起" class="headerlink" title="菜单导航收起"></a>菜单导航收起</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 兼容性处理</span><br><span class="line">@mixin webkit($type, $value)&#123;</span><br><span class="line">  -webkit-#&#123;$type&#125;: $value;</span><br><span class="line">  -moz-#&#123;$type&#125;: $value;</span><br><span class="line">  -o-#&#123;$type&#125;: $value;</span><br><span class="line">  -ms-#&#123;$type&#125;: $value;</span><br><span class="line">  #&#123;$type&#125;: $value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@include webkit(transition, all .3s ease 0s);</span><br><span class="line">// transition: property duration timing-function delay;</span><br></pre></td></tr></table></figure><h3 id="存储方法"><a href="#存储方法" class="headerlink" title="存储方法"></a>存储方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 页面刷新时数据初始化，需要缓存数据</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cookie.js</span><br><span class="line">npm i cookie_js -save</span><br><span class="line"></span><br><span class="line">import Cookie from &#x27;cookie_js&#x27;</span><br><span class="line">Cookie.set(&#x27;isCollapse&#x27;, JSON.stringify(state.isCollapse))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.sessionStorage.setItem(&#x27;isCollapse&#x27;, JSON.stringify(state.isCollapse))</span><br><span class="line">isCollapse: JSON.parse(sessionStorage.getItem(&#x27;isCollapes&#x27;)) || false</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  login(content, data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      // 接口</span><br><span class="line">      postLogin(data).then((response) =&gt;&#123;</span><br><span class="line">        resolve(response)</span><br><span class="line">      &#125;).catch(error =&gt; &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/176686/19/17349/270236/60dbe3deEe5dce88e/97237fc41076396b.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210630112304654"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 全局前置守卫</span><br><span class="line">// router.beforeEach 路由跳前之前 </span><br></pre></td></tr></table></figure><p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是<strong>异步</strong>解析执行，此时导航在所有守卫 resolve 完之前一直处于 <strong>等待中</strong>。</p><p>每个守卫方法接收三个参数：</p><ul><li><strong><code>to: Route</code></strong>: 即将要进入的目标路由对象</li><li><strong><code>from: Route</code></strong>: 当前导航正要离开的路由</li><li><strong><code>next: Function</code></strong>: 一定要调用该方法来 <strong>resolve</strong> 这个钩子。执行效果依赖 <code>next</code> 方法的调用参数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 路由守卫</span><br><span class="line">import router from &#x27;./index&#x27;</span><br><span class="line">import &#123; getToken &#125; from &#x27;../utils/app&#x27;</span><br><span class="line"></span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  if (getToken()) &#123;</span><br><span class="line">    // 路由动态添加，分配菜单。每个角色分配不同菜单</span><br><span class="line">    next()</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  whiteRouter.includes(to.path) ? next() : next(&#x27;/login&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import cookie from &#x27;cookie_js&#x27;</span><br><span class="line"></span><br><span class="line">export function getToken() &#123;</span><br><span class="line">  return cookie.get(&#x27;admin_token&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">export function setToken(value) &#123;</span><br><span class="line">  cookie.set(&#x27;admin_token&#x27;, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 修改vue.config.js</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      &#x27;/api&#x27;: &#123;</span><br><span class="line">        target: &#x27;http://www.web-jshtml.cn/productapi/token&#x27;, // 加上token</span><br><span class="line">        changeOrigin: true,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &#x27;^/api&#x27;: &#x27;&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  login(content, data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      // 接口</span><br><span class="line">      postLogin(data).then((response) =&gt;&#123;</span><br><span class="line">        let data = response.data</span><br><span class="line">        content.commit(&#x27;SET_TOKEN&#x27;, data.token)</span><br><span class="line">        content.commit(&#x27;SET_USERNAME&#x27;, data.username)</span><br><span class="line">        setToken(data.token)</span><br><span class="line">        resolve(response)</span><br><span class="line">      &#125;).catch(error =&gt; &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 用户切换路由到login页面清除cookie</span><br><span class="line">  if (getToken()) &#123;</span><br><span class="line">    // 路由动态添加，分配菜单。每个角色分配不同菜单</span><br><span class="line">    if (to.path === &#x27;/login&#x27;) &#123;</span><br><span class="line">      removeToken()</span><br><span class="line">      removeUsername()</span><br><span class="line">      store.commit(&#x27;SET_TOKEN&#x27;, &#x27;&#x27;)</span><br><span class="line">      store.commit(&#x27;SET_USERNAM&#x27;, &#x27;&#x27;)</span><br><span class="line">      next()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// exit</span><br><span class="line">    exit(content) &#123;</span><br><span class="line">      return new Promise((resolve) =&gt; &#123;</span><br><span class="line">        removeToken();</span><br><span class="line">        removeUsername();</span><br><span class="line">        content.commit(&#x27;SET_TOKEN&#x27;, &#x27;&#x27;)</span><br><span class="line">        content.commit(&#x27;SET_USERNAME&#x27;, &#x27;&#x27;)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     const exit =  () =&gt; &#123;</span><br><span class="line">       root.$store.dispatch(&#x27;exit&#x27;).then(() =&gt; &#123;</span><br><span class="line">         root.$router.push(&#123;</span><br><span class="line">           name: &#x27;login&#x27;</span><br><span class="line">         &#125;)</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="信息管理UI制作"><a href="#信息管理UI制作" class="headerlink" title="信息管理UI制作"></a>信息管理UI制作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 表格样式封装</span><br><span class="line">@mixin labelDom($align, $width, $line-height: &quot;normal&quot;)&#123;</span><br><span class="line">  label &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: $width + px;</span><br><span class="line">    text-align: $align;</span><br><span class="line">    line-height: $line-height + px;</span><br><span class="line">  &#125;</span><br><span class="line">  .warp-content &#123;</span><br><span class="line">      margin-left: $width + px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 占位符</span><br><span class="line">&lt;el-col :span=&quot;2&quot;&gt;&amp;nbsp;&lt;/el-col&gt;</span><br><span class="line">// 占位空间</span><br><span class="line">.black-space-30 &#123;</span><br><span class="line">  height: 30px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// table 样式</span><br><span class="line">// 若修改无效，可以尝试增加权重</span><br><span class="line">.el-table td,</span><br><span class="line">.el-table th &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 宽度设置 不要全部写死 留出一行自适应</span><br><span class="line">&lt;el-table-column prop=&quot;title&quot; label=&quot;标题&quot; &gt; &lt;/el-table-column&gt;</span><br><span class="line">   &lt;el-table-column prop=&quot;catagory&quot; label=&quot;类别&quot; width=&quot;130&quot;&gt; &lt;/el-table-column&gt;</span><br><span class="line">   &lt;el-table-column prop=&quot;data&quot; label=&quot;日期&quot; width=&quot;237&quot;&gt; &lt;/el-table-column&gt;</span><br><span class="line">   &lt;el-table-column prop=&quot;user&quot; label=&quot;管理员&quot; width=&quot;115&quot;&gt; &lt;/el-table-column&gt;</span><br><span class="line">   &lt;el-table-column label=&quot;操作&quot; width=&quot;160&quot;&gt; &lt;/el-table-column&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 底部分页</span><br><span class="line">    &lt;!-- 分页 --&gt;</span><br><span class="line">    &lt;el-row&gt;</span><br><span class="line">      &lt;el-col :span=&quot;12&quot;&gt;</span><br><span class="line">        &lt;el-button size=&quot;medium&quot; @click=&quot;deleteAll&quot;&gt;批量删除&lt;/el-button&gt;</span><br><span class="line">      &lt;/el-col&gt;</span><br><span class="line">      &lt;el-col :span=&quot;12&quot;&gt;</span><br><span class="line">        &lt;el-pagination</span><br><span class="line">          class=&quot;pull-right&quot;</span><br><span class="line">          background</span><br><span class="line">          @size-change=&quot;handleSizeChange&quot;</span><br><span class="line">          @current-change=&quot;handleCurrentChange&quot;</span><br><span class="line">          :page-sizes=&quot;[2, 4, 6, 8]&quot;</span><br><span class="line">          layout=&quot;total, sizes, prev, pager, next, jumper&quot;</span><br><span class="line">          :total=&quot;total&quot;</span><br><span class="line">        &gt;</span><br><span class="line">        &lt;/el-pagination&gt;</span><br><span class="line">      &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br></pre></td></tr></table></figure><h3 id="弹窗"><a href="#弹窗" class="headerlink" title="弹窗"></a>弹窗</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-dialog title=&quot;收货地址&quot; :visible.sync=&quot;dialog_info&quot;&gt;</span><br><span class="line">  dialog</span><br><span class="line">&lt;/el-dialog&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 封装成一个新组件 dialog.vue</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 子组件修改父组件的值</span><br><span class="line">  watch: &#123;</span><br><span class="line">    flag: &#123;</span><br><span class="line">      handler(newValue, oldValue) &#123;</span><br><span class="line">      // 赋值给一个新变量</span><br><span class="line">        this.dialog_info_flag = newValue</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// messageBox 弹框</span><br></pre></td></tr></table></figure><h3 id="vue的全局方法"><a href="#vue的全局方法" class="headerlink" title="vue的全局方法"></a>vue的全局方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  install(Vue, options) &#123;</span><br><span class="line">    Vue.prototype.confirm = (data) =&gt; &#123;</span><br><span class="line">      Vue.prototype.$confirm(data.content, data.tip || &quot;提示&quot;, &#123;</span><br><span class="line">          confirmButtonText: &quot;确定&quot;,</span><br><span class="line">          cancelButtonText: &quot;取消&quot;,</span><br><span class="line">          type: data.type || &quot;warning&quot;,</span><br><span class="line">          center: true</span><br><span class="line">        &#125;).then(() =&gt; &#123;</span><br><span class="line">          Vue.prototype.$message(&#123;</span><br><span class="line">            type: &quot;success&quot;,</span><br><span class="line">            message: &quot;删除成功!&quot;,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(() =&gt; &#123;</span><br><span class="line">          Vue.prototype.$message(&#123;</span><br><span class="line">            type: &quot;info&quot;,</span><br><span class="line">            message: &quot;已取消删除&quot;,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">// 在main.js注入</span><br><span class="line">import global from &#x27;@/utils/global.js&#x27;</span><br><span class="line">Vue.use(global)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// vue3.0写法</span><br><span class="line">import &#123; ref &#125; from &quot;@vue/composition-api&quot;;</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export function global3() &#123;</span><br><span class="line">  const str = ref(&#x27;&#x27;);</span><br><span class="line">  const confirm = (data) =&gt; &#123;</span><br><span class="line">    Vue.prototype.$confirm(data.content, data.tip || &quot;提示&quot;, &#123;</span><br><span class="line">        confirmButtonText: &quot;确定&quot;,</span><br><span class="line">        cancelButtonText: &quot;取消&quot;,</span><br><span class="line">        type: data.type || &quot;warning&quot;,</span><br><span class="line">        center: true</span><br><span class="line">      &#125;).then(() =&gt; &#123;</span><br><span class="line">        data.fn &amp;&amp; data.fn(data.id)</span><br><span class="line">        Vue.prototype.$message(&#123;</span><br><span class="line">          type: &quot;success&quot;,</span><br><span class="line">          message: &quot;删除成功!&quot;,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(() =&gt; &#123;</span><br><span class="line">        Vue.prototype.$message(&#123;</span><br><span class="line">          type: &quot;info&quot;,</span><br><span class="line">          message: &quot;已取消删除&quot;,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    str,</span><br><span class="line">    confirm</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 引用后</span><br><span class="line">    const &#123; confirm &#125; = global()</span><br></pre></td></tr></table></figure><h2 id="信息管理模块"><a href="#信息管理模块" class="headerlink" title="信息管理模块"></a>信息管理模块</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// /api/news.js</span><br><span class="line">// 分类添加</span><br><span class="line">export function addFirstCategory (data) &#123;</span><br><span class="line">  return service.request(&#123;</span><br><span class="line">    method: &#x27;post&#x27;,</span><br><span class="line">    url: &#x27;/news/addFirstCategory/&#x27;,</span><br><span class="line">    data</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 需要验证token信息，在请求头里传入</span><br><span class="line">config.headers.Tokey = cookie.get(admin_token)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 优化 添加完信息后，更新视图，需要再次请求资源 可以用vuex解决 减少一次请求</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const deleteCategoryComfirm = (id) =&gt; &#123;</span><br><span class="line">  deleteId.value = id;</span><br><span class="line">  confirm(&#123;</span><br><span class="line">    content: &quot;确认删除当前信息，确认后将无法恢复！！&quot;,</span><br><span class="line">    tip: &quot;警告&quot;,</span><br><span class="line">    fn: delCategory,</span><br><span class="line">    catchFn: () =&gt; &#123;&#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">const delCategory = () =&gt; &#123;</span><br><span class="line">  deleteCategory(&#123; categoryId: deleteId.value &#125;)</span><br><span class="line">    .then((res) =&gt; &#123;&#125;)</span><br><span class="line">    .catch((err) =&gt; &#123;&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="接口封装"><a href="#接口封装" class="headerlink" title="接口封装"></a>接口封装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// api/common.js</span><br><span class="line">import &#123; getCategory &#125; from &quot;@/api/news&quot;;</span><br><span class="line">import &#123; reactive &#125; from &quot;@vue/composition-api&quot;;</span><br><span class="line">export function common() &#123;</span><br><span class="line">  const categoryItem = reactive(&#123;</span><br><span class="line">    item: []</span><br><span class="line">  &#125;);</span><br><span class="line">  /**</span><br><span class="line">   * 获取分类</span><br><span class="line">   */</span><br><span class="line">  const getInfoCategory = () =&gt; &#123;</span><br><span class="line">    getCategory(&#123;&#125;)</span><br><span class="line">      .then(response =&gt; &#123;</span><br><span class="line">        categoryItem.item = response.data.data.data;</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(error =&gt; &#123;&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 获取全部分类</span><br><span class="line">   */</span><br><span class="line">  // const getInfoCategoryAll = () =&gt; &#123;</span><br><span class="line">  //   GetCategoryAll(&#123;&#125;)</span><br><span class="line">  //     .then(response =&gt; &#123;</span><br><span class="line">  //       categoryItem.item = response.data.data;</span><br><span class="line">  //     &#125;)</span><br><span class="line">  //     .catch(error =&gt; &#123;&#125;);</span><br><span class="line">  // &#125;;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    getInfoCategory,</span><br><span class="line">    // getInfoCategoryAll,</span><br><span class="line">    categoryItem</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 使用vuex</span><br><span class="line">    VuexGetInfoCategory(content, data) &#123;</span><br><span class="line">      return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        getCategory()</span><br><span class="line">          .then(res =&gt; &#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(err =&gt; &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    root.$store.dispatch(&#x27;VuexGetInfoCategory&#x27;).then(res =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="添加接口信息"><a href="#添加接口信息" class="headerlink" title="添加接口信息"></a>添加接口信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 数据多时，可以将数据封装在data中</span><br><span class="line">    const data = reactive(&#123;</span><br><span class="line">      dialog_info_flag: false,</span><br><span class="line">      formLabelWidth: &#x27;70px&#x27;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="vue子组件修改父组件属性值的两种方法"><a href="#vue子组件修改父组件属性值的两种方法" class="headerlink" title="vue子组件修改父组件属性值的两种方法"></a>vue子组件修改父组件属性值的两种方法</h3><p>1、子组件调用<code>$emit</code>方法来触发父组件的事件，从而修改属性值</p><p>2、使用<code>.sync</code>配合$emit方法以update的模式触发事件从而修改父组件属性值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 父组件 传属性title给子组件，使用.sync修饰符</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;blog :title.sync=&quot;title&quot;&gt;&lt;/blog&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// 子组件接收父组件传的属性title</span><br><span class="line">props: &#123;</span><br><span class="line">  title: String</span><br><span class="line">&#125;</span><br><span class="line">// 子组件调用$emit方法以update的模式触发事件来修改title的值</span><br><span class="line">&lt;div @click=&quot;$emit(&#x27;update:title&#x27;,&#x27;new title&#x27;)&quot;&gt;</span><br><span class="line">  &#123;&#123;title&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 两种刷新数据方式</span><br><span class="line"> * 1、暴力型，直接刷新接口</span><br><span class="line"> * 2、返回列表，手动修改指定的数据</span><br><span class="line"> // let newData = category.item.filter(</span><br><span class="line">//   (item) =&gt; item.id !== deleteId.value</span><br><span class="line">// );</span><br><span class="line">// category.item = newData;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h2 id="info页面编辑详情"><a href="#info页面编辑详情" class="headerlink" title="info页面编辑详情"></a>info页面编辑详情</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// router</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#x27;/infoDetailed&#x27;,</span><br><span class="line">        name: &#x27;InfoDetailed&#x27;,</span><br><span class="line">        hidden: true,</span><br><span class="line">        meta: &#123;</span><br><span class="line">          name: &#x27;详情&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        component: () =&gt; import(&#x27;../views/Info/infoDetailed.vue&#x27;)</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-button type=&quot;success&quot; size=&quot;mini&quot;&gt;</span><br><span class="line">  &lt;router-link :to=&quot;&#123; name: &#x27;InfoDetailed&#x27; &#125;&quot;&gt; 编辑详情 &lt;/router-link&gt;</span><br><span class="line">&lt;/el-button&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@for $i from 1 through 110 &#123;</span><br><span class="line">    .margin-left-#&#123;$i&#125; &#123; margin-left:(1px * $i); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="富文本编辑器"><a href="#富文本编辑器" class="headerlink" title="富文本编辑器"></a>富文本编辑器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-quill-editor -S</span><br><span class="line">引入</span><br><span class="line">import &#123; quillEditor &#125; from &quot;vue-quill-editor&quot;; </span><br><span class="line">import &#x27;quill/dist/quill.core.css&#x27;;</span><br><span class="line">import &#x27;quill/dist/quill.snow.css&#x27;;</span><br><span class="line">import &#x27;quill/dist/quill.bubble.css&#x27;;</span><br><span class="line"></span><br><span class="line">Template</span><br><span class="line">&lt;quillEditor v-model=&quot;form.content&quot; ref=&quot;myQuillEditor&quot; :options=&quot;data.editorOption&quot;/</span><br></pre></td></tr></table></figure><h2 id="用户管理页面"><a href="#用户管理页面" class="headerlink" title="用户管理页面"></a>用户管理页面</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 作用域插槽</span><br><span class="line">&lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">  &lt;slot :name=&quot;item.slotName&quot; :data=&quot;scope.row&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 数据处理</span><br><span class="line">let requestData = Object.assign(&#123;&#125;, data.form); // 浅拷贝</span><br><span class="line">requestData.role = requestData.role.join(); // 数组转字符串，默认以，号隔开</span><br><span class="line">requestData.btnPerm = requestData.btnPerm.join(); // 数组转字符串，默认以，号隔开</span><br><span class="line">requestData.region = JSON.stringify(data.cityPickerData);</span><br></pre></td></tr></table></figure><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>1.默认路由(所有人都能访问)</p><p>2.动态路由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const defaultRouterMap = [&#123;</span><br><span class="line">    path: &#x27;/&#x27;,</span><br><span class="line">    redirect: &#x27;/console&#x27;,</span><br><span class="line">    hidden: true,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      name: &#x27;主页&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/login&#x27;,</span><br><span class="line">    name: &#x27;login&#x27;,</span><br><span class="line">    hidden: true,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      name: &#x27;登录&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    component: () =&gt; import(&#x27;../views/Login&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/console&#x27;,</span><br><span class="line">    name: &#x27;console&#x27;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      name: &#x27;控制台&#x27;,</span><br><span class="line">      icon: &#x27;console&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    redirect: &#x27;/index&#x27;,</span><br><span class="line">    children: [&#123;</span><br><span class="line">      path: &#x27;/index&#x27;,</span><br><span class="line">      name: &#x27;index&#x27;,</span><br><span class="line">      meta: &#123;</span><br><span class="line">        name: &#x27;首页&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      component: () =&gt; import(&#x27;../views/Console/index.vue&#x27;)</span><br><span class="line">    &#125;],</span><br><span class="line">    component: Layout</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">const asyncRouterMap = [&#123;</span><br><span class="line">    path: &#x27;/info&#x27;,</span><br><span class="line">    name: &#x27;info&#x27;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      name: &#x27;信息管理&#x27;,</span><br><span class="line">      icon: &#x27;info&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    component: Layout,</span><br><span class="line">    children: [&#123;</span><br><span class="line">        path: &#x27;/infoIndex&#x27;,</span><br><span class="line">        name: &#x27;infoIndex&#x27;,</span><br><span class="line">        meta: &#123;</span><br><span class="line">          name: &#x27;信息列表&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        component: () =&gt; import(&#x27;../views/Info/index.vue&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#x27;/infoCategory&#x27;,</span><br><span class="line">        name: &#x27;infoCategory&#x27;,</span><br><span class="line">        meta: &#123;</span><br><span class="line">          name: &#x27;信息分类&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        component: () =&gt; import(&#x27;../views/Info/category.vue&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#x27;/infoDetailed&#x27;,</span><br><span class="line">        name: &#x27;InfoDetailed&#x27;,</span><br><span class="line">        hidden: true,</span><br><span class="line">        meta: &#123;</span><br><span class="line">          name: &#x27;详情&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        component: () =&gt; import(&#x27;../views/Info/infoDetailed.vue&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/user&#x27;,</span><br><span class="line">    name: &#x27;user&#x27;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      name: &#x27;用户管理&#x27;,</span><br><span class="line">      icon: &#x27;user&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    children: [&#123;</span><br><span class="line">      path: &#x27;/userIndex&#x27;,</span><br><span class="line">      name: &#x27;userIndex&#x27;,</span><br><span class="line">      meta: &#123;</span><br><span class="line">        name: &#x27;用户列表&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      component: () =&gt; import(&#x27;../views/User/index.vue&#x27;)</span><br><span class="line">    &#125;, ],</span><br><span class="line">    component: Layout,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  mode: &#x27;hash&#x27;,</span><br><span class="line">  routes: defaultRouterMap,</span><br><span class="line">  scrollBehavior: () =&gt; (&#123; y: 0 &#125;),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">store permission.js</span><br><span class="line">import &#123;</span><br><span class="line">  getUserRole</span><br><span class="line">&#125; from &#x27;@/api/login&#x27;</span><br><span class="line">import &#123;</span><br><span class="line">  defaultRouterMap,</span><br><span class="line">  asyncRouterMap</span><br><span class="line">&#125; from &quot;@/router/index.js&quot;</span><br><span class="line"></span><br><span class="line">function hasPremission(roles, router) &#123;</span><br><span class="line">  if (router.meta &amp;&amp; router.meta.role) &#123;</span><br><span class="line">    return roles.some(item =&gt; router.meta.role.indexOf(item) &gt;= 0)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const state = &#123;</span><br><span class="line">  roles: [],</span><br><span class="line">  allRouters: defaultRouterMap,</span><br><span class="line">  addRouters: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const getters = &#123;</span><br><span class="line">  roles: state =&gt; state.roles,</span><br><span class="line">  allRouters: state =&gt; state.allRouters,  // 所有的</span><br><span class="line">  addRouters: state =&gt; state.addRouters,  // 匹配的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mutations = &#123;</span><br><span class="line">  SET_ROLES(state, value) &#123;</span><br><span class="line">    state.roles = value</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  SET_ROUTER(state, router) &#123;</span><br><span class="line">    state.addRouters = router</span><br><span class="line">    state.allRouters = defaultRouterMap.concat(router)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const actions = &#123;</span><br><span class="line">  getRoles(&#123;</span><br><span class="line">    commit</span><br><span class="line">  &#125;, requestData) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      getUserRole()</span><br><span class="line">        .then(res =&gt; &#123;</span><br><span class="line">          let role = res.data</span><br><span class="line">          commit(&#x27;SET_ROLES&#x27;, role)</span><br><span class="line">          resolve(role)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(err =&gt; &#123;&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  // &quot;sale&quot;, &quot;technician&quot;, &quot;manager&quot;</span><br><span class="line">  createRouter(&#123;</span><br><span class="line">    commit</span><br><span class="line">  &#125;, data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      let role = data.role</span><br><span class="line">      let addRouters = []</span><br><span class="line">      // 超管的状态</span><br><span class="line">      if (role.includes(&#x27;admin&#x27;)) &#123;</span><br><span class="line">        addRouters = asyncRouterMap</span><br><span class="line">      &#125; else &#123; // 普通管理员</span><br><span class="line">        addRouters = asyncRouterMap.filter(item =&gt; &#123;</span><br><span class="line">          if (hasPremission(role, item)) &#123;</span><br><span class="line">            // 优先判断 </span><br><span class="line">            if (item.children &amp;&amp; item.children.length &gt; 0) &#123;</span><br><span class="line">              item.children = item.children.filter(child =&gt; &#123;</span><br><span class="line">                if (hasPremission(role, child)) &#123;</span><br><span class="line">                  return child;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">              return item;</span><br><span class="line">            &#125;</span><br><span class="line">            return item;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        addRouters.push(asyncRouterMap[asyncRouterMap.length - 1]);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      commit(&#x27;SET_ROUTER&#x27;, addRouters);</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  namespaced: false,</span><br><span class="line">  state,</span><br><span class="line">  getters,</span><br><span class="line">  mutations,</span><br><span class="line">  actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取用户角色接口</span><br><span class="line">export function getUserRole (data = &#123;&#125;) &#123;</span><br><span class="line">  return service.request(&#123;</span><br><span class="line">    method: &#x27;post&#x27;,</span><br><span class="line">    url: &#x27;/userRole/&#x27;,</span><br><span class="line">    data</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  if (getToken()) &#123;</span><br><span class="line">    // 路由动态添加，分配菜单。每个角色分配不同菜单</span><br><span class="line">    if (to.path === &#x27;/login&#x27;) &#123;</span><br><span class="line">      removeToken()</span><br><span class="line">      removeUsername()</span><br><span class="line">      store.commit(&#x27;SET_TOKEN&#x27;, &#x27;&#x27;)</span><br><span class="line">      store.commit(&#x27;SET_USERNAME&#x27;, &#x27;&#x27;)</span><br><span class="line">      next()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 获取用户的色</span><br><span class="line">      // 动态分配路由权限</span><br><span class="line">      /**</span><br><span class="line">       * 1、什么时候处理动态路由 beforeEach</span><br><span class="line">       * 2、以什么条件处理</span><br><span class="line">       * roles[]</span><br><span class="line">       */</span><br><span class="line">      if (store.getters[&#x27;roles&#x27;].length === 0) &#123;</span><br><span class="line">        store.dispatch(&#x27;getRoles&#x27;)</span><br><span class="line">          .then(res =&gt; &#123;</span><br><span class="line">            store.dispatch(&#x27;createRouter&#x27;, res)</span><br><span class="line">            .then(res =&gt; &#123;</span><br><span class="line">              let addRouters = store.getters.addRouters</span><br><span class="line">              let allRouters = store.getters.allRouters</span><br><span class="line">              // 路由更新</span><br><span class="line">              router.options.routes = allRouters</span><br><span class="line">              // 添加动态路由</span><br><span class="line">              console.log(router.options.routes);</span><br><span class="line">              router.addRoutes(addRouters)</span><br><span class="line">              next( &#123;...to, replace:true&#125; )</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125; else &#123; next() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  whiteRouter.includes(to.path) ? next() : next(&#x27;/login&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 全局注册方法 按钮权限</span><br><span class="line">import &#123; buttonPermission &#125; from &#x27;./utils/buttonPermission&#x27;</span><br><span class="line">Vue.prototype.btnPerm = buttonPermission</span><br><span class="line"></span><br><span class="line">import store from &#x27;../store&#x27;</span><br><span class="line"></span><br><span class="line">buttonPermission.js</span><br><span class="line">export function buttonPermission(permission) &#123;</span><br><span class="line">  const button = store.getters[&quot;buttonPermission&quot;];</span><br><span class="line">  return button.indexOf(permission) !== -1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 自定义指令</span><br><span class="line">import Vue from &quot;vue&quot;;</span><br><span class="line">import store from &quot;../store/permission.js&quot;;</span><br><span class="line">// 自定义指令</span><br><span class="line">Vue.directive(&quot;btnPerm&quot;, &#123;</span><br><span class="line">  bind: function (el, bingind, vnode) &#123;</span><br><span class="line">    bingind.def.hasBtnPerm()</span><br><span class="line">    // el 绑定的对象 DOM，原生JS处理</span><br><span class="line">    // 操作DOM</span><br><span class="line">    if (bingind.def.hasBtnPerm(bingind.value)) &#123;</span><br><span class="line">      el.className = el.className + &quot; show-button&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  inserted: function (el) &#123;&#125;,</span><br><span class="line">  update: function () &#123;&#125;,</span><br><span class="line">  componentUpdated: function () &#123;&#125;,</span><br><span class="line">  unbind: function () &#123;&#125;,</span><br><span class="line">  hasBtnPerm: function () &#123;</span><br><span class="line">    const button = store.getters[&quot;buttonPermission&quot;]; // 请求到的数据权限</span><br><span class="line">    const roles = store.getters[&#x27;roles&#x27;]; // 获取角色 </span><br><span class="line">    // 如果是超级管理员</span><br><span class="line">    console.log(roles);</span><br><span class="line">    if (roles.includes(&quot;admin&quot;)) &#123;</span><br><span class="line">      return true</span><br><span class="line">    &#125;</span><br><span class="line">    return button.indexOf(permission) != -1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义指令，5种状态（操作DOM元素）</title>
      <link href="/2021/07/08/zi-ding-yi-zhi-ling-5-chong-zhuang-tai-cao-zuo-dom-yuan-su/"/>
      <url>/2021/07/08/zi-ding-yi-zhi-ling-5-chong-zhuang-tai-cao-zuo-dom-yuan-su/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(&quot;hello&quot;,&#123;</span><br><span class="line">  bind:function(el,bingind,vnode)&#123;</span><br><span class="line">    bingind.value</span><br><span class="line">    bingind.def</span><br><span class="line">      el.style[&quot;color&quot;] = bingind.value;</span><br><span class="line">      console.log(&quot;1-bind&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  inserted:function()&#123;</span><br><span class="line">      console.log(&quot;2-insert&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  update:function()&#123;</span><br><span class="line">      console.log(&quot;3-update&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  componentUpdated:function()&#123;</span><br><span class="line">      console.log(&#x27;4 - componentUpdated&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">  unbind:function()&#123;</span><br><span class="line">      console.log(&#x27;5 - unbind&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h5><p> 只调用一次，指令第一次绑定到元素时候调用，用这个钩子可以定义一个绑定时执行一次的初始化动作。</p><h5 id="Inserted"><a href="#Inserted" class="headerlink" title="Inserted"></a>Inserted</h5><p> 被绑定的元素插入父节点的时候调用(父节点存在即可调用，不必存在document中)</p><h5 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h5><p> 被绑定与元素所在模板更新时调用，而且无论绑定值是否有变化，通过比较更新前后的绑定值，忽略不必要的模板更新</p><h5 id="componentUpdate"><a href="#componentUpdate" class="headerlink" title="componentUpdate"></a>componentUpdate</h5><p> 被绑定的元素所在模板完成一次更新更新周期的时候调用</p><h5 id="Unbind"><a href="#Unbind" class="headerlink" title="Unbind"></a>Unbind</h5><p> 只调用一次，指令月元素解绑的时候调用</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue中组件通讯</title>
      <link href="/2021/07/06/vue-zhong-zu-jian-tong-xun/"/>
      <url>/2021/07/06/vue-zhong-zu-jian-tong-xun/</url>
      
        <content type="html"><![CDATA[<p><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/186889/24/12294/65324/60e6a558E458c92c5/4132aa7c6b3e26d1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="组件通讯"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">父子组件</span><br><span class="line">A与B、B与C、B与D、C与E、D与E</span><br><span class="line"></span><br><span class="line">子孙组件</span><br><span class="line">A与D、B与E</span><br><span class="line"></span><br><span class="line">兄弟组件</span><br><span class="line">C与D</span><br><span class="line"></span><br><span class="line">隔代组件</span><br><span class="line">A与E</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="父、子组件通讯-props、emit、-sync"><a href="#父、子组件通讯-props、emit、-sync" class="headerlink" title="父、子组件通讯 props、emit、.sync"></a>父、子组件通讯 props、emit、.sync</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">A.vue（父组件）</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;B data.sync=&quot;100“ @eventFn=“parent” /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    setup(props) &#123;</span><br><span class="line">        eventFn = (number) =&gt; &#123;&#125;</span><br><span class="line">        return &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">B.vue（子组件）</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; data &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        data: &#123;</span><br><span class="line">            type: String,</span><br><span class="line">            defaule: &quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    setup()&#123;</span><br><span class="line">        emit(“parent”, 100) // 回调父组件的方法</span><br><span class="line">        emit(“update:data”, 111111)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="中央事件总线"><a href="#中央事件总线" class="headerlink" title="中央事件总线"></a>中央事件总线</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">创建实例</span><br><span class="line">bus.js</span><br><span class="line">import Vue from ‘vue&#x27;;</span><br><span class="line">export default new Vue();</span><br><span class="line"></span><br><span class="line">调用事件</span><br><span class="line">import Bus from &#x27;bus.js&#x27;</span><br><span class="line">Bus.$emit(&#x27;getTarget&#x27;, 11111);</span><br><span class="line"></span><br><span class="line">注册事件</span><br><span class="line">import Bus from &#x27;bus.js&#x27;</span><br><span class="line">Bus.$on(&#x27;getTarget&#x27;, target =&gt; &#123;  </span><br><span class="line">    console.log(target);  </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><h2 id="attrs、-listeners"><a href="#attrs、-listeners" class="headerlink" title="$attrs、$listeners"></a>$attrs、$listeners</h2><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/196048/5/12137/31100/60e6a558Eb6f30c02/ad8f9abe557abe3f.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><p><strong>注意事件</strong>: 通过props接收相同名称的属性，将不被读取</p><h2 id="provide、inject"><a href="#provide、inject" class="headerlink" title="provide、inject"></a>provide、inject</h2><p><strong>跨级组件间的通信</strong></p><p>祖先组件中通过provider来提供变量，然后在子孙组件中通过inject来注入变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">父组件</span><br><span class="line">provide(&quot;customVal&quot;, &quot;我是父组件向子组件传递的值&quot;);</span><br><span class="line"></span><br><span class="line">子组件</span><br><span class="line">inject(&quot;customVal&quot;);</span><br></pre></td></tr></table></figure><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">store</span><br><span class="line">state: &#123; username: &#x27;xx&#x27; &#125;,</span><br><span class="line">mutation: &#123;</span><br><span class="line">  SET_USERNAME(state, value) &#123;</span><br><span class="line">      state.username = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">index.vue</span><br><span class="line">this.$store.state.commit(&#x27;SET_USERNAME&#x27;, &#x27;yy&#x27;)</span><br></pre></td></tr></table></figure><h2 id="parent、-children、ref"><a href="#parent、-children、ref" class="headerlink" title="$parent、$children、ref"></a>$parent、$children、ref</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原生JS实现—打地鼠游戏</title>
      <link href="/2021/07/04/yuan-sheng-js-shi-xian-da-di-shu-you-xi/"/>
      <url>/2021/07/04/yuan-sheng-js-shi-xian-da-di-shu-you-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p><a href="https://v833.github.io/javscript-projects/05-Whack%20A%20Mole/index.html">点击查看</a></p><h2 id="HTML-代码"><a href="#HTML-代码" class="headerlink" title="HTML 代码"></a>HTML 代码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Whack A Mole!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&#x27;https://fonts.googleapis.com/css?family=Amatic+SC:400,700&#x27;</span> <span class="attr">rel</span>=<span class="string">&#x27;stylesheet&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;text/css&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Whack-a-mole! <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;score&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&quot;startGame()&quot;</span>&gt;</span>Start!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;game&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hole hole1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mole&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hole hole2&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mole&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hole hole3&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mole&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hole hole4&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mole&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hole hole5&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mole&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hole hole6&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mole&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>开始游戏的按钮</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&quot;startGame()&quot;</span>&gt;</span>Start!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>展示所得分数</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Whack-a-mole! <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;score&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>地洞、地鼠</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;game&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hole hole1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mole&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hole hole2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mole&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hole hole3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mole&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hole hole4&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mole&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hole hole5&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mole&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hole hole6&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mole&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>hole</code>为地洞，地洞中有一个地鼠<code>mole</code>。</p><h2 id="CSS-代码"><a href="#CSS-代码" class="headerlink" title="CSS 代码"></a>CSS 代码</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ffc600</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*,</span><br><span class="line">*<span class="selector-pseudo">:before</span>,</span><br><span class="line">*<span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: inherit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;Amatic SC&#x27;</span>, cursive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">10rem</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.score</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.2</span>);</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">3rem</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">1rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.game</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hole</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">0</span> <span class="number">33.33%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hole</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">dirt.svg</span>) bottom center no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: contain;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">70px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: -<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.mole</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;mole.svg&#x27;</span>) bottom center no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">60%</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.4s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hole</span><span class="selector-class">.up</span> <span class="selector-class">.mole</span> &#123;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>dirt.svg</code>为地洞的图片</p></li><li><p><code>mole.svg</code>为地鼠的图片</p></li></ul><h2 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> holes = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.hole&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> scoreBoard = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.score&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> moles = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.mole&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> lastHole;</span><br><span class="line">  <span class="keyword">let</span> timeUp = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">randomTime</span>(<span class="params">min, max</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (max - min) + min);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">randomHole</span>(<span class="params">holes</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> idx = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * holes.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">const</span> hole = holes[idx];</span><br><span class="line">    <span class="keyword">if</span> (hole === lastHole) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">randomHole</span>(holes);</span><br><span class="line">    &#125;</span><br><span class="line">    lastHole = hole;</span><br><span class="line">    <span class="keyword">return</span> hole;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">peep</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="title function_">randomTime</span>(<span class="number">200</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">const</span> hole = <span class="title function_">randomHole</span>(holes);</span><br><span class="line">    hole.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;up&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      hole.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;up&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (!timeUp) <span class="title function_">peep</span>();</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">startGame</span>(<span class="params"></span>) &#123;</span><br><span class="line">    scoreBoard.<span class="property">textContent</span> = <span class="number">0</span>;</span><br><span class="line">    timeUp = <span class="literal">false</span>;</span><br><span class="line">    score = <span class="number">0</span>;</span><br><span class="line">    <span class="title function_">peep</span>();</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> timeUp = <span class="literal">true</span>, <span class="number">10000</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bonk</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    score++;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parentNode</span>.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;up&#x27;</span>);</span><br><span class="line">    scoreBoard.<span class="property">textContent</span> = score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  moles.<span class="title function_">forEach</span>(<span class="function"><span class="params">mole</span> =&gt;</span> mole.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, bonk));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>获取所有的地洞、得分、地鼠标签</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> holes = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.hole&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> scoreBoard = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.score&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> moles = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.mole&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>初始化变量</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastHole; <span class="comment">//用于存储上一次的地洞，主要用于和下一次做对比</span></span><br><span class="line"><span class="keyword">let</span> timeUp = <span class="literal">false</span>; <span class="comment">//判断时间是否结束</span></span><br><span class="line"><span class="keyword">let</span> score = <span class="number">0</span>; <span class="comment">//记录得分</span></span><br></pre></td></tr></table></figure><ul><li>事件监听</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 敲中地鼠，调用bonk方法</span></span><br><span class="line">moles.<span class="title function_">forEach</span>(<span class="function"><span class="params">mole</span> =&gt;</span> mole.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, bonk));</span><br></pre></td></tr></table></figure><ul><li>bonk函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bonk</span>(<span class="params">e</span>) &#123;</span><br><span class="line">     score++; <span class="comment">// 得一分</span></span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">parentNode</span>.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;up&#x27;</span>); <span class="comment">// 隐藏地鼠</span></span><br><span class="line">     scoreBoard.<span class="property">textContent</span> = score; <span class="comment">//更新得分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>开始游戏</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">startGame</span>(<span class="params"></span>) &#123;</span><br><span class="line">    scoreBoard.<span class="property">textContent</span> = <span class="number">0</span>; <span class="comment">//清空得分</span></span><br><span class="line">    timeUp = <span class="literal">false</span>; <span class="comment">//将时间是否结束标志设置为false</span></span><br><span class="line">    score = <span class="number">0</span>; <span class="comment">//得分归零</span></span><br><span class="line">    <span class="title function_">peep</span>(); <span class="comment">//调用peep()函数</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> timeUp = <span class="literal">true</span>, <span class="number">10000</span>) <span class="comment">//设置倒计时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>randomTime设置一个<code>min - max</code>之间的随机数</li></ul><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round">Math.round</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>( <span class="number">20.49</span>); <span class="comment">//  20</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>( <span class="number">20.5</span>);  <span class="comment">//  21</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>( <span class="number">42</span>  );  <span class="comment">//  42</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>(-<span class="number">20.5</span>);  <span class="comment">// -20</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>(-<span class="number">20.51</span>); <span class="comment">// -21</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">randomTime</span>(<span class="params">min, max</span>) &#123;</span><br><span class="line">    <span class="comment">//Math.round() 函数返回一个数字四舍五入后最接近的整数值。</span></span><br><span class="line">    <span class="comment">//Math.random() 函数返回一个浮点,  伪随机数在范围[0，1)，然后您可以缩放到所需的范围。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (max - min) + min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>randomHole函数</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/floor">Math.floor</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>( <span class="number">45.95</span>); <span class="comment">//  45</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>( <span class="number">45.05</span>); <span class="comment">//  45</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(  <span class="number">4</span>   ); <span class="comment">//   4</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(-<span class="number">45.05</span>); <span class="comment">// -46 </span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(-<span class="number">45.95</span>); <span class="comment">// -46</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//随机选出一个地洞，用于弹出地鼠</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">randomHole</span>(<span class="params">holes</span>) &#123;</span><br><span class="line">    <span class="comment">//Math.floor() 返回小于或等于一个给定数字的最大整数。</span></span><br><span class="line">    <span class="keyword">const</span> idx = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * holes.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">const</span> hole = holes[idx];</span><br><span class="line">    <span class="keyword">if</span> (hole === lastHole) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">randomHole</span>(holes);</span><br><span class="line">    &#125;</span><br><span class="line">    lastHole = hole;</span><br><span class="line">    <span class="keyword">return</span> hole;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>peep()函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 地鼠、地洞处理函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">peep</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//产生一个随机数，这个数主要用于设置当前的地鼠什么时候消失</span></span><br><span class="line">    <span class="keyword">const</span> time = <span class="title function_">randomTime</span>(<span class="number">200</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//随机产生一个 0 - 5的值，用于随机选择一个地洞</span></span><br><span class="line">    <span class="keyword">const</span> hole = <span class="title function_">randomHole</span>(holes);</span><br><span class="line">    <span class="comment">//弹出地鼠</span></span><br><span class="line">    hole.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;up&#x27;</span>);</span><br><span class="line">    <span class="comment">//time时间后地鼠消失</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        hole.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;up&#x27;</span>);</span><br><span class="line">        <span class="comment">//如果倒计时没到，继续调用peep()函数</span></span><br><span class="line">        <span class="keyword">if</span> (!timeUp) </span><br><span class="line">            <span class="title function_">peep</span>();</span><br><span class="line">    &#125;, time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 原生js项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2 源码学习</title>
      <link href="/2021/07/03/vue2-yuan-ma-xue-xi/"/>
      <url>/2021/07/03/vue2-yuan-ma-xue-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h3><p>flow 是facebook出品的javascript静态类型检查工具。Vue.js的源码用了Flow做了静态类型检查</p><h4 id="Flow工作方式"><a href="#Flow工作方式" class="headerlink" title="Flow工作方式"></a>Flow工作方式</h4><p>通常类型检查分为2种方式</p><p><strong>类型判断</strong>：通过变量的使用上下文来推断出变量类型，然后根据这些推断来检查类型</p><p><strong>类型注释</strong>： 事先注释好我们期待的类型，Flow会基于这些注释来判断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// @flow</span><br><span class="line">function split (str)&#123;</span><br><span class="line">  return str.split(&#x27; &#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">split(&#x27;11&#x27;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// @flow</span><br><span class="line">function add (x: number, y: number): number &#123;</span><br><span class="line">  return x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(12, 11)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Bar &#123;</span><br><span class="line">  x: string;</span><br><span class="line">  y: string | number;</span><br><span class="line">  z: boolean;</span><br><span class="line"></span><br><span class="line">  constructor(x: string, y: string | number, z: boolean) &#123;</span><br><span class="line">    this.x = x</span><br><span class="line">    this.y = y</span><br><span class="line">    this.z = z</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let bar: Bar = new Bar(&#x27;hello&#x27;, 4)</span><br><span class="line">let obj: &#123;a: string, b: number, c: Array&lt;string&gt;, d: Bar&#125; = &#123;</span><br><span class="line">  a: &#x27;hello&#x27;,</span><br><span class="line">  b: 11,</span><br><span class="line">  c: [&#x27;hello&#x27;, &#x27;world&#x27;],</span><br><span class="line">  d: new Bar(&#x27;hello&#x27;, 3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue-js源码构建"><a href="#Vue-js源码构建" class="headerlink" title="Vue.js源码构建"></a>Vue.js源码构建</h3><p>Vue.js源码构建是基于rollup构ta 建，它的构建相关配置都在scripts目录下</p><h3 id="从入口开始"><a href="#从入口开始" class="headerlink" title="从入口开始"></a>从入口开始</h3><p>Vue本身是一个函数，实现一个类，原型上挂载了很多方法</p><p><strong>global-api</strong>：Vue上的静态属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue在instance index.js中定义</span><br></pre></td></tr></table></figure><h3 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h3><p>Vue.js一个核心思路式数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不直接操作DOM，而是通过修改数据，<strong>DOM变成了数据的映射</strong>，我们所有的逻辑都是对数据的修改，而不用触碰DOM，这样的代码非常利于维护。</p><p>声明式的将数据渲染为DOM</p><h4 id="new-Vue发生了什么"><a href="#new-Vue发生了什么" class="headerlink" title="new Vue发生了什么"></a>new Vue发生了什么</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">执行了init方法</span><br><span class="line">function initData (vm) &#123;</span><br><span class="line">let data = vm.$options.data</span><br><span class="line">observe(data, true /* asRootData */) // 做响应式处理</span><br><span class="line">&#125;</span><br><span class="line">  const props = vm.$options.props</span><br><span class="line">  const methods = vm.$options.methods</span><br><span class="line">  将data数据代理到vm上</span><br><span class="line">  如访问data.x =&gt; this.x (this._data.x)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue 初始化主要就干了几件事情，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等等。</span><br><span class="line">    if (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line">在初始化的最后，检测到如果有 el 属性，则调用 vm.$mount 方法挂载 vm，挂载的目标就是把模板渲染成最终的 DOM，那么接下来我们来分析 Vue 的挂载过程。</span><br></pre></td></tr></table></figure><h4 id="Vue-实例挂载的实现"><a href="#Vue-实例挂载的实现" class="headerlink" title="Vue 实例挂载的实现"></a>Vue 实例挂载的实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">有render函数直接调用mount方法，没有将template转换成render函数 </span><br><span class="line">render 生成 VNode</span><br><span class="line">template = getOuterHTML(el)</span><br><span class="line">Vue 不能挂载在 body、html 这样的根节点上。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果没有定义 render 方法，则会把 el 或者 template 字符串转换成 render 方法。这里我们要牢记，在 Vue 2.0 版本中，所有 Vue 的组件的渲染最终都需要 render 方法，无论我们是用单文件 .vue 方式开发组件，还是写了 el 或者 template 属性，最终都会转换成 render 方法，那么这个过程是 Vue 的一个“在线编译”的过程，它是调用 compileToFunctions 方法实现的，编译过程我们之后会介绍。最后，调用原先原型上的 $mount 方法挂载。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">渲染watcher 当数据发生变化，调用updateComponent更新</span><br></pre></td></tr></table></figure><h4 id="render"><a href="#render" class="headerlink" title="render"></a>render</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue 的 _render 方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 Node。它的定义在 src/core/instance/render.js 文件中：</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render (createElement) &#123;</span><br><span class="line">return createElement(&#x27;div&#x27;, &#123;</span><br><span class="line">attrs: &#123;</span><br><span class="line">id: &#x27;#app1&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, this.message)</span><br><span class="line">&#125; // 挂载的元素替换掉原有元素</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们在平时的开发工作中手写 render 方法的场景比较少，而写的比较多的是 template 模板，在之前的 mounted 方法的实现中，会把 template 编译成 render 方法，但这个编译过程是非常复杂的，</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际上，vm.$createElement 方法定义是在执行 initRender 方法的时候，可以看到除了 vm.$createElement 方法，还有一个 vm._c 方法，它是被模板编译成的 render 函数使用，而 vm.$createElement 是用户手写 render 方法使用的， 这俩个方法支持的参数相同，并且内部都调用了 createElement 方法。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm._render 最终是通过执行 createElement 方法并返回的是 vnode，它是一个虚拟 Node。Vue 2.0 相比 Vue 1.0 最大的升级就是利用了 Virtual DOM。因此在分析 createElement 的实现前，我们先了解一下 Virtual DOM 的概念。</span><br></pre></td></tr></table></figure><h4 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h4><p>真正的 DOM 元素是非常庞大的，因为浏览器的标准就把 <strong>DOM 设计的非常复杂</strong>。当我们频繁的去做 DOM 更新，会产生一定的性能问题。</p><p>而 Virtual DOM 就是用一个原生的 JS 对象去描述一个 DOM 节点，所以它比创建一个 DOM 的代价要小很多。在 Vue.js 中，Virtual DOM 是用 <code>VNode</code> 这么一个 <code>Class</code> 去描述，它是定义在 <code>src/core/vdom/vnode.js</code> 中的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">其实 VNode 是对真实 DOM 的一种抽象描述，它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等，其它属性都是都是用来扩展 VNode 的灵活性以及实现一些特殊 feature 的。由于 VNode 只是用来映射到真实 DOM 的渲染，不需要包含操作 DOM 的方法，因此它是非常轻量和简单的。</span><br><span class="line">Virtual DOM 除了它的数据结构的定义，映射到真实的 DOM 实际上要经历 VNode 的 create、diff、patch 等过程。那么在 Vue.js 中，VNode 的 create 是通过之前提到的 createElement 方法创建的，我们接下来分析这部分的实现。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export function createElement (</span><br><span class="line">  context: Component,</span><br><span class="line">  tag: any,</span><br><span class="line">  data: any,</span><br><span class="line">  children: any,</span><br><span class="line">  normalizationType: any,</span><br><span class="line">  alwaysNormalize: boolean</span><br><span class="line">): VNode | Array&lt;VNode&gt; &#123;</span><br><span class="line">  if (Array.isArray(data) || isPrimitive(data)) &#123;</span><br><span class="line">    normalizationType = children</span><br><span class="line">    children = data</span><br><span class="line">    data = undefined</span><br><span class="line">  &#125; // 对参数个数不一致的处理，前移</span><br></pre></td></tr></table></figure><p>每个 VNode 有 <code>children</code>，<code>children</code> 每个元素也是一个 VNode，这样就形成了一个 VNode Tree，它很好的描述了我们的 DOM Tree。</p><p>回到 <code>mountComponent</code> 函数的过程，我们已经知道 <code>vm._render</code> 是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 <code>vm._update</code> 完成的，接下来分析一下这个过程。</p><h4 id="vm-update"><a href="#vm-update" class="headerlink" title="vm._update"></a>vm._update</h4><p>Vue 的 <code>_update</code> 是实例的一个私有方法，它被调用的时机有 2 个，<strong>一个是首次渲染，一个是数据更新的时候</strong>；由于我们这一章节只分析首次渲染部分，数据更新部分会在之后分析响应式原理的时候涉及。**<code>_update</code> 方法的作用是把 VNode 渲染成真实的 DOM**，它的定义在 <code>src/core/instance/lifecycle.js</code> 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_update 的核心就是调用 vm.__patch__ 方法，这个方法实际上在不同的平台，比如 web 和 weex 上的定义是不一样的，因此在 web 平台中它的定义在 src/platforms/web/runtime/index.js 中：</span><br><span class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop</span><br><span class="line">可以看到，甚至在 web 平台上，是否是服务端渲染也会对这个方法产生影响。因为在服务端渲染中，没有真实的浏览器 DOM 环境，所以不需要把 VNode 最终转换成 DOM，因此是一个空函数，而在浏览器端渲染中，它指向了 patch 方法，它的定义在 src/platforms/web/runtime/patch.js中：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <code>patch</code> 方法，它接收 4个参数，<code>oldVnode</code> 表示旧的 VNode 节点，它也可以不存在或者是一个 DOM 对象；<code>vnode</code> 表示执行 <code>_render</code> 后返回的 VNode 的节点；<code>hydrating</code> 表示是否是服务端渲染；<code>removeOnly</code> 是给 <code>transition-group</code> 用的，之后会介绍。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将oldVnode (真实DOM) 转换成真实Vnode</span><br><span class="line">insert 新的DOM 删除旧的DOM 相当节点替换</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于我们传入的 oldVnode 实际上是一个 DOM container，所以 isRealElement 为 true，接下来又通过 emptyNodeAt 方法把 oldVnode 转换成 VNode 对象，然后再调用 createElm 方法，这个方法在这里非常重要</span><br></pre></td></tr></table></figure><p><strong>最后调用 <code>insert</code> 方法把 <code>DOM</code> 插入到父节点中，因为是递归调用，子元素会优先调用 <code>insert</code>，所以整个 <code>vnode</code> 树节点的插入顺序是先子后父。</strong></p><blockquote><p>其实就是调用原生 DOM 的 API 进行 DOM 操作</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch 方法:实际上整个过程就是递归创建了一个完整的 DOM 树并插入到 Body 上。</span><br></pre></td></tr></table></figure><h4 id="Vue-初始化到最终渲染"><a href="#Vue-初始化到最终渲染" class="headerlink" title="Vue 初始化到最终渲染"></a>Vue 初始化到最终渲染</h4><p><strong>new Vue =&gt; init =&gt; $mount =&gt; compile =&gt; render =&gt; vnode =&gt; patch =&gt; DOM</strong></p><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>Vue.js 另一个核心思想是组件化。所谓组件化，就是<strong>把页面拆分成多个组件</strong> (component)，每个组件依赖的 CSS、JavaScript、模板、图片等资源放在一起开发和维护。组件是资源独立的，组件在系统内部可复用，组件和组件之间可以嵌套。</p><h3 id="createComponent"><a href="#createComponent" class="headerlink" title="createComponent"></a>createComponent</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组件Vnode的children为空</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  // router,</span><br><span class="line">  render: createElement =&gt; createElement(App) // 传入的是组件</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure><p>上一章我们在分析 <code>createElement</code> 的实现的时候，它最终会调用 <code>_createElement</code> 方法，其中有一段逻辑是对参数 <code>tag</code> 的判断，如果是一个普通的 html 标签，像上一章的例子那样是一个普通的 div，则会实例化一个普通 VNode 节点，否则通过 <code>createComponent</code> 方法创建一个组件 VNode。</p><p> App 对象，它本质上是一个 <code>Component</code> 类型。直接通过 <code>createComponent</code> 方法来创建 <code>vnode</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.构造子类构造函数</span><br><span class="line">2.安装组件钩子函数</span><br><span class="line">3.实例化 vnode</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们之前提到 Vue.js 使用的 Virtual DOM 参考的是开源库 snabbdom，它的一个特点是在 VNode 的 patch 流程中对外暴露了各种时机的钩子函数，方便我们做一些额外的事情，Vue.js 也是充分利用这一点，在初始化一个 Component 类型的 VNode 的过程中实现了几个钩子函数：</span><br></pre></td></tr></table></figure><h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p>通过前一章的分析我们知道，当我们通过 <code>createComponent</code> 创建了组件 VNode，接下来会走到 <code>vm._update</code>，执行 <code>vm.__patch__</code> 去把 VNode 转换成真正的 DOM 节点。这个过程我们在前一章已经分析过了，但是针对一个普通的 VNode 节点，接下来我们来看看<strong>组件的 VNode</strong> 会有哪些不一样的地方。</p><h4 id="了解组件patch的整体流程"><a href="#了解组件patch的整体流程" class="headerlink" title="了解组件patch的整体流程"></a>了解组件patch的整体流程</h4><h4 id="了解组件patch流程中的activeInstance、vm-vnode、vm-vnode"><a href="#了解组件patch流程中的activeInstance、vm-vnode、vm-vnode" class="headerlink" title="了解组件patch流程中的activeInstance、vm.$vnode、vm._vnode"></a>了解组件patch流程中的activeInstance、vm.$vnode、vm._vnode</h4><h4 id="了解嵌套组件的插入顺序"><a href="#了解嵌套组件的插入顺序" class="headerlink" title="了解嵌套组件的插入顺序"></a>了解嵌套组件的插入顺序</h4><p>在完成组件的整个 <code>patch</code> 过程后，最后执行 <code>insert(parentElm, vnode.elm, refElm)</code> 完成组件的 DOM 插入，如果组件 <code>patch</code> 过程中又创建了子组件，那么DOM 的插入顺序是<strong>先子后父</strong>。(<strong><code>递归</code></strong>)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$el = vm.__patch__()</span><br></pre></td></tr></table></figure><p>Patch整体流程：createComponent =》子组件初始化 =》子组件renfer =》子组件patch</p><h3 id="合并配置"><a href="#合并配置" class="headerlink" title="合并配置"></a>合并配置</h3><p>了解外部调用场景的配置合并</p><p>了解组件场景的配置合并</p><p>通过之前章节的源码分析我们知道，<code>new Vue</code> 的过程通常有 2 种场景，一种是外部我们的代码主动调用 <code>new Vue(options)</code> 的方式实例化一个 Vue 对象；另一种是我们上一节分析的组件过程中内部通过 <code>new Vue(options)</code> 实例化子组件。</p><p>无论哪种场景，都会执行实例的 <code>_init(options)</code> 方法，它首先会执行一个 <code>merge options</code> 的逻辑，相关的代码在 <code>src/core/instance/init.js</code> 中：</p><h4 id="外部调用场景"><a href="#外部调用场景" class="headerlink" title="外部调用场景"></a>外部调用场景</h4><p>当执行 <code>new Vue</code> 的时候，在执行 <code>this._init(options)</code> 的时候，就会执行如下逻辑去合并 <code>options</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="property">$options</span> = <span class="title function_">mergeOptions</span>(</span><br><span class="line">  <span class="title function_">resolveConstructorOptions</span>(vm.<span class="property">constructor</span>),</span><br><span class="line">  options || &#123;&#125;,</span><br><span class="line">  vm</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里通过调用 <code>mergeOptions</code> 方法来合并，它实际上就是把 <code>resolveConstructorOptions(vm.constructor)</code> 的返回值和 <code>options</code> 做合并，<code>resolveConstructorOptions</code> 的实现先不考虑，在我们这个场景下，它还是简单返回 <code>vm.constructor.options</code>，相当于 <code>Vue.options</code>，那么这个值又是什么呢，其实在 <code>initGlobalAPI(Vue)</code> 的时候定义了这个值，代码在 <code>src/core/global-api/index.js</code> 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initGlobalAPI</span> (<span class="title class_">Vue</span>: <span class="title class_">GlobalAPI</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property">options</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="variable constant_">ASSET_TYPES</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property">options</span>[type + <span class="string">&#x27;s&#x27;</span>] = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// this is used to identify the &quot;base&quot; constructor to extend all plain-object</span></span><br><span class="line">  <span class="comment">// components with in Weex&#x27;s multi-instance scenarios.</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property">options</span>.<span class="property">_base</span> = <span class="title class_">Vue</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">extend</span>(<span class="title class_">Vue</span>.<span class="property">options</span>.<span class="property">components</span>, builtInComponents)</span><br><span class="line">  <span class="comment">// .</span></span><br></pre></td></tr></table></figure><p>首先通过 <code>Vue.options = Object.create(null)</code> 创建一个空对象，然后遍历 <code>ASSET_TYPES</code>，<code>ASSET_TYPES</code> 的定义在 <code>src/shared/constants.js</code> 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">ASSET_TYPES</span> = [</span><br><span class="line">  <span class="string">&#x27;component&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;directive&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;filter&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>所以上面遍历 <code>ASSET_TYPES</code> 后的代码相当于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property">options</span>.<span class="property">components</span> = &#123;&#125;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">options</span>.<span class="property">directives</span> = &#123;&#125;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">options</span>.<span class="property">filters</span> = &#123;&#125;</span><br></pre></td></tr></table></figure><p>接着执行了 <code>Vue.options._base = Vue</code>，它的作用在我们上节实例化子组件的时候介绍了。</p><p>最后通过 <code>extend(Vue.options.components, builtInComponents)</code> 把一些内置组件扩展到 <code>Vue.options.components</code> 上，Vue 的内置组件目前有 <code>&lt;keep-alive&gt;</code>、<code>&lt;transition&gt;</code> 和 <code>&lt;transition-group&gt;</code> 组件，<strong>这也就是为什么我们在其它组件中使用 <code>&lt;keep-alive&gt;</code> 组件不需要注册的原因</strong>，这块儿后续我们介绍 <code>&lt;keep-alive&gt;</code> 组件的时候会详细讲。</p><p><code>mergeOptions</code> 主要功能就是把 <code>parent</code> 和 <code>child</code> 这两个对象根据一些合并策略，合并成一个新对象并返回。比较核心的几步，先递归把 <code>extends</code> 和 <code>mixins</code> 合并到 <code>parent</code> 上，然后遍历 <code>parent</code>，调用 <code>mergeField</code>，然后再遍历 <code>child</code>，如果 <code>key</code> 不在 <code>parent</code> 的自身属性上，则调用 <code>mergeField</code>。</p><p>这里有意思的是 <code>mergeField</code> 函数，它对不同的 <code>key</code> 有着不同的合并策略。</p><p>所以对于钩子函数，他们的合并策略都是 <code>mergeHook</code> 函数。这个函数的实现也非常有意思，用了一个多层 3 元运算符，逻辑就是如果不存在 <code>childVal</code> ，就返回 <code>parentVal</code>；否则再判断是否存在 <code>parentVal</code>，如果存在就把 <code>childVal</code> 添加到 <code>parentVal</code> 后返回新数组；否则返回 <code>childVal</code> 的数组。所以回到 <code>mergeOptions</code> 函数，一旦 <code>parent</code> 和 <code>child</code> 都定义了相同的钩子函数，<strong>那么它们会把 2 个钩子函数合并成一个数组</strong>。(先父后子)</p><h4 id="组件场景"><a href="#组件场景" class="headerlink" title="组件场景"></a>组件场景</h4><p>组件的构造函数是通过 <code>Vue.extend</code> 继承自 <code>Vue</code> 的</p><p>把实例化子组件传入的子组件父 VNode 实例 <code>parentVnode</code>、子组件的父 Vue 实例 <code>parent</code> 保存到 <code>vm.$options</code> 中，另外还保留了 <code>parentVnode</code> 配置中的如 <code>propsData</code> 等其它的属性。</p><p>这么看来，<code>initInternalComponent</code> 只是做了简单一层对象赋值，并不<strong>涉及到递归、合并策略</strong>等复杂逻辑。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>那么至此，Vue 初始化阶段对于 <code>options</code> 的合并过程就介绍完了，我们需要知道对于 <code>options</code> 的合并有 2 种方式，子组件初始化过程通过 <code>initInternalComponent</code> 方式要比外部初始化 Vue 通过 <code>mergeOptions</code> 的过程要快，合并完的结果保留在 <code>vm.$options</code> 中。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如需要设置数据监听、编译模板、挂载实例到 DOM、在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，给予用户机会在一些特定的场景下添加他们自己的代码。</p><p>源码中最终执行生命周期的函数都是调用 <code>callHook</code> 方法，它的定义在 <code>src/core/instance/lifecycle</code> 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export function callHook (vm: Component, hook: string) &#123;</span><br><span class="line">  // #7573 disable dep collection when invoking lifecycle hooks</span><br><span class="line">  pushTarget()</span><br><span class="line">  const handlers = vm.$options[hook]</span><br><span class="line">  const info = `$&#123;hook&#125; hook`</span><br><span class="line">  if (handlers) &#123;</span><br><span class="line">    for (let i = 0, j = handlers.length; i &lt; j; i++) &#123;</span><br><span class="line">      invokeWithErrorHandling(handlers[i], vm, null, vm, info)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (vm._hasHookEvent) &#123;</span><br><span class="line">    vm.$emit(&#x27;hook:&#x27; + hook)</span><br><span class="line">  &#125;</span><br><span class="line">  popTarget()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上一节中，我们详细地介绍了 Vue.js 合并 <code>options</code> 的过程，各个阶段的生命周期的函数也被合并到 <code>vm.$options</code> 里，并且是一个<strong>数组</strong>。<strong>因此 <code>callhook</code> 函数的功能就是调用某个生命周期钩子注册的所有回调函数</strong>。</p><h4 id="beforeCreate-amp-created"><a href="#beforeCreate-amp-created" class="headerlink" title="beforeCreate &amp; created"></a>beforeCreate &amp; created</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">init 过程中</span><br><span class="line">initLifecycle(vm)</span><br><span class="line">   initEvents(vm)</span><br><span class="line">   initRender(vm)</span><br><span class="line">   callHook(vm, &#x27;beforeCreate&#x27;)</span><br><span class="line">   initInjections(vm) // resolve injections before data/props</span><br><span class="line">   initState(vm)</span><br><span class="line">   initProvide(vm) // resolve provide after data/props</span><br><span class="line">   callHook(vm, &#x27;created&#x27;)</span><br></pre></td></tr></table></figure><p>可以看到 <code>beforeCreate</code> 和 <code>created</code> 的钩子调用是在 <code>initState</code> 的前后，<code>initState</code> 的作用是初始化 <code>props</code>、<code>data</code>、<code>methods</code>、<code>watch</code>、<code>computed</code> 等属性。那么显然 <code>beforeCreate</code> 的钩子函数中就不能获取到 <code>props</code>、<code>data</code> 中定义的值，也不能调用 <code>methods</code> 中定义的函数。</p><p>在这俩个钩子函数执行的时候，并没有渲染 DOM，所以我们也不能够访问 DOM，一般来说，如果组件在加载的时候需要和后端有交互，放在这俩个钩子函数执行都可以，如果是需要访问 <code>props</code>、<code>data</code> 等数据的话，就需要使用 <code>created</code> 钩子函数。<strong>之后我们会介绍 vue-router 和 vuex 的时候会发现它们都混合了 <code>beforeCreate</code> 钩子函数。</strong></p><h4 id="beforeMount-amp-mounted"><a href="#beforeMount-amp-mounted" class="headerlink" title="beforeMount &amp; mounted"></a>beforeMount &amp; mounted</h4><p>顾名思义，<code>beforeMount</code> 钩子函数发生在 <code>mount</code>，也就是 DOM 挂载之前，它的调用时机是在 <code>mountComponent</code> 函数中，定义在 <code>src/core/instance/lifecycle.js</code> 中</p><p>在<strong>执行 <code>vm._render()</code> 函数渲染 VNode 之前</strong>（执行完了compie过程编译为render函数），执行了 <code>beforeMount</code> 钩子函数，在执行完 <code>vm._update()</code> 把 VNode patch 到真实 DOM 后，执行 <code>mounted</code> 钩子。注意，这里对 <code>mounted</code> 钩子函数执行有一个判断逻辑，<code>vm.$vnode</code> 如果为 <code>null</code>，则表明这不是一次组件的初始化过程，而是我们通过外部 <code>new Vue</code> 初始化过程。那么对于组件，它的 <code>mounted</code> 时机在哪儿呢？</p><p>之前我们提到过，组件的 VNode patch 到 DOM 后，会执行 <code>invokeInsertHook</code> 函数，把 <code>insertedVnodeQueue</code> 里保存的钩子函数依次执行一遍，它的定义在 <code>src/core/vdom/patch.js</code> 中：</p><p>对于同步渲染的子组件而言，<code>mounted</code> 钩子函数的执行顺序是先子后父。</p><h4 id="beforeUpdate-amp-updated"><a href="#beforeUpdate-amp-updated" class="headerlink" title="beforeUpdate &amp; updated"></a>beforeUpdate &amp; updated</h4><p><code>beforeUpdate</code> 的执行时机是在渲染 Watcher 的 <code>before</code> 函数中，我们刚才提到过</p><p>注意这里有个判断，也就<strong>是在组件已经 <code>mounted</code> 之后，才会去调用这个钩子函数。</strong></p><p><code>update</code> 的执行时机是在<code>flushSchedulerQueue</code> 函数调用的时候，它的定义在 <code>src/core/observer/scheduler.js</code> 中</p><p>我们之前提过，在<strong>组件 mount 的过程中</strong>，会实例化一个渲染的 <code>Watcher</code> 去监听 <code>vm</code> 上的数据变化重新渲染，这段逻辑发生在 <code>mountComponent</code> 函数执行的时候</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function callUpdatedHooks (queue) &#123;</span><br><span class="line">  let i = queue.length</span><br><span class="line">  while (i--) &#123;</span><br><span class="line">    const watcher = queue[i]</span><br><span class="line">    const vm = watcher.vm</span><br><span class="line">    // watcher是渲染watcher </span><br><span class="line">    if (vm._watcher === watcher &amp;&amp; vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">      callHook(vm, &#x27;updated&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="beforeDestroy-amp-destroyed"><a href="#beforeDestroy-amp-destroyed" class="headerlink" title="beforeDestroy &amp; destroyed"></a>beforeDestroy &amp; destroyed</h4><p>顾名思义，<code>beforeDestroy</code> 和 <code>destroyed</code> 钩子函数的执行时机在组件销毁的阶段，终会调用 <code>$destroy</code> 方法，它的定义在 <code>src/core/instance/lifecycle.js</code> 中：</p><p>包括从 <code>parent</code> 的 <code>$children</code> 中删掉自身，删除 <code>watcher</code>，当前渲染的 VNode 执行销毁钩子函数等，执行完毕后再调用 <code>destroy</code> 钩子函数。</p><p>在 <code>$destroy</code> 的执行过程中，它又会执行 <code>vm.__patch__(vm._vnode, null)</code> 触发它子组件的销毁钩子函数，这样一层层的递归调用，所以 <code>destroy</code> 钩子函数执行顺序是先子后父，和 <code>mounted</code> 过程一样。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>这一节主要介绍了 Vue 生命周期中各个钩子函数的执行时机以及顺序，通过分析，<strong>我们知道了如在 <code>created</code> 钩子函数中可以访问到数据，在 <code>mounted</code> 钩子函数中可以访问到 DOM，在 <code>destroy</code> 钩子函数中可以做一些定时器销毁工作，了解它们有利于我们在合适的生命周期去做不同的事情。</strong></p><h3 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h3><p>在 Vue.js 中，除了它内置的组件如 <code>keep-alive</code>、<code>component</code>、<code>transition</code>、<code>transition-group</code> 等，其它用户自定义组件在使用前必须注册。</p><p>Vue.js 提供了 2 种组件的注册方式，全局注册和局部注册。接下来我们从源码分析的角度来分析这两种注册方式。</p><h4 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h4><p>要注册一个全局组件，可以使用 <code>Vue.component(tagName, options)</code>。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那么，<code>Vue.component</code> 函数是在什么时候定义的呢，它的定义过程发生在最开始初始化 Vue 的全局函数的时候，代码在 <code>src/core/global-api/assets.js</code> 中：</p><p>函数首先遍历 <code>ASSET_TYPES</code>，得到 <code>type</code> 后挂载到 Vue 上 。<code>ASSET_TYPES</code> 的定义在 <code>src/shared/constants.js</code> 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">ASSET_TYPES</span> = [</span><br><span class="line">  <span class="string">&#x27;component&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;directive&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;filter&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>所以实际上 Vue 是初始化了 3 个全局函数，并且如果 <code>type</code> 是 <code>component</code> 且 <code>definition</code> 是一个对象的话，通过 <code>this.opitons._base.extend</code>， 相当于 <code>Vue.extend</code> 把这个对象转换成一个继承于 Vue 的构造函数，最后通过 <code>this.options[type + &#39;s&#39;][id] = definition</code> 把它挂载到 <code>Vue.options.components</code> 上。</p><p>由于我们每个组件的创建都是通过 <code>Vue.extend</code> 继承而来，我们之前分析过在继承的过程中有这么一段逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Sub</span>.<span class="property">options</span> = <span class="title function_">mergeOptions</span>(</span><br><span class="line">  <span class="title class_">Super</span>.<span class="property">options</span>,</span><br><span class="line">  extendOptions</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>也就是说它会把 <code>Vue.options</code> 合并到 <code>Sub.options</code>，也就是组件的 <code>options</code> 上， 然后在组件的实例化阶段，会执行 <code>merge options</code> 逻辑，把 <code>Sub.options.components</code> 合并到 <code>vm.$options.components</code> 上。</p><p><strong>我们在使用 <code>Vue.component(id, definition)</code> 全局注册组件的时候，id 可以是连字符、驼峰或首字母大写的形式。</strong></p><h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><p>Vue.js 也同样支持局部注册，我们可以在一个组件内部使用 <code>components</code> 选项做组件的局部注册，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">HelloWorld</span> <span class="keyword">from</span> <span class="string">&#x27;./components/HelloWorld&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="title class_">HelloWorld</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件的 Vue 的实例化阶段有一个<strong>合并 <code>option</code> 的逻辑</strong>，之前我们也分析过，所以就把 <code>components</code> 合并到 <code>vm.$options.components</code> 上，这样我们就可以在 <code>resolveAsset</code> 的时候拿到这个组件的构造函数，并作为 <code>createComponent</code> 的钩子的参数。</p><p>注意，局部注册和全局注册不同的是，只有该类型的组件才可以访问局部注册的子组件，而全局注册是扩展到 <code>Vue.options</code> 下，所以在所有组件创建的过程中，<strong>都会从全局的 <code>Vue.options.components</code> 扩展到当前组件的 <code>vm.$options.components</code> 下，这就是全局注册的组件能被任意使用的原因。</strong></p><p><strong>当我们使用到组件库的时候，往往更通用基础组件都是全局注册的，而编写的特例场景的业务组件都是局部注册的。</strong></p><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>在我们平时的开发工作中，为了减少首屏代码体积，往往会把一些非首屏的组件设计成异步组件，按需加载。Vue 也原生支持了异步组件的能力，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;async-example&#x27;</span>, <span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">   <span class="comment">// 这个特殊的 require 语法告诉 webpack</span></span><br><span class="line">   <span class="comment">// 自动将编译后的代码分割成不同的块，</span></span><br><span class="line">   <span class="comment">// 这些块将通过 Ajax 请求自动下载。</span></span><br><span class="line">   <span class="built_in">require</span>([<span class="string">&#x27;./my-async-component&#x27;</span>], resolve)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS实现时钟效果</title>
      <link href="/2021/07/02/js-shi-xian-shi-zhong-xiao-guo/"/>
      <url>/2021/07/02/js-shi-xian-shi-zhong-xiao-guo/</url>
      
        <content type="html"><![CDATA[<p><a href="https://v833.github.io/javscript-projects/04-JS%20and%20CSS%20Clock/">点击查看</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>实现模拟时钟的效果，大致思路和解决方案如下：</p><ul><li>分别获取到当前时间的时、分、秒。</li><li>通过时分秒对一圈360度，进行映射，确定每一个指针所需旋转的角度。</li><li>通过CSS的<code>transform：rotate(deg)</code>，来实时的调整指针在键盘中的位置。</li></ul><h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clock&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clock-face&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hand hour-hand&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hand min-hand&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hand second-hand&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#018DED</span> <span class="built_in">url</span>(<span class="string">http://unsplash.it/1500/1000?image=881&amp;blur=50</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: cover;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;helvetica neue&#x27;</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">2rem</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.clock</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">30rem</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30rem</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">20px</span> solid white;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">2rem</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">4px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>),</span><br><span class="line">    inset <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3px</span> <span class="number">#EFEFEF</span>,</span><br><span class="line">    inset <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> black,</span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.clock-face</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">3px</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.hand</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">background</span>: black;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform-origin</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">90deg</span>);</span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">0.05s</span>;</span><br><span class="line">    <span class="attribute">transition-timing-function</span>: <span class="built_in">cubic-bezier</span>(<span class="number">0.1</span>, <span class="number">2.7</span>, <span class="number">0.58</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><strong>涉及到的特性：</strong></p><ul><li><code>transform-oragin</code></li></ul><p>调整指针的初始位置以及旋转的轴点:<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin">transform-oragin</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transform</span>-oragin: <span class="number">100%</span>; //初始化使三个指针全部指向<span class="number">12</span>时</span><br></pre></td></tr></table></figure><ul><li><code>transform: rotate()</code></li></ul><p>设置旋转角度</p><ul><li><code>transition</code></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transition</span>: all //<span class="number">0.05s</span>;设置动画时间为<span class="number">0.05</span>秒</span><br></pre></td></tr></table></figure><ul><li><code>transition-timing-function: cubic-bezier(x, x, x, x)</code></li></ul><p>设置 <code>transition-time-function</code> 的值，以实现秒针“滴答滴答”的效果。此外注意 <code>transform</code> 中的 <code>rotate</code> （旋转）属性由角度来控制，可以试着在页面上修改这个参数来查看效果。</p><h2 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> secondHand = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.second-hand&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> minsHand = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.min-hand&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> hourHand = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.hour-hand&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">setDate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> seconds = now.<span class="title function_">getSeconds</span>();</span><br><span class="line">    <span class="keyword">const</span> secondsDegrees = ((seconds / <span class="number">60</span>) * <span class="number">360</span>) + <span class="number">90</span>;</span><br><span class="line">    secondHand.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`rotate(<span class="subst">$&#123;secondsDegrees&#125;</span>deg)`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> mins = now.<span class="title function_">getMinutes</span>();</span><br><span class="line">    <span class="keyword">const</span> minsDegrees = ((mins / <span class="number">60</span>) * <span class="number">360</span>) + ((seconds / <span class="number">60</span>) * <span class="number">6</span>) + <span class="number">90</span>;</span><br><span class="line">    minsHand.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`rotate(<span class="subst">$&#123;minsDegrees&#125;</span>deg)`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> hour = now.<span class="title function_">getHours</span>();</span><br><span class="line">    <span class="keyword">const</span> hourDegrees = ((hour / <span class="number">12</span>) * <span class="number">360</span>) + ((mins / <span class="number">60</span>) * <span class="number">30</span>) + <span class="number">90</span>;</span><br><span class="line">    hourHand.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`rotate(<span class="subst">$&#123;hourDegrees&#125;</span>deg)`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setInterval</span>(setDate, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setDate</span>();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>获取秒针、分钟、小时节点</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> secondHand = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.second-hand&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> minsHand = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.min-hand&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> hourHand = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.hour-hand&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>获取当前时间秒、分、小时</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> seconds = now.<span class="title function_">getSeconds</span>();</span><br><span class="line"><span class="keyword">const</span> mins = now.<span class="title function_">getMinutes</span>();</span><br><span class="line"><span class="keyword">const</span> hour = now.<span class="title function_">getHours</span>();</span><br></pre></td></tr></table></figure><ul><li>计算秒、分、小时角度</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> secondsDegrees = ((seconds / <span class="number">60</span>) * <span class="number">360</span>) + <span class="number">90</span>;</span><br><span class="line"><span class="keyword">const</span> minsDegrees = ((mins / <span class="number">60</span>) * <span class="number">360</span>) + ((seconds / <span class="number">60</span>) * <span class="number">6</span>) + <span class="number">90</span>;</span><br><span class="line"><span class="keyword">const</span> hourDegrees = ((hour / <span class="number">12</span>) * <span class="number">360</span>) + ((mins / <span class="number">60</span>) * <span class="number">30</span>) + <span class="number">90</span>;</span><br></pre></td></tr></table></figure><ul><li>根据角度设置样式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">secondHand.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`rotate(<span class="subst">$&#123;secondsDegrees&#125;</span>deg)`</span>;</span><br><span class="line">minsHand.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`rotate(<span class="subst">$&#123;minsDegrees&#125;</span>deg)`</span>;</span><br><span class="line">hourHand.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`rotate(<span class="subst">$&#123;hourDegrees&#125;</span>deg)`</span>;</span><br></pre></td></tr></table></figure><ul><li>设置定时器，每秒调用一次<code>setDate</code>函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(setDate, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 原生js项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise全面总结</title>
      <link href="/2021/06/30/promise-quan-mian-zong-jie/"/>
      <url>/2021/06/30/promise-quan-mian-zong-jie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Promise是在ES6中新增的一种用于解决异步编程的方案，接下来会从下面几个方面详细介绍Promise</p><p>Prmoise诞生的原因</p><p>Promise的生命周期</p><p>Promse的基本用法</p></blockquote><h2 class="bamboo-h " id="Prmoise诞生的原因">Prmoise诞生的原因</h2><br/><p>Promise诞生以前，在处理一个异步请求时，我们通常是在回调函数中做处理，例如处理一个Ajax请求的代码如下所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;testUrl&#x27;</span>,</span><br><span class="line">  <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 回调函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)    </span><br></pre></td></tr></table></figure><p>假如在一个行为中，需要执行多个异步请求，每一个请求又需要依赖上一个请求的结果，按照回调函数的处理方法，代码如下所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;testUrl&#x27;</span>,</span><br><span class="line">  <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 第二个请求</span></span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;url2&#x27;</span>,</span><br><span class="line">      <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 第三个请求</span></span><br><span class="line">        $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">          <span class="attr">url</span>: <span class="string">&#x27;url2&#x27;</span>,</span><br><span class="line">          <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// 第四个请求</span></span><br><span class="line">            $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">              <span class="attr">url</span>: <span class="string">&#x27;url2&#x27;</span>,</span><br><span class="line">              <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="comment">// 回调</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>事实上，一个行为所产生的异步请求可能比这个还要多，这就会导致代码的嵌套太深，引发“回调地狱”。</p><p>“回调地狱”存在以下几个问题。</p><p>· 代码臃肿，可读性差。</p><p>· 代码耦合度高，可维护性差，难以复用。</p><p>· 回调函数都是匿名函数，不方便调试。</p><p>那么有什么方法能够避免在处理异步请求时，产生“回调地狱”的问题呢？</p><p>Promise就应运而生了，它为异步编程提供了一种更合理、更强大的解决方案。</p><h2 class="bamboo-h " id="Promise的生命周期">Promise的生命周期</h2><br/><p>每一个Promise对象都有3种状态，即pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p><p>Promise在创建时处于pending状态，状态的改变只有两种可能。</p><p>一种是在Promise执行成功时，由pending状态改变为fulfilled状态；</p><p>另一种是在Promise执行失败时，由pending状态改变为rejected状态。</p><blockquote><p><strong>状态一旦改变，就不能再改变</strong>，状态改变一次后得到的就是Promise的终态。</p></blockquote><h2 class="bamboo-h " id="Promise 的基本用法">Promise 的基本用法</h2><br/><p>Promise对象本身是一个构造函数，可以通过new操作符生成Promise的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 异步请求处理</span></span><br><span class="line">  <span class="keyword">if</span> (...) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Promise执行的过程是：在接收的函数中处理异步请求，然后判断异步请求的结果</p><p>如果结果为“true”，则表示异步请求执行成功，调用resolve()函数，resolve()函数一旦执行，Promise的状态就从pending变为fulfilled；</p><p>如果结果为“false”，则表示异步请求执行失败，调用reject()函数，reject()函数一旦执行，Promise的状态就从pending变为rejected。</p><p>resolve()函数和reject()函数可以传递参数，作为后续.then()函数或者.catch()函数执行时的数据源。<br>需要注意的是Promise在创建后会立即调用，然后等待执行resolve()函数或者reject()函数来确定Promise的最终状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise&#x27;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;)</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved&#x27;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在上面的代码中，会先后输出“Promise” “Hello” “resolved”。</p><p>· 首先是Promise的创建，会立即执行，输出“Promise”。</p><p>· 然后是执行resolve()函数，这样的话就会触发then()函数指定回调函数的执行，但是它需要等当前线程中的所有同步代码执行完毕，因此会先执行最后一行同步代码，输出“Hello”。</p><p>· 最后是当所有同步代码执行完毕后，执行then()函数，输出“resolved”。<br>在拥有Promise异步解决方案后，实现原生get类型的Ajax请求的代码如下所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装原生get类型Ajax请求</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ajaxGetPromise</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">    client.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url)</span><br><span class="line">    client.<span class="property">onreadystatechange</span> = handler</span><br><span class="line">    client.<span class="property">responseText</span> = <span class="string">&#x27;json&#x27;</span></span><br><span class="line">    client.<span class="title function_">send</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个Promise的实例创建好后，我们该如何进行成功或者失败的异步处理呢？</p><p><strong>这就需要调用then()函数和catch()函数了。</strong></p><h3 class="bamboo-h warning" id="then()函数">then()函数</h3><br/><p>Promise在原型属性上添加了一个then()函数，表示在Promise实例状态改变时执行的回调函数。</p><p>它接收两个函数作为参数</p><p>第一个参数表示的是Promise在执行成功后（即调用了resolve()函数），所需要执行的回调函数，函数参数就是通过resolve()函数传递的参数。</p><p>第二个参数是可选的，表示的是Promise在执行失败后（即调用了reject()函数或抛出了异常），执行的回调函数。</p><p>以上面封装Ajax请求的函数为例，我们看看then()函数的用法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">ajaxGetPromise</span>(<span class="string">&#x27;/testUrl&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>ajaxGetPromise()函数在执行后会返回一个Promise实例，在执行then()函数时，回调函数中接收一个response参数，值为resolve()函数中传递的this.response，表示Ajax请求的响应。</p><p>then()函数返回的是一个新Promise实例，因此可以使用链式调用then()函数，在上一轮then()函数内部return的值会作为下一轮then()函数接收的参数值。</p><p>基于then()函数的链式调用写法，可以解决本小节开头提到的“回调地狱”问题。从代码风格上看，使用Promise的写法非常优雅。</p><p>需要注意的是，在then()函数中不能返回Promise实例本身，否则会出现Promise循环引用的问题，抛出异常。</p><h3 class="bamboo-h warning" id="catch()函数">catch()函数</h3><br/><p>catch()函数与then()函数是成对存在的，then()函数是Promise执行成功之后的回调，而catch()函数是Promise执行失败之后的回调，它所接收的参数就是执行reject()函数时传递的参数。</p><p>我们可以通过在Promise中手动抛出一个异常，来测试catch()函数的用法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err)) <span class="comment">// Error: test</span></span><br></pre></td></tr></table></figure><p>因为promise实例在创建后会立即执行，所以进入try语句后会抛出一个异常，从而被catch()函数捕获到，在catch()函数中调用reject()函数，并传递Error信息。一旦reject()函数被执行，就会触发promise实例的catch()函数，从而能在catch()函数的回调函数中输出err的信息。</p><p>事实上只要在Promise执行过程中出现了异常，就会被自动抛出，并触发reject(err)，而不用我们去使用try…catch，在catch()函数中手动调用reject()函数。<br>因此前面的代码可以改写成如下所示的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err)) <span class="comment">// Error: test</span></span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，如果一个Promise的状态已经变成fulfilled成功状态，再去抛出异常，是无法触发catch()函数的。这是因为Promise的状态一旦改变，就会永久保持该状态，不会再次改变。</p></blockquote><p><strong>在ES6中不仅为Promise的原型对象添加了then()函数和catch()函数等异步处理函数，还为Promise对象自身添加了一系列的静态函数，用来处理多Promise实例同时运行的情况。接下来我们选择几个重点的静态函数来讲解。</strong></p><h3 class="bamboo-h warning" id="Promise.all()函数">Promise.all()函数</h3><br/><p>then()函数和catch()函数是Promise原型链中的函数，因此每个Promise的实例可以进行共享，而all()函数是Promise本身的静态函数，用于将多个Promise实例包装成一个新的Promise实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>返回的新Promise实例p的状态由3个Promise实例p1、p2、p3共同决定，总共会出现以下两种情况。</p><p>· 只有p1、p2、p3全部的状态都变为fulfilled成功状态，p的状态才会变为fulfilled状态，此时p1、p2、p3的返回值组成一个数组，作为p的then()函数的回调函数的参数。</p><p>· 只要p1、p2、p3中有任意一个状态变为rejected失败状态，p的状态就变为rejected状态，此时第一个被reject的实例的返回值会作为p的catch()函数的回调函数的参数。</p><blockquote><p>需要注意的是，作为参数的Promise实例p1、p2、p3，如果已经定义了catch()函数，那么当其中一个Promise状态变为rejected时，并不会触发Promise.all()函数的catch()函数。</p><p>如果想要Promise.all()函数能触发catch()函数，那么就不要在p1、p2实例中定义catch()函数。</p></blockquote><h3 class="bamboo-h warning" id="Promise.race()函数">Promise.race()函数</h3><br/><p>Promise.all()函数作用于多个Promise实例上，返回一个新的Promise实例，表示的是如果多个Promise实例中有任何一个实例的状态发生改变，那么这个新实例的状态就随之改变，而最先改变的那个Promise实例的返回值将作为新实例的回调函数的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>当p1、p2、p3这3个Promise实例中有任何一个执行成功或者失败时，由Promise.race()函数生成的实例p的状态就与之保持一致，并且最先那个执行完的实例的返回值将会成为p的回调函数的参数。</p><p>使用Promise.race()函数可以实现这样一个场景：假如发送一个Ajax请求，在3秒后还没有收到请求成功的响应时，会自动处理成请求失败。</p><p>实现的思路如下。</p><p>· 将Ajax请求处理成一个Promise，称之为p1。</p><p>· 创建一个自定义的Promise实例，称之为p2，在p2中通过setTimeout()函数控制3秒后抛出一个异常。</p><p>· 将p1和p2两个实例放入Promise.race()函数中，生成一个新的实例p，如果在3秒内接收到Ajax请求的返回值，表示实例p1执行成功，则p通过调用then()函数可以接收到p1的返回值；如果在3秒后还没有接收到Ajax请求的返回值，则会执行p2中的setTimeout()函数，抛出一个异常，表示p2执行失败，则p通过调用catch()函数可以接收到p2的返回值。</p><p>根据以上分析，可以得到以下代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="title function_">ajaxGetPromise</span>(<span class="string">&#x27;./testUrl&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;timeout&#x27;</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2])</span><br></pre></td></tr></table></figure><h3 class="bamboo-h warning" id="Promise.resolve()函数">Promise.resolve()函数</h3><br/><p>Promise提供了一个静态函数resolve()，用于将传入的变量转换为Promise对象，它等价于在Promise函数体内调用resolve()函数。</p><p>Promise.resolve()函数执行后，Promise的状态会立即变为fulfilled，然后进入then()函数中做处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 class="bamboo-h warning" id="Promise.reject()函数">Promise.reject()函数</h3><br/><p>Promise.reject()函数用于返回一个状态为rejected的Promise实例，函数在执行后Promise的状态会立即变为rejected，从而会立即进入catch()函数中做处理，等价于在Promise函数体内调用reject()函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>));</span><br></pre></td></tr></table></figure><p>在Promise. reject (param)函数中传递的参数param，会作为后续catch()函数的回调函数接收的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;fail&#x27;</span>).<span class="title function_">catch</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result));</span><br></pre></td></tr></table></figure><p>执行上面的代码后，会输出字符串“fail”。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 vue 中使用 svg 的方法</title>
      <link href="/2021/06/27/zai-vue-zhong-shi-yong-svg/"/>
      <url>/2021/06/27/zai-vue-zhong-shi-yong-svg/</url>
      
        <content type="html"><![CDATA[<h2 class="bamboo-h " id="使用方式">使用方式</h2><br/><p class='p primary'>全局引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install svg-sprite-loader -S</span><br></pre></td></tr></table></figure><p class='p primary'>配置vue.config.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// vue.config.js</span><br><span class="line">  chainWebpack: (config) =&gt; &#123;</span><br><span class="line">    const svgRule = config.module.rule(&quot;svg&quot;);</span><br><span class="line">    svgRule.uses.clear();</span><br><span class="line">    svgRule</span><br><span class="line">      .use(&quot;svg-sprite-loader&quot;)</span><br><span class="line">      .loader(&quot;svg-sprite-loader&quot;)</span><br><span class="line">      .options(&#123;</span><br><span class="line">        symbolId: &quot;icon-[name]&quot;,</span><br><span class="line">        include: [&quot;./src/icons&quot;]</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p class='p primary'>制作组件SvgIcon</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;svg :class=&quot;svgClass&quot; aria-hidden=&quot;true&quot;&gt;</span><br><span class="line">    &lt;use :xlink:href=&quot;iconName&quot;&gt;&lt;/use&gt;</span><br><span class="line">  &lt;/svg&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; computed, ref &#125; from &quot;@vue/composition-api&quot;;</span><br><span class="line">// 解析svg</span><br><span class="line">const req = require.context(&quot;@/assets/svg&quot;, false, /\.svg$/);</span><br><span class="line">const requireAll = (requireContext) =&gt; &#123;</span><br><span class="line">  return requireContext.keys().map(requireContext);</span><br><span class="line">&#125;;</span><br><span class="line">requireAll(req);</span><br><span class="line"></span><br><span class="line">// require.context(‘./svg’, false, /\.svg$/) 参数说明：</span><br><span class="line">// 第一个：目录</span><br><span class="line">// 第二个：是否遍历子级目录</span><br><span class="line">// 第三个：定义遍历文件规则</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;SvgIcon&quot;,</span><br><span class="line">  props: [&quot;iconClass&quot;, &quot;className&quot;],</span><br><span class="line">  setup(props, &#123; root &#125;) &#123;</span><br><span class="line">    // 计算属性，得出最终结果并返回</span><br><span class="line">    const iconName = computed(() =&gt; `#icon-$&#123;props.iconClass&#125;`);</span><br><span class="line">    const svgClass = computed(() =&gt; &#123;</span><br><span class="line">      if (props.className) return `svg-icon $&#123;props.className&#125;`;</span><br><span class="line">      return &quot;svg-icon&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    return &#123;</span><br><span class="line">      iconName,</span><br><span class="line">      svgClass,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">  .svg-icon &#123;</span><br><span class="line">    width: 1em;</span><br><span class="line">    height: 1em;</span><br><span class="line">    // 添加fill后可修改color</span><br><span class="line">    fill: currentColor;</span><br><span class="line">    color: white;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p class='p primary'>引入组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg-icon :iconClass=&quot;iconClass&quot; :className=&quot;className&quot;/&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端安全：如何防范 XSS 和 CSRF</title>
      <link href="/2021/06/25/qian-duan-an-quan-ru-he-fang-fan-xss-he-csrf/"/>
      <url>/2021/06/25/qian-duan-an-quan-ru-he-fang-fan-xss-he-csrf/</url>
      
        <content type="html"><![CDATA[<h2 class="bamboo-h " id="什么是 XSS 攻击？如何防范 XSS 攻击？">什么是 XSS 攻击？如何防范 XSS 攻击？</h2><br/><p>XSS 攻击指的是跨站脚本攻击，是一种<code>代码注入攻击</code>。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 <code>cookie</code> 等。</p><p>XSS 的本质是因为<code>网站没有对恶意代码进行过滤</code>，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</p><p>而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。</p><p class='p primary'>XSS 一般分为存储型、反射型和 DOM 型。</p><p>存储型指的是恶意代码提交到了网站的数据库中，当用户请求数据的时候，<code>服务器将其拼接为 HTML 后返回给了用户</code>，从而导致了恶意代码的执行。</p><p>反射型指的是攻击者构建了特殊的 URL，当服务器接收到请求后，从 <code>URL 中获取数据，拼接到 HTML 后返回</code>，从而导致了恶意代码的执行。</p><p>DOM 型指的是攻击者构建了特殊的 URL，用户打开网站后，<code>js 脚本从 URL 中获取数据，从而导致了恶意代码的执行</code>。</p><p class='p primary'>XSS 攻击的预防可以从两个方面入手，一个是恶意代码提交的时候，一个是浏览器执行恶意代码的时候。</p><p>对于第一个方面，如果我们对存入数据库的数据都进行的转义处理，但是一个数据可能在多个地方使用，有的地方可能不需要转义，由于我们没有办法判断数据最后的使用场景，<code>所以直接在输入端进行恶意代码的处理，其实是不太可靠的</code>。</p><p>因此我们可以从<code>浏览器的执行来进行预防</code>，一种是使用纯前端的方式，不用服务器端拼接后返回。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，我们对于<code>数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码</code>情况进行判断。</p><p>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等。</p><p>如果用 Vuet 技术栈，并且不使用 <code>v-html</code>功能，就在前端 render 阶段避免 <code>innerHTML</code>、<code>outerHTML</code> 的 XSS 隐患。</p><p>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 内联事件监听器中包含恶意代码 --&gt;</span><br><span class="line">&lt;img onclick=&quot;UNTRUSTED&quot; onerror=&quot;UNTRUSTED&quot; src=&quot;data:image/png,&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 链接内包含恶意代码 --&gt;</span><br><span class="line">&lt;a href=&quot;UNTRUSTED&quot;&gt;1&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// setTimeout()/setInterval() 中调用恶意代码</span><br><span class="line">setTimeout(&quot;UNTRUSTED&quot;)</span><br><span class="line">setInterval(&quot;UNTRUSTED&quot;)</span><br><span class="line"></span><br><span class="line">// location 调用恶意代码</span><br><span class="line">location.href = &#x27;UNTRUSTED&#x27;</span><br><span class="line"></span><br><span class="line">// eval() 中调用恶意代码</span><br><span class="line">eval(&quot;UNTRUSTED&quot;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输入内容长度控制</strong></p><p>对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。</p><p><strong>HTTP-only Cookie</strong></p><p>禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。</p><p><strong>验证码</strong></p><p>防止脚本冒充用户提交危险操作。</p><p><strong>检测</strong></p><p> 只要在网站的各输入框中提交这个字符串，或者把它拼接到 URL 参数上，就可以进行检测了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xxx/search?keyword=jaVasCript%3A%2F*-%2F*%60%2F*%60%2F*%27%2F*%22%2F**%2F(%2F*%20*%2FoNcliCk%3Dalert()%20)%2F%2F%250D%250A%250d%250a%2F%2F%3C%2FstYle%2F%3C%2FtitLe%2F%3C%2FteXtarEa%2F%3C%2FscRipt%2F--!%3E%3CsVg%2F%3CsVg%2FoNloAd%3Dalert()%2F%2F%3E%3E</span><br></pre></td></tr></table></figure><h2 class="bamboo-h " id="什么是 CSRF 攻击？如何防范 CSRF 攻击？">什么是 CSRF 攻击？如何防范 CSRF 攻击？</h2><br/><p>CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被<br>攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。<br>CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</p><p><strong>一个典型的CSRF攻击有着如下的流程：</strong></p><ul><li><p><a href="http://受害者登录a.com/">受害者登录a.com</a>，并保留了登录凭证（Cookie）。</p></li><li><p><a href="http://攻击者引诱受害者访问了b.com/">攻击者引诱受害者访问了b.com</a>。</p></li><li><p><a href="http://b.com/">b.com</a> 向 <a href="http://a.com/">a.com</a> 发送了一个请求：<a href="http://a.com/act=xx%E3%80%82%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E9%BB%98%E8%AE%A4%E6%90%BA%E5%B8%A6a.com%E7%9A%84Cookie%E3%80%82">a.com/act=xx。浏览器会…</a></p></li><li><p>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。</p></li><li><p>a.com以受害者的名义执行了act=xx。</p></li><li><p>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。</p><p><strong>CSRF的特点</strong></p><ul><li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。</li><li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。</li><li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。</li><li>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</li></ul><p>CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。</p></li></ul><p>一般的 CSRF 攻击类型有三种：</p><p class='p primary'>第一种是 GET 类型的 CSRF 攻击</p><p>比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。</p><p class='p primary'>第二种是 POST 类型的 CSRF 攻击</p><p>比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</p><p class='p primary'>第三种是链接类型的 CSRF 攻击</p><p>比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</p><p>CSRF 可以用下面几种方法来防护：</p><p class='p success'>第一种是同源检测的方法</p><p>服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。</p><p class='p success'>第二种方法是使用 CSRF Token 来进行验证</p><p>服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。</p><p class='p success'>第三种方式使用双重 Cookie 验证的办法</p><p>服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</p><p class='p success'>第四种方式是使用在设置 cookie 属性的时候设置 Samesite</p><p> 限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6 的 Reflect</title>
      <link href="/2021/06/24/es6-de-reflect/"/>
      <url>/2021/06/24/es6-de-reflect/</url>
      
        <content type="html"><![CDATA[<h2 class="bamboo-h " id="Reflect概述">Reflect概述</h2><br/><blockquote><p>什么是<code>Reflect</code>对象？</p><p>我们可以这样理解，有一个名为<code>Reflect的全局对象</code>，上面挂载了对象的某些特殊函数(如：<code>[[Get]]</code>、<code>[[Set]]</code>)，这些函数可以通过类似于<code>Reflect.apply()</code>这种形式调用，所有在Reflect对象上的函数要么可以在<code>Object原型链</code>中找到，要么可以通过<code>命令式操作符</code>实现，例如<code>delete</code>和<code>in</code>操作符。</p></blockquote><p><em><strong>既然在ES6以前，Object对象中已经有与Reflect的函数相同功能的函数或者命令式操作符，那么为什么还要在ES6中专门增加一个Reflect对象呢？</strong></em></p><p>主要原因有以下几点。</p><ul><li><p><code>更合理地规划于Object对象相关的API</code><br>在ES6中，Object对象的一些明显属于<strong>语言内部的函数</strong>都会添加到Reflect对象中，这样Object对象与Reflect对象中会存在相同处理函数。<strong>而在未来的设计中，语言内部的函数只会添加到Reflect对象中</strong>。</p></li><li><p><code>全局对象(内置的对象)</code><br>用一个单一的全局对象去存储这些函数，能够保持其他的Javascript代码的整齐、干净。不然的话，这些函数可能是全局的，或者通过原型来调用，<strong>不方便统一管理</strong>。</p></li><li><p><code>代替命令式操作符</code><br>将一些命令式操作符如delete、in等使用函数来代替，这样的目的是为了<strong>代码更好维护，更好向下兼容</strong>，同时避免出现更多的保留字。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">has</span>(<span class="title class_">Object</span>, <span class="string">&#x27;toString&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><code>修改Object对象的某些函数的返回结果</code><br>修改Object对象的某些函数的返回结果，可以让其变得更合理，使得代码更好维护。</li></ul><p>如果一个对象obj是<strong>不能扩展的</strong>，那么在调用ObjectdefineProperty(obj, prop, desc)时，会<strong>抛出一个异常</strong>。因此在传统的写法中，我们需要通过try…catch处理。</p><p>而使用Reflect.defineProperty(obj, prop, desc)时，返回的是<strong>false</strong>，新写法就可以通过if…else实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, prop, desc) </span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// failure</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(obj, prop, desc) ) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Reflect对象的函数与Proxy对象的函数一一对应</code></li></ul><p><strong>只要是Proxy对象的函数，就能在Reflect对象上找到对应的函数</strong>。这就让Proxy对象可以方便的调用对应的Reflect对象上的函数，完成默认行为，并以此为修改行为的基础。</p><p>也就是说，不管Proxy对象怎么修改默认行为，总可以在Refect对象上获取默认行为。事实上<strong>Proxy对象也经常随着Reflect对象一起进行调用</strong>。</p><h2 class="bamboo-h " id="Reflect静态函数">Reflect静态函数</h2><br/><p>**Reflect对象本身并不是一个构造函数(无法通过 new 调用)**，而是直接提供静态函数以供调用，Reflect对象的静态函数一共13个，如下所示。</p><ul><li><p><code>Reflect.get(target, prop, receiver)</code><br>Reflect.get()函数的作用是<strong>获取对象的属性值</strong>，等同于执行target[prop]<br>receiver表示函数中this绑定的对象。</p></li><li><p><code>Reflect.set(target, prop, value, receiver)</code><br>Reflect.set()的作用是<strong>设置某个属性值</strong>。等同于执行target[prop] = value。</p></li><li><p><code>Reflect.apply(target, thisArg, args)</code><br>Reflect.apply()函数的作用是<strong>通过指定的参数列表执行target函数</strong>，等同于执行Function.prototype.apply.call(target, thisArg, args)。其中target表示的是目标对象，thsArg表示的是执行target函数时的this对象，args表示的时参数列表。</p></li><li><p><code>Reflect.has(target, prop)</code><br>Reflect.has()函数的作用是<strong>判断属性是否在对象中</strong>，等同于执行prop in target</p></li></ul><ul><li><p><code>Reflect.deleteProperty(target, prop)</code><br>Reflect.deleteProperty()函数的作用是<strong>删除对象的属性</strong>，等同于执行delete obj[prop]</p></li><li><p><code>Reflect.ownKeys(target)</code><br>Reflect.ownKeys()函数的作用是<strong>获取对象的所有属性</strong>，包括Symbol，等同于Object.getOwnPrototypeNames()与Objct.getOwnPrototypeSymbols()之和。</p></li><li><p><code>Reflect.construct(target, args)</code><br>Reflect.construct()函数的作用是<strong>执行构造函数</strong>，等同于执行new Target(…args)</p></li><li><p><code>Reflect.defineProperty(target, prop, desc)</code><br>Reflect.defineProperty()函数的作用是<strong>为对象定义属性</strong>，等同于执行Object.defineProperty()</p></li></ul><ul><li><p><code>Reflect.getOwnPropertyDescriptor(target, prop)</code><br>Reflect.getOwnPropertyDescriptor()函数的作用是<strong>得到制定属性的描述对象</strong>，等同于执行Object.getOwnPropertyDescriptor()</p></li><li><p><code>Reflect.setPrototypeOf(target, newProto)</code><br>Reflect.setPrototypeOf()函数的作用是<strong>设置对象的原型</strong>，等同于执行Object.setPrototypeOf(target, newProto)</p></li><li><p><code>Reflect.getPrototypeOf(target)</code><br>Reflect.getPrototypeOf()函数的作用是<strong>读取对象的__proto__属性</strong>，等同于执行Object.getPrototypeOf(obj)</p></li></ul><ul><li><p><code>Reflect.isExtensible(target)</code><br>Reflect.isExtensible()函数的作用是<strong>判断对象是否可拓展</strong>，等同于执行Object.isExtensible()</p></li><li><p><code>Reflect.preventExtensions(target)</code><br>Reflect.preventExtensions()函数的作用是<strong>让一个函数变得不可拓展</strong>，等同于执行Object.preventExtensions()</p></li></ul><blockquote><p>Reflect 上存在的一些静态函数对应于ES2015之前的Object上可用的方法。尽管某些方法在行为上看似相似，但它们之间常常存在细微的差异。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/Comparing_Reflect_and_Object_methods">查看具体差异(MDN)</a></p></blockquote><h2 class="bamboo-h " id="Reflect 与 Proxy">Reflect 与 Proxy</h2><br/><p><strong>ES6在设计的时候就将Reflect和Proxy对象绑定在一起了</strong>，Reflect对象的函数与Proxy对象的函数一一对应，因此在Proxy对象中调用Reflect对象对应的函数是一个明智的选择。</p><p>例如我们使用Proxy对象拦截属性的读取、设置和删除操作，并配合Reflect对象实现时，可以编写如下代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xx&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">target = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">`读取属性<span class="subst">$&#123;prop&#125;</span>的值为<span class="subst">$&#123;target[prop]&#125;</span>`</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, prop, value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">`设置属性<span class="subst">$&#123;prop&#125;</span>的值为<span class="subst">$&#123;value&#125;</span>`</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, prop, value)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">`删除属性<span class="subst">$&#123;prop&#125;</span>`</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, prop)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">target.<span class="property">name</span> <span class="comment">// 读取属性name的值为xx</span></span><br><span class="line">target.<span class="property">name</span> = <span class="string">&#x27;yy&#x27;</span> <span class="comment">// 设置属性name的值为yy</span></span><br><span class="line"><span class="keyword">delete</span> target.<span class="property">name</span> <span class="comment">// 删除属性name</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的实例只是讲解了如何配合使用Proxy对象和Reflect对象，那么两者的配合能实现什么样的功能呢？</p></blockquote><p><strong>有一个最经典的案例就是可以实现观察者模式</strong>。</p><h3 class="bamboo-h warning" id="Proxy 和 Reflect 实现观察者模式">Proxy 和 Reflect 实现观察者模式</h3><br/><blockquote><p>观察者模式的表现</p><p>一个目标对象管理所有依赖它的观察者对象</p><p>当自身的状态有改变时，会主动向所有观察者发出通知</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeObservable</span> (target) &#123;</span><br><span class="line">  <span class="comment">// 初始化 handler 存储</span></span><br><span class="line">  target.<span class="property">observers</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将 handler 函数存储到 Set 中，以便于之后调用</span></span><br><span class="line">  target.<span class="property">observe</span> = <span class="function"><span class="params">handler</span> =&gt;</span> target.<span class="property">observers</span>.<span class="title function_">add</span>(handler)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个 proxy 以处理更改</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span> (target, &#123;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, prop, value</span>) &#123;</span><br><span class="line">      <span class="comment">// 将操作转发给对象</span></span><br><span class="line">      <span class="keyword">let</span> success = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">      <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        <span class="comment">// 调用所有 handler</span></span><br><span class="line">        target.<span class="property">observers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">handler</span> =&gt;</span> <span class="title function_">handler</span>(prop, value))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> success</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line">user = <span class="title function_">makeObservable</span>(user)</span><br><span class="line"><span class="comment">// 定义一个观察者</span></span><br><span class="line">user.<span class="title function_">observe</span>(<span class="function">(<span class="params">key, value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`SET <span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">user.<span class="property">name</span> = <span class="string">&quot;xx&quot;</span> <span class="comment">// SET name=xx</span></span><br><span class="line">user.<span class="property">age</span> = <span class="number">24</span> <span class="comment">// SET age=24</span></span><br></pre></td></tr></table></figure><h3 class="bamboo-h warning" id="代理一个 getter">代理一个 getter</h3><br/><p>让我们看一个示例，来说明为什么 <strong>Reflect.get 更好</strong>。此外，<strong>我们还将看到为什么 get/set 有第三个参数 receiver，而且我们之前从来没有使用过它。</strong></p><p>我们有一个带有 _name 属性和 getter 的对象 user。</p><p>这是对 user 对象对一个代理（proxy）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">_name</span>: <span class="string">&quot;xx&quot;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, prop, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target[prop];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userProxy.<span class="property">name</span>) <span class="comment">// xx</span></span><br></pre></td></tr></table></figure><blockquote><p>另一个对象 admin 从 user 继承后，我们可以观察到错误的行为</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">_name</span>: <span class="string">&quot;xx&quot;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, prop, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target[prop]  <span class="comment">// (*) target = user</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = &#123;</span><br><span class="line">  <span class="attr">__proto__</span>: userProxy,</span><br><span class="line">  <span class="attr">_name</span>: <span class="string">&quot;yy&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 期望输出：yy</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(admin.<span class="property">name</span>); <span class="comment">// 输出：xx (!??)</span></span><br></pre></td></tr></table></figure><p><strong>读取 admin.name 应该返回 “yy”，而不是 “xx”！</strong></p><p>发生了什么？或许我们在继承方面做错了什么？</p><p>但是，如果我们移除代理，那么一切都会按预期进行。</p><p>问题实际上出在代理中，<strong>在 (*) 行。</strong></p><p>当我们读取 admin.name 时，由于 admin 对象自身没有对应的的属性，搜索将转到其原型。</p><p>原型是 userProxy。</p><p>从代理读取 name 属性时，get 捕捉器会被触发，并从原始对象返回 target[prop] 属性，在 (*) 行。</p><p>当调用 target[prop] 时，若 prop 是一个 getter，它将在 <strong>this=target 上下文中运行其代码</strong>。因此，结果是来自原始对象 target 的 this._name，即来自 <strong>user</strong>。</p><p>为了解决这种情况，我们需要 get 捕捉器的第三个参数 receiver。它保证将正确的 this 传递给 getter。在我们的例子中是 admin。</p><blockquote><p>如何把上下文传递给 getter？</p><p>对于一个常规函数，我们可以使用 call/apply，但这是一个 <strong>getter</strong>，它不能“被调用”，只能被访问。</p></blockquote><p>Reflect.get 可以做到。如果我们使用它，一切都会正常运行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">_name</span>: <span class="string">&quot;xx&quot;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, prop, receiver</span>) &#123; <span class="comment">// receiver = admin</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop, receiver) <span class="comment">// (*)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = &#123;</span><br><span class="line">  <span class="attr">__proto__</span>: userProxy,</span><br><span class="line">  <span class="attr">_name</span>: <span class="string">&quot;yy&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(admin.<span class="property">name</span>) <span class="comment">// yy</span></span><br></pre></td></tr></table></figure><p>现在 receiver 保留了对正确 this 的引用（即 admin），该引用是在 (*) 行中被通过 Reflect.get 传递给 getter 的。</p><p><strong><em>我们可以把捕捉器重写得更短</em>：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">get</span>(<span class="params">target, prop, receiver</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6 的 Proxy</title>
      <link href="/2021/06/23/es6-de-proxy/"/>
      <url>/2021/06/23/es6-de-proxy/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ES6中新增了Proxy对象，从字面量上看可以理解为代理器，主要用于<strong>改变对象的默认访问行为</strong>，实际表现是在访问对象之间增加了一层<strong>拦截</strong>，任何对对象的访问行为都会通过这层拦截。在拦截中，我们可以<strong>增加自定义的行为</strong>。</p></blockquote><h3 class="bamboo-h warning" id="Proxy的基本语法：">Proxy的基本语法：</h3><br/><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure><p>target —— 是要包装的对象，可以是任何东西，包括函数。</p><p>handler —— 代理配置：带有“捕捉器”（“traps”，即拦截操作的方法）的对象。比如 get 捕捉器用于读取 target 的属性，set 捕捉器用于写入 target 的属性，等等。</p><p><strong>对 proxy 进行操作，如果在 handler 中存在相应的捕捉器，则它将运行</strong>，并且 Proxy 有机会对其进行处理，否则将直接对 target 进行处理。</p><h3 class="bamboo-h warning" id="Proxy实例">Proxy实例</h3><br/><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们用 get 来实现一个对象的默认值。</span></span><br><span class="line"><span class="comment">//我们将创建一个对不存在的数组项返回 0 的数组。</span></span><br><span class="line"><span class="comment">//通常，当人们尝试获取不存在的数组项时，他们会得到 undefined，</span></span><br><span class="line"><span class="comment">//但是我们在这将常规数组包装到代理（proxy）中，以捕获读取操作，并在没有要读取的属性的时返回 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义目标数组</span></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义配置对象</span></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> prop <span class="keyword">in</span> target ? target[prop] : <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成Proxy实例</span></span><br><span class="line"><span class="keyword">let</span> numbersProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(numbers, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbersProxy[<span class="number">1</span>]); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbersProxy[<span class="number">123</span>]); <span class="comment">// 0（没有这个数组项）</span></span><br></pre></td></tr></table></figure><p>上面实例中，我们定义了一个包含get()函数的配置对象，表示的是对代理对象的属性进行读取操作，就会触发get()函数。因此在执行numbersProxy[1]，即访问Proxy实例数组项为1的值，会触发get()函数，在控制台输出自定义的结果。</p><h3 class="bamboo-h warning" id="使用Proxy时的注意事项">使用Proxy时的注意事项</h3><br/><blockquote><p><strong>必须通过代理实例访问</strong></p><p>如果需要配置对象的拦截行为生效，那么必须是对代理实例的属性进行访问，而不是直接对目标对象进行访问。</p></blockquote><h3 class="bamboo-h warning" id="Proxy实例函数及其基本使用">Proxy实例函数及其基本使用</h3><br/><p>在上面例子中，我们通过访问代理对象的属性来触发自定义配置对象的get()函数。而get()函数只是Proxy实例支持的总共13中函数中的一种，这13中函数汇总如下。</p><h4 class="bamboo-h red" id="get(target，property，receiver)">get(target，property，receiver)</h4><br/><p>用于拦截对象的读取属性操作。例如调用proxy.name或者proxy[name]，其中target表示的是目标对象，property表示的是读取的属性值，receiver表示的是配置对象(最初被调用的对象。通常是 proxy 本身)。</p><h4 class="bamboo-h red" id="set(target，property，value，receiver)">set(target，property，value，receiver)</h4><br/><p>拦截对象属性的写入操作，即设置属性值，例如proxy.name = ‘xx’或者proxy[name] = ‘xx’，其中target表示目标对象，property表示的是将要设置的属性，value表示将要设置的属性值，receiver表示的是配置对象。</p><h4 class="bamboo-h red" id="has(target，prop)">has(target，prop)</h4><br/><p>拦截hasProperty的操作，返回一个布尔值，最典型的表现形式是执行prop in target，其中target表示目标对象，prop表示判断的属性值。</p><h4 class="bamboo-h red" id="deleteProperty(target，property)">deleteProperty(target，property)</h4><br/><p>拦截delete proxy[property]的操作，返回一个布尔值，表示是否执行成功，其中target表示目标对象，property表示将要删除的属性。</p><h4 class="bamboo-h red" id="ownkeys(target)">ownkeys(target)</h4><br/><p>拦截Object.getOwnPropertyNames(target)、Object.getOwnPropertySymbols(target)、Object.keys(target)、for…in循环等操作，其中target表示的是获取对象自身所有的属性名。</p><h5 class="bamboo-h " id="拓展 ,">拓展 ,</h5><br/><p>Object.getOwnPropertyNames(obj) 返回非 Symbol 键。</p><p>Object.getOwnPropertySymbols(obj) 返回 Symbol 键。</p><p>Object.keys/values() 返回带有 enumerable 标志的非 Symbol 键/值。</p><p>for..in 循环遍历所有带有 enumerable 标志的非 Symbol 键，以及原型对象的键。</p><h4 class="bamboo-h red" id="getOwnPropertyDecriptor(target，prop)">getOwnPropertyDecriptor(target，prop)</h4><br/><p>拦截Object.getOwnPropertyDecriptor(proxy, prop)操作，返回属性的属性描述符构成的对象，其中target表示目标对象，prop表示需要获取属性描述符集合的属性。</p><h4 class="bamboo-h red" id="defineProperty(target，property，descriptor)">defineProperty(target，property，descriptor)</h4><br/><p>拦截Object.defineProperty(proxy, property, decriptor)、Object.defineProperties(proxy, decriptors)操作，返回一个布尔值，其中target表示目标对象，property表示新增的属性，descriptor表示的是属性描述符对象。</p><h4 class="bamboo-h red" id="preventExtensions(target)">preventExtensions(target)</h4><br/><p>拦截Object.preventExtensions(proxy)操作，返回一个布尔值，表示的是让一个对象变得不可扩展，不能再增加新属性，其中target表示目标对象。</p><h4 class="bamboo-h red" id="isExtensible(target)">isExtensible(target)</h4><br/><p>拦截Object.isExtensible(proxy)，返回一个布尔值，表示对象是否可拓展。其中target表示目标对象。</p><h4 class="bamboo-h red" id="getPrototypeOf(target)">getPrototypeOf(target)</h4><br/><p>拦截Object.getPrototypeOf(proxy)操作，返回一个对象，表示的是拦截获取对象原型属性，其中target表示目标对象。</p><h4 class="bamboo-h red" id="setPropertyOf(target，prototype)">setPropertyOf(target，prototype)</h4><br/><p>拦截Object.setPrototype(proxy, prototype)操作，返回一个布尔值，表示的是拦截设置对象的原型属性的行为，其中target表示目标对象，prototype表示新的原型对象。</p><h4 class="bamboo-h red" id="apply(target，object，args)">apply(target，object，args)</h4><br/><p>拦截Proxy实例作为函数调用的操作，例如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)，其中target表示目标对象，object表示函数的调用方，args表示函数调用传递的参数。</p><h4 class="bamboo-h red" id="constructor(target，args)">constructor(target，args)</h4><br/><p>拦截Proxy实例作为构造函数调用的操作，例如new Proxy(…args)，其中target表示目标对象，args表示函数调用传递的参数。</p><blockquote><p>这些函数都有一个通用的特性，即如果再target中使用了this关键字，再通过Proxy处理后，<strong>this关键之指向的是Proxy实例，而不是目标对象target</strong>。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === proxy)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(person, &#123;&#125;)</span><br><span class="line">person.<span class="title function_">getName</span>() <span class="comment">// fasle</span></span><br><span class="line">proxy.<span class="title function_">getName</span>() <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 class="bamboo-h warning" id="Proxy应用场景">Proxy应用场景</h3><br/><h4 class="bamboo-h red" id="读取不存在属性">读取不存在属性</h4><br/><p>通常，尝试读取不存在的属性会返回 undefined。</p><p>创建一个代理，在尝试读取不存在的属性时，该代理抛出一个错误。</p><p>这可以帮助及早发现编程错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xx&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">wrap</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">        <span class="keyword">return</span> target[prop]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReferenceError</span>(<span class="string">`Property doesn&#x27;t exist: &quot;<span class="subst">$&#123;prop&#125;</span>&quot;`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user = <span class="title function_">wrap</span>(user);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span>); <span class="comment">// xx</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">age</span>); <span class="comment">// ReferenceError: Property doesn&#x27;t exist: &quot;age&quot;</span></span><br></pre></td></tr></table></figure><h4 class="bamboo-h red" id="读取负索引的值">读取负索引的值</h4><br/><p>数组的索引值时从0开始依次递增的，正常情况下我们无法读取负索引的值，但是通过<strong>Proxy的get()函数</strong>可以做到这一点。</p><blockquote><p>负索引实际就是从数组的尾部元素开始，从后往前，寻找元素的位置。</p><p><strong>换句话说，array[-N] 与 array[array.length - N] 相同。</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr = <span class="keyword">new</span> <span class="title class_">Proxy</span>(arr, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[index]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> target[+index + target.<span class="property">length</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">1</span>]) <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">2</span>]) <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[-<span class="number">1</span>]) <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[-<span class="number">2</span>]) <span class="comment">// 4   </span></span><br></pre></td></tr></table></figure><h4 class="bamboo-h red" id="禁止访问私有属性">禁止访问私有属性</h4><br/><p>在一些约定熟成的写法中，私有属性都会以下划线(_)开头，事实上，我们并不希望用户能访问到私有属性。</p><p><strong><em>我们将需要以下捕捉器</em>：</strong></p><p><code>get 读取此类属性时抛出错误</code></p><p><code>set 写入属性时抛出错误</code></p><p><code>deleteProperty 删除属性时抛出错误</code></p><p><code>has 在使用 in 方法时排除以 _ 开头的属性</code></p><p><code>ownKeys 在使用 for..in 和像 Object.keys 这样的的方法时排除以 _ 开头的属性</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xx&quot;</span>,</span><br><span class="line">  <span class="attr">_age</span>: <span class="string">&quot;18&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user = <span class="keyword">new</span> <span class="title class_">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123; <span class="comment">// 拦截属性读取</span></span><br><span class="line">    <span class="keyword">if</span> (prop.<span class="title function_">startsWith</span>(<span class="string">&#x27;_&#x27;</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Access denied&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> target[prop]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, prop, val</span>) &#123; <span class="comment">// 拦截属性写入</span></span><br><span class="line">    <span class="keyword">if</span> (prop.<span class="title function_">startsWith</span>(<span class="string">&#x27;_&#x27;</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Access denied&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      target[prop] = val</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="params">target, prop</span>) &#123; <span class="comment">// 拦截属性删除</span></span><br><span class="line">    <span class="keyword">if</span> (prop.<span class="title function_">startsWith</span>(<span class="string">&#x27;_&#x27;</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Access denied&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">delete</span> target[prop]</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop.<span class="title function_">startsWith</span>(<span class="string">&#x27;_&#x27;</span>)) &#123; <span class="comment">// 拦截 in 操作</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Access denied&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> prop <span class="keyword">in</span> target</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">ownKeys</span>(<span class="params">target</span>) &#123; <span class="comment">// 拦截读取属性列表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(target).<span class="title function_">filter</span>(<span class="function"><span class="params">key</span> =&gt;</span> !key.<span class="title function_">startsWith</span>(<span class="string">&#x27;_&#x27;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;get&quot; 不允许读取 _age</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  user.<span class="property">_age</span> <span class="comment">// Error: Access denied</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">message</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;set&quot; 不允许写入 _age</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  user.<span class="property">_age</span> = <span class="string">&quot;20&quot;</span> <span class="comment">// Error: Access denied</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">message</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;deleteProperty&quot; 不允许删除 _age</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">delete</span> user.<span class="property">_age</span> <span class="comment">// Error: Access denied</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">message</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;has&quot; 将 _age 过滤出去</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="string">&#x27;_age&#x27;</span> <span class="keyword">in</span> user</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>( e.<span class="property">message</span> ) &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// &quot;ownKeys&quot; 将 _age 过滤出去</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> user) <span class="variable language_">console</span>.<span class="title function_">log</span>(key) <span class="comment">// name</span></span><br></pre></td></tr></table></figure><h4 class="bamboo-h red" id="Proxy访问属性的限制">Proxy访问属性的限制</h4><br/><p>当我们期望使用Proxy对对象的属性进行代理，并修改属性的返回值时，我们需要这个属性<strong>不能同时为不可配置和不可写</strong>。如果这个属性同时为不可配置和不可写，那么在通过代理读取属性时，会抛出异常。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="comment">// 可配置的name</span></span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;xx&#x27;</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不可配置的age</span></span><br><span class="line">  <span class="attr">age</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">target = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">name</span>) <span class="comment">// abc</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">age</span>) <span class="comment">// Uncaught TypeError: &#x27;get&#x27; on proxy: property &#x27;age&#x27; is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value (expected &#x27;18&#x27; but got &#x27;abc&#x27;)</span></span><br></pre></td></tr></table></figure><h4 class="bamboo-h red" id="拦截属性赋值操作">拦截属性赋值操作</h4><br/><p>定义一个person对象，包含一个age属性，取值在0~100之间，只要设置的值不在区间内，就会抛出异常。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xx&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user = <span class="keyword">new</span> <span class="title class_">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, prop, number</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;age&#x27;</span> &amp;&amp; number &gt; <span class="number">100</span> || number &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;The age is invalid&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    target[prop] = number</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">user.<span class="property">name</span> = <span class="string">&#x27;yy&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span>) <span class="comment">// yy</span></span><br><span class="line">user.<span class="property">age</span> = <span class="number">20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">age</span>) <span class="comment">// 20</span></span><br><span class="line">user.<span class="property">age</span> = <span class="number">200</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">age</span>) <span class="comment">// Uncaught Error: The age is invalid</span></span><br></pre></td></tr></table></figure><h4 class="bamboo-h red" id="函数的拦截">函数的拦截</h4><br/><p>Proxy中提供了apply()函数，用于拦截函数调用的操作，<strong>函数调用包括直接调用、call()函数调用、apply()函数调用<code>3</code>种方式</strong>。</p><p>通过对函数调用的拦截，可以加入自定义操作，从而得到新的函数处理结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span> (num1, num2) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum = <span class="keyword">new</span> <span class="title class_">Proxy</span>(sum, &#123;</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">target, obj, args</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.<span class="title function_">apply</span>(obj, args) * <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>) ) <span class="comment">// 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( sum.<span class="title function_">call</span>(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>) ) <span class="comment">// 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( sum.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>]) ) <span class="comment">// 6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能优化：防抖和节流</title>
      <link href="/2021/06/20/xing-neng-you-hua-fang-dou-he-jie-liu/"/>
      <url>/2021/06/20/xing-neng-you-hua-fang-dou-he-jie-liu/</url>
      
        <content type="html"><![CDATA[<h2 class="bamboo-h " id="debounce防抖">debounce防抖</h2><br/><p><code>debounce(f, ms)</code>装饰器的结果是一个包装器，该包装器将暂停对 <code>f</code> 的调用，直到经过 <code>ms</code> 毫秒的非活动状态（没有函数调用，“冷却期”），然后使用最新的参数调用 <code>f</code> 一次。</p><blockquote><p>换句话说，<code>debounce</code> 就像一个“接听电话”的秘书，并一直等到 <code>ms</code> 毫秒的安静时间之后，才将最新的呼叫信息传达给“老板”（调用实际的 <code>f</code>）。</p></blockquote><p>举个例子，我们有一个函数 <code>f</code>，并将其替换为 <code>f = debounce(f, 1000)</code>。</p><p>然后，如果包装函数分别在 <code>0ms、200ms 和 500ms</code> 时被调用了，之后没有其他调用，那么实际的 <code>f</code> 只会在 <code>1500ms</code> 时被调用一次。也就是说：从最后一次调用开始经过 <code>1000ms</code> 的冷却期之后。</p><p><img "" class="lazyload placeholder" data-original="/medias/debounce.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="throttle"></p><p>……并且，它将获得最后一个调用的所有参数，其他调用的参数将被忽略。</p><h3 class="bamboo-h warning" id="防抖举例">防抖举例</h3><br/><p>现在我们举一个实际中的例子。假设用户输入了一些内容，我们想要在用户输入完成时向服务器发送一个请求。</p><p>我们没有必要为每一个字符的输入都发送请求。相反，我们想要等一段时间，然后处理整个结果。</p><p>在 <code>Web</code> 浏览器中，我们可以设置一个事件处理程序 —— 一个在每次输入内容发生改动时都会调用的函数。通常，监听所有按键输入的事件的处理程序会被调用的非常频繁。但如果我们为这个处理程序做一个 <code>1000ms</code> 的 <code>debounce</code> 处理，它仅会在最后一次输入后的 <code>1000ms</code> 后被调用一次。</p><p><img "" class="lazyload placeholder" data-original="/medias/debounce.gif" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="debounce"></p><p>看到了吗？第二个输入框调用了防抖函数，所以它的内容是在最后一次输入的 <code>1000ms</code> 后被处理的。</p><p>因此，<code>debounce</code> 是一个处理一系列事件的好方法：无论是系列键盘输入，鼠标移动还是其他类似的事件。</p><p>它在最后一次调用之后等待给定的时间，然后运行其可以处理结果的函数。</p><h3 class="bamboo-h warning" id="实现一个防抖函数">实现一个防抖函数</h3><br/><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">f, ms</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> f.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>), ms);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>调用 debounce 会返回一个包装器。当它被调用时，它会安排一个在给定的 ms 之后对原始函数的调用，并取消之前的此类超时。</p></blockquote><h2 class="bamboo-h " id="throttle节流">throttle节流</h2><br/><p>当被多次调用时，它会在每 <code>ms</code> 毫秒最多将调用传递给 <code>f</code> 一次。</p><p>与防抖抖的不同是，它是个完全不同的装饰器：</p><p><code>debounce</code> 会在“冷却”期后运行函数一次。适用于处理最终结果。<br><code>throttle</code> 运行函数的频率不会大于所给定的时间 <code>ms</code> 毫秒。适用于不应该经常进行的定期更新。</p><blockquote><p>换句话说，throttle 就像接电话的秘书，但是打扰老板（实际调用 <code>f</code>）的频率不能超过每 <code>ms</code> 毫秒一次。</p></blockquote><h3 class="bamboo-h warning" id="节流举例">节流举例</h3><br/><p><img "" class="lazyload placeholder" data-original="/medias/throttle.gif" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="throttle"></p><h3 class="bamboo-h warning" id="实现一个节流函数">实现一个节流函数</h3><br/><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">f, ms = <span class="number">100</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (timer) <span class="keyword">return</span></span><br><span class="line">   timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      f，<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">    &#125;, ms)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 class="bamboo-h " id="总结">总结</h2><br/><p><strong>防抖：用户输入结束或暂停时，才会触发change事件</strong></p><p><strong>节流：无论输入速度多快，每隔一定时间只会触发一次</strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 实现继承的几种方式</title>
      <link href="/2021/06/19/js-shi-xian-ji-cheng-de-ji-chong-fang-shi/"/>
      <url>/2021/06/19/js-shi-xian-ji-cheng-de-ji-chong-fang-shi/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>继承</strong>作为面向对象语言的三大特性之一，可以在不影响父类对象实现的情况下，使得子类对象具有父类对象的特性；同时还能再不影响父类对象行为的情况下扩展子类对象独有的特性，为编码带来了极大的便利。<br>下面我们就来看看 <code>JavaScript</code> 中都有哪些实现继承的方法。</p></blockquote><h2 class="bamboo-h " id="原型链继承">原型链继承</h2><br/><p>原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即<strong>每一个构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针。</strong></p><blockquote><p>原型链继承的主要思想是：<strong>重写子类的prototype属性，将其指向父类的实例</strong>。<br>下面我们结合代码来了解一下。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span> (name) &#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;Animal&#x27;</span></span><br><span class="line">  <span class="comment">// 实例函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sleep</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;正在睡觉&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型函数</span></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span> (<span class="params">food</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>正在吃<span class="subst">$&#123;food&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span> (name) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型继承</span></span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Animal</span>()</span><br><span class="line"><span class="comment">// 将Cat的构造函数指向自身</span></span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Cat</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat.<span class="property">name</span>) <span class="comment">// Tom</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat.<span class="property">type</span>) <span class="comment">// Animal</span></span><br><span class="line">cat.<span class="title function_">sleep</span>() <span class="comment">// Tom正在睡觉</span></span><br><span class="line">cat.<span class="title function_">eat</span>(<span class="string">&#x27;猫罐头&#x27;</span>) <span class="comment">// Tom正在吃猫罐头</span></span><br></pre></td></tr></table></figure><p>在子类<code>Cat</code>中，我们没有增加<code>type</code>属性，因此会直接继承父类<code>Animal</code>的<code>type</code>属性。</p><p>在子类<code>Cat</code>中，我们增加了<code>name</code>属性，在生成子类实例时，<code>name</code>属性会覆盖父类<code>Animal</code>属性值。</p><p>同样因为<code>Cat</code>的<code>prototype</code>属性指向了<code>Animal</code>类型的实例，因此在生成实例<code>Cat</code>时，会继承实例函数和原型函数。</p><blockquote><p>需要注意：</p><p>Cat.prototype.constructor = Cat</p><p>如果不将Cat原型对象的constructor属性指向自身的构造函数，那将指向父类Animal的构造函数。</p></blockquote><h3 class="bamboo-h warning" id="原型链继承的优点">原型链继承的优点</h3><br/><h4 class="bamboo-h red" id="简单，易于实现">简单，易于实现</h4><br/><p>只需要设置子类的<code>prototype</code>属性指向父类的实例即可。</p><h4 class="bamboo-h red" id="可通过子类直接访问父类原型链属性和函数">可通过子类直接访问父类原型链属性和函数</h4><br/><h3 class="bamboo-h warning" id="原型链继承的缺点">原型链继承的缺点</h3><br/><h4 class="bamboo-h red" id="子类的所有实例将共享父类的属性">子类的所有实例将共享父类的属性</h4><br/><p>子类的所有实例将共享父类的属性会带来一个很严重的问题，父类包含<strong>引用值</strong>时，子类的实例改变该引用值会在所有实例中共享。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span> () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">skill</span> = [<span class="string">&#x27;eat&#x27;</span>, <span class="string">&#x27;jump&#x27;</span>, <span class="string">&#x27;sleep&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span> () &#123;&#125;</span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Animal</span>()</span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Cat</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat1 = <span class="keyword">new</span> <span class="title class_">Cat</span>()</span><br><span class="line"><span class="keyword">let</span> cat2 = <span class="keyword">new</span> <span class="title class_">Cat</span>()</span><br><span class="line">cat1.<span class="property">skill</span>.<span class="title function_">push</span>(<span class="string">&#x27;walk&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat1.<span class="property">skill</span>) <span class="comment">// [&quot;eat&quot;, &quot;jump&quot;, &quot;sleep&quot;, &quot;walk&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat2.<span class="property">skill</span>) <span class="comment">// [&quot;eat&quot;, &quot;jump&quot;, &quot;sleep&quot;, &quot;walk&quot;]</span></span><br></pre></td></tr></table></figure><h4 class="bamboo-h red" id="在子类实例化时，无法向父类的构造函数传参">在子类实例化时，无法向父类的构造函数传参</h4><br/><p>在通过<code>new</code>操作符创建子类的实例时，会调用子类的构造函数，而在子类的构造函数中并没有设置与父类关联，从而导致无法向父类的构造函数传递参数。</p><h4 class="bamboo-h red" id="无法实现多继承">无法实现多继承</h4><br/><p>子类的<code>prototype</code>只能设置一个值，设置多个值时，后面的值会覆盖前面的值。</p><h2 class="bamboo-h " id="构造函数继承（借助 call）">构造函数继承（借助 call）</h2><br/><blockquote><p>构造函数继承的主要思想：<strong>在子类的构造函数中通过call()函数改变thi的指向，调用父类的构造函数，从而将父类的实例的属性和函数绑定到子类的this上。</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span> (age) &#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Animal&#x27;</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="comment">// 实例函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sleep</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;正在睡觉&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型函数</span></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span> (<span class="params">food</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>正在吃<span class="subst">$&#123;food&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span> (name) &#123;</span><br><span class="line">  <span class="comment">// 核心，通过call()函数实现Animal的实例的属性和函数的继承</span></span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line">cat.<span class="title function_">sleep</span>() <span class="comment">// Tom正在睡觉</span></span><br><span class="line">cat.<span class="title function_">eat</span>() <span class="comment">// Uncaught TypeError: cat.eat is not a function</span></span><br></pre></td></tr></table></figure><p>通过代码可以发现，子类可以正常调用父类的实例函数，而无法调用父类原型上的函数，<strong>这是因为子类并没有通过某种方式来调用父类原型对象上的函数</strong>。</p><h3 class="bamboo-h warning" id="构造继承的优点">构造继承的优点</h3><br/><h4 class="bamboo-h red" id="解决了子类实例共享父类属性的问题">解决了子类实例共享父类属性的问题</h4><br/><p><code>call()</code>函数实际时改变父类<code>Animal</code>构造函数中<code>this</code>的指向，然后调用<code>this</code>指向了子类<code>Cat</code>，相当于将父类的属性和函数直接绑定到了子类的<code>this</code>中，成了子类实例的熟属性和函数，因此生成的子类实例中是各自拥有自己的属性和函数，不会相互影响。</p><h4 class="bamboo-h red" id="创建子类的实例时，可以向父类传参">创建子类的实例时，可以向父类传参</h4><br/><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span> (age) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Animal&#x27;</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span> (name, parentAge) &#123;</span><br><span class="line">  <span class="comment">// 在子类生成实例时，传递参数给call()函数，间接地传递给父类，然后被子类继承</span></span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, parentAge)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">10</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat.<span class="property">age</span>)</span><br></pre></td></tr></table></figure><h4 class="bamboo-h red" id="可以实现多继承">可以实现多继承</h4><br/><p>在子类的构造函数中，可以多次调用<code>call()</code>函数来继承多个父对象。</p><h3 class="bamboo-h warning" id="构造函数的缺点">构造函数的缺点</h3><br/><h4 class="bamboo-h red" id="实例只是子类的实例，并不是父类的实例">实例只是子类的实例，并不是父类的实例</h4><br/><p>因为我们并未通过原型对象将子类与父类进行串联，所以生成的实例与父类并没有关系。</p><h4 class="bamboo-h red" id="只能继承父类实例的属性和函数，并不能继承原型对象上的属性和函数">只能继承父类实例的属性和函数，并不能继承原型对象上的属性和函数</h4><br/><p>与上面原因相同。</p><h4 class="bamboo-h red" id="无法复用父类的构造函数">无法复用父类的构造函数</h4><br/><p>因为父类的实例函数将通过<code>call()</code>函数绑定到子类的<code>this</code>中，因此子类生成的每个实例都会拥有父类实例的引用，这会造成不必要的内存消耗，影响性能。</p><h2 class="bamboo-h " id="组合继承">组合继承</h2><br/><blockquote><p>组合继承的主要思想：<strong>结合构造继承和原型继承的两种方式，一方面在子类的构造函数中通过call()函数调用父类的构造函数，将父类的实例的属性和函数绑定到子类的this中；另一方面，通过改变子类的prototype属性，继承父类的原型对象上的属性和函数。</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span> (age) &#123;</span><br><span class="line">  <span class="comment">// 实例属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Animal&#x27;</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">skill</span> = [<span class="string">&#x27;eat&#x27;</span>, <span class="string">&#x27;jump&#x27;</span>, <span class="string">&#x27;sleep&#x27;</span>]</span><br><span class="line">  <span class="comment">// 实例函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sleep</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;正在睡觉&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型函数</span></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span> (<span class="params">food</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>正在吃<span class="subst">$&#123;food&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span> (name) &#123;</span><br><span class="line">  <span class="comment">// 通过构造函数继承实例的属性和函数</span></span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过原型继承原型对象上的属性和函数</span></span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Animal</span>()</span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Cat</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat.<span class="property">name</span>) <span class="comment">// Tom</span></span><br><span class="line">cat.<span class="title function_">sleep</span>() <span class="comment">// Tom正在睡觉</span></span><br><span class="line">cat.<span class="title function_">eat</span>(<span class="string">&#x27;猫罐头&#x27;</span>) <span class="comment">// Tom正在吃猫罐头</span></span><br></pre></td></tr></table></figure><h3 class="bamboo-h warning" id="组合继承的优点">组合继承的优点</h3><br/><h4 class="bamboo-h red" id="既能继承父类实例的属性和函数，又能继承原型对象上的属性和函数">既能继承父类实例的属性和函数，又能继承原型对象上的属性和函数</h4><br/><h4 class="bamboo-h red" id="既是子类的实例，又是父类的实例">既是子类的实例，又是父类的实例</h4><br/><h4 class="bamboo-h red" id="不存在引用属性共享的问题">不存在引用属性共享的问题</h4><br/><p>构造函数作用域优先级比原型链优先级高，所以不会出现引用属性共享的问题。</p><h4 class="bamboo-h red" id="可以向父类的构造函数中传参">可以向父类的构造函数中传参</h4><br/><h3 class="bamboo-h warning" id="组合继承的缺点">组合继承的缺点</h3><br/><h4 class="bamboo-h red" id="父类的实例属性会被绑定两次">父类的实例属性会被绑定两次</h4><br/><p>在子类的构造函数中，通过<code>call()</code>函数调用了一次父类的构造函数；在改写子类的<code>prototype</code>属性，生成的实例时又调用了一次父类的构造函数。</p><h2 class="bamboo-h " id="寄生组合继承">寄生组合继承</h2><br/><p>组合继承方案已经足够好，但是针对其存在的缺点，我们仍然可以进行优化。</p><p><strong>在进行子类的<code>prototype</code>属性的设置时，可以去掉父类实例的属性的函数</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span> (age) &#123;</span><br><span class="line">  <span class="comment">// 实例属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Animal&#x27;</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">skill</span> = [<span class="string">&#x27;eat&#x27;</span>, <span class="string">&#x27;jump&#x27;</span>, <span class="string">&#x27;sleep&#x27;</span>]</span><br><span class="line">  <span class="comment">// 实例函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sleep</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;正在睡觉&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型函数</span></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span> (<span class="params">food</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>正在吃<span class="subst">$&#123;food&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span> (name) &#123;</span><br><span class="line">  <span class="comment">// 继承父类的实例和属性</span></span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承父类原型上的实例和属性</span></span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Cat</span></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat.<span class="property">name</span>) <span class="comment">// Tom</span></span><br><span class="line">cat.<span class="title function_">sleep</span>() <span class="comment">// Tom正在睡觉</span></span><br><span class="line">cat.<span class="title function_">eat</span>(<span class="string">&#x27;猫罐头&#x27;</span>) <span class="comment">// Tom正在吃猫罐头</span></span><br></pre></td></tr></table></figure><blockquote><p>其中最关键的语句：</p><p>Cat.prototype = Object.create(Animal.prototype)</p><p>只取父类Animal的prototype属性，过滤掉Animal的实例属性，从而避免了父类的实例属性绑定两次。</p></blockquote><p>这种寄生组合式继承方式，基本可以解决前几种继承方式的缺点，较好地实现了继承想要的结果，同时也减少了构造次数，减少了性能的开销。</p><p><strong>整体看下来，这六种继承方式中，寄生组合式继承是这里面最优的继承方式。</strong></p><h2 class="bamboo-h " id="总结">总结</h2><br/><p><img "" class="lazyload placeholder" data-original="/medias/extends.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="继承"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2的基本使用方法</title>
      <link href="/2021/06/18/vue2-de-ji-ben-shi-yong-fang-fa/"/>
      <url>/2021/06/18/vue2-de-ji-ben-shi-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>vue-style-loader 可以热更新</p><p>scoped的实现是借助了PostCSS实现的，一旦增加了scoped，他会将之前覆盖的样式转换成下面的样式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">.content[data-v-67e6b31f] &#123;</span><br><span class="line">  .title-wrap[data-v-67e6b31f] &#123;</span><br><span class="line">    font-size: 20px;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>如果你希望scoped中的某个样式能够作用的更深，影响到子组件，你可以使用<code>&gt;&gt;&gt;</code>操作符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cssModules: &#123;</span><br><span class="line"> localIdentName: isDev ? &#x27;[path]-[name]-[hash:base64:5]&#x27; : &#x27;[hash:base64:5]&#x27;,</span><br><span class="line">&#125;, // 在vue-loader-config中配置modules</span><br></pre></td></tr></table></figure><h5 id="设置指定的Vue版本"><a href="#设置指定的Vue版本" class="headerlink" title="设置指定的Vue版本"></a>设置指定的Vue版本</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">devServer,</span><br><span class="line">// import Vue from &#x27;vue&#x27; 默认是vue.runtime.commonjs</span><br><span class="line">// 开发环境 vue.runtime.esm.js</span><br><span class="line">// 正式环境 vue.runtime.min.js</span><br><span class="line">// runtime 区别：简单来说，vue.js 是完整版的 Vue，拥有全部的组件（如 compiler）,而非完整版则没有。但也正因为没有 compiler，非完整版是不能使用 template ，需要使用 h 函数来渲染页面，开发体验特别糟糕。使用该版本，可直接将内容写在HTML中查看视图效果，或用template 渲染到 HTML，用webpack引入，需要配置alias，@vue/cli 引入也需要额外配置。</span><br><span class="line">resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">        &#x27;vue&#x27;: path.join(__dirname, &#x27;../node_modules/vue/dist/vue.esm.js&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new HTMLPlugin(&#123;</span><br><span class="line">  template: path.join(__dirname, &#x27;./template.html&#x27;) // 本地模板文件的位置</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Vue-的实例"><a href="#Vue-的实例" class="headerlink" title="Vue 的实例"></a>Vue 的实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const app = new Vue(&#123;</span><br><span class="line">  el: &#x27;#root&#x27;, // app.$mount(&#x27;#root&#x27;) 等价</span><br><span class="line">  template: &#x27;&lt;div&gt;this is content&lt;/div&gt;&#x27;</span><br><span class="line">&#125;) // 挂载节点，整体替换掉</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">console.log(app.$data); // data里的数据</span><br><span class="line">console.log(app.$props); // 传入的属性，外部属性</span><br><span class="line">console.log(app.$el); // 挂载的html节点的引用</span><br><span class="line">console.log(app.$options); // 传递的和Vue实例的初始化相关 使用 vm.$options 可以获取 实例上自定义的  属性</span><br><span class="line">app.$options.data.text = 2  // 修改值失败 传入的options的data是通过vue在init时做过修改，并不是直接引入options.data </span><br><span class="line">子组件的$options.data().xx是数据初始化信息</span><br><span class="line">app.text 和 app.$data.text 是同一个属性</span><br><span class="line">app.$options.render = (h) =&gt; &#123;</span><br><span class="line">  return h(&#x27;div&#x27;, &#123;&#125;, &#x27;new render function&#x27;)</span><br><span class="line">&#125; // 页面不变化，有值下一次渲染时生效</span><br><span class="line">app.$root === app</span><br><span class="line">app.$children &lt;item&gt;&lt;div&gt;&lt;/div&gt;&lt;item&gt;  // div作为children传入到item 组件相关</span><br><span class="line">app.$slots</span><br><span class="line">app.$scopeSlots // template 中书写</span><br><span class="line">app.$refs // 模板的引用 &lt;div ref=&quot;div&quot;&gt;&lt;/div&gt; html节点返还html节点对象，是组件，返回组件实例</span><br><span class="line">app.$isServer SSR用到 </span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">app.$watch(&#x27;text&#x27;, (newText, oldText) =&gt; &#123;</span><br><span class="line">this.$data.text + 5 // 报错</span><br><span class="line">  console.log(`$&#123;newText&#125; : $&#123;oldText&#125;`);</span><br><span class="line">&#125;)</span><br><span class="line">等价于</span><br><span class="line">  watch: &#123;</span><br><span class="line">    text: function(newText, oldText)&#123;</span><br><span class="line">      console.log(`$&#123;newText&#125; : $&#123;oldText&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  注意，不应该使用箭头函数来定义 watcher 函数 (例如 searchQuery: newValue =&gt; this.updateAutocomplete(newValue))。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.updateAutocomplete 将是 undefined。</span><br><span class="line">  选项：deep：为了发现对象内部值的变化，可以在选项参数中指定 deep: true。注意监听数组的变更不需要这么做。</span><br><span class="line">  </span><br><span class="line">  通过$watch 需要自己注销 监听</span><br><span class="line">  为什么要注销 watch？因为我们的组件是经常要被销毁的，比如我们跳一个路由，从一个页面跳到另外一个页面，那么原来的页面的 watch 其实就没用了，这时候我们应该注销掉原来页面的 watch 的，不然的话可能会导致内置溢出。</span><br><span class="line">  const unWatch = app.$watch(&#x27;text&#x27;, function(newText, oldText) &#123;</span><br><span class="line">  this.$data.text + 5</span><br><span class="line">  console.log(`$&#123;newText&#125; : $&#123;oldText&#125;`);</span><br><span class="line">&#125;)</span><br><span class="line">unWatch() // app.$watch会返回一个注销方法 </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">自定义事件监听和触发</span><br><span class="line">app.$on(&#x27;test&#x27;, () =&gt; console.log(&#x27;change&#x27;))</span><br><span class="line">app.$emit(&#x27;test&#x27;) // 不会冒泡 作用在同一个对象</span><br><span class="line"></span><br><span class="line">app.$on(&#x27;test&#x27;, (a ,b) =&gt; console.log(&#x27;change&#x27;+ ` $&#123;a&#125; $&#123;b&#125;`))</span><br><span class="line">app.$emit(&#x27;test&#x27;, 1, 2) // 传值和接收</span><br><span class="line"></span><br><span class="line">app.$once 只监听一次</span><br><span class="line">app.$off 注销事件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.$forceUpdate() // 迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件 Vue是声明式渲染 在data中声明才触发响应式</span><br><span class="line">app.$set(app.obj, &#x27;a&#x27;, i)</span><br><span class="line">app.$delete()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">app.$nextTick([callback]) // Vue 渲染是异步的  </span><br><span class="line">methods: &#123;</span><br><span class="line">  updateMessage: async function () &#123;</span><br><span class="line">    this.message = &#x27;已更新&#x27;</span><br><span class="line">    console.log(this.$el.textContent) // =&gt; &#x27;未更新&#x27;</span><br><span class="line">    await this.$nextTick()</span><br><span class="line">    console.log(this.$el.textContent) // =&gt; &#x27;已更新&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateMessage: function () &#123;</span><br><span class="line">      this.message = &#x27;已更新&#x27;</span><br><span class="line">      console.log(this.$el.textContent) // =&gt; &#x27;未更新&#x27;</span><br><span class="line">      this.$nextTick(function () &#123;</span><br><span class="line">        console.log(this.$el.textContent) // =&gt; &#x27;已更新&#x27;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue 生命周期"></a>Vue 生命周期</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate () &#123;</span><br><span class="line">    console.log(this, &#x27;beforeCreate&#x27;);</span><br><span class="line">    // 初始化时执行</span><br><span class="line">&#125;,</span><br><span class="line">created () &#123;</span><br><span class="line">    console.log(this, &#x27;created&#x27;);</span><br><span class="line">    // 完成响应式</span><br><span class="line">&#125;,</span><br><span class="line">beforeMount () &#123;</span><br><span class="line">    console.log(this, &#x27;beforeMount&#x27;);</span><br><span class="line">    // 不挂载到el上 不执行</span><br><span class="line">&#125;,</span><br><span class="line">mounted () &#123;</span><br><span class="line">    console.log(this, &#x27;mounted&#x27;);</span><br><span class="line">    // 和DOM有关的放在这里</span><br><span class="line">    // 数据有关放在 created 和 mounted 都可以</span><br><span class="line">    // 服务端渲染不调用</span><br><span class="line">&#125;,</span><br><span class="line">activated () &#123;</span><br><span class="line">    console.log(this, &#x27;activated&#x27;);</span><br><span class="line">    // keep-alive 相关</span><br><span class="line">&#125;,</span><br><span class="line">deactivated () &#123;</span><br><span class="line">    console.log(this, &#x27;deactivated&#x27;);</span><br><span class="line">&#125;,</span><br><span class="line">beforeUpdate () &#123;</span><br><span class="line">    console.log(this, &#x27;beforeUpdate&#x27;);</span><br><span class="line">&#125;,</span><br><span class="line">updated () &#123;</span><br><span class="line">    console.log(this, &#x27;updated&#x27;);</span><br><span class="line">    // 数据更新执行</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy () &#123;</span><br><span class="line">    console.log(this, &#x27;beforeDestroy&#x27;);</span><br><span class="line">&#125;,</span><br><span class="line">destroyed () &#123;</span><br><span class="line">    console.log(this, &#x27;destroyed&#x27;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">beforeMount () &#123;</span><br><span class="line">    console.log(this.$el, &#x27;beforeMount&#x27;);</span><br><span class="line">    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">    // 不挂载到el上 不执行</span><br><span class="line">&#125;,</span><br><span class="line">mounted () &#123;</span><br><span class="line">    console.log(this.$el, &#x27;mounted&#x27;);</span><br><span class="line">    // &lt;div&gt;1&lt;div&gt;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">render (h) &#123;</span><br><span class="line">    return h(&#x27;div&#x27;, &#123;&#125;, this.text)</span><br><span class="line">&#125;,等价于</span><br><span class="line"> template: &#x27;&lt;div&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;&#x27;</span><br><span class="line"> // 再beforeMount 和 mounted 之间执行</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">renderError(h, err ) &#123;</span><br><span class="line">    return h(&quot;div&quot;, &#123;&#125;, err.stack)</span><br><span class="line">&#125;, // 开发环境使用，只会作用于该组件，作用不到子组件 </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">errorCaptured() &#123;</span><br><span class="line">       </span><br><span class="line">   &#125;, // 线上使用，可以作用到子组件，除非子组件禁止冒泡</span><br></pre></td></tr></table></figure><h2 id="Data-binding"><a href="#Data-binding" class="headerlink" title="Data-binding"></a>Data-binding</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var data = &#x27;xxx&#x27; // template 无法访问</span><br><span class="line"></span><br><span class="line">template: `</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;&#123;isActive ? &quot;W&quot; : &quot;Q&quot;&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">` // 可以做简单逻辑运算 arr.push() Date.now() 三元运算 自己定义在外层的变量不能访问</span><br></pre></td></tr></table></figure><h2 id="Computed-And-Watch"><a href="#Computed-And-Watch" class="headerlink" title="Computed And Watch"></a>Computed And Watch</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">const app = new Vue(&#123;</span><br><span class="line">    el: &quot;#root&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        firstName: &quot;Wang&quot;,</span><br><span class="line">        lastName: &quot;Qun&quot;,</span><br><span class="line">        number: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    template: `</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;&#123;getFullName()&#125;&#125;</span><br><span class="line">        &lt;/br&gt;</span><br><span class="line">        &#123;&#123;fullName&#125;&#125;</span><br><span class="line">        &lt;/br&gt;</span><br><span class="line">        &#123;&#123;number&#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    `,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        fullName() &#123;</span><br><span class="line">            console.log(&quot;computed&quot;);</span><br><span class="line">            return this.firstName + &#x27; &#x27; + this.lastName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        getFullName() &#123;</span><br><span class="line">            console.log(&quot;methods&quot;);</span><br><span class="line">            return this.firstName + &#x27; &#x27; + this.lastName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setInterval(() =&gt; &#123;</span><br><span class="line">    app.number++</span><br><span class="line">&#125;, 5000) // 页面数据改变，重新渲染，执行getFullName(),而computed依赖的数据不变，不重新计算</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">       fullName: &#123;</span><br><span class="line">           get() &#123;</span><br><span class="line">               console.log(&quot;computed&quot;);</span><br><span class="line">               return this.firstName + &#x27; &#x27; + this.lastName</span><br><span class="line">           &#125;,</span><br><span class="line">           set (fullName) &#123;</span><br><span class="line">               const names = fullName.split(&#x27; &#x27;);</span><br><span class="line">               this.firstName = names[0]</span><br><span class="line">               this.lastName = names[1]</span><br><span class="line">           &#125;</span><br><span class="line">// cpmputed 可以设置值，但不推荐这样做，组合容易，拆分难，容易出错，重复计算</span><br><span class="line">       </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;fullName_watch&#125;&#125;</span><br><span class="line"></span><br><span class="line">watch: &#123;</span><br><span class="line">     firstName: &#123;</span><br><span class="line">         firstName (newVal, oldVal) &#123;</span><br><span class="line">             this.fullName_watch = newVal + &#x27;&#x27; + this.lastName</span><br><span class="line">         &#125; // watch最初绑定的时候不会执行。可以通过添加handler方法</span><br><span class="line">         // 声明时不执行，有变化时执行</span><br><span class="line">     &#125;,</span><br><span class="line"> &#125;,</span><br><span class="line"> </span><br><span class="line">     watch: &#123; // 不设置deep时浅监听，只监听一层 性能好</span><br><span class="line">     firstName: &#123;</span><br><span class="line">         handler(newVal, oldVal) &#123;</span><br><span class="line">             this.fullName_watch = newVal + &#x27;&#x27; + this.lastName</span><br><span class="line">         &#125;,</span><br><span class="line">         immediate: true // 立即先执行一次handler</span><br><span class="line">         deep: true // 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;, // 监听变化，给后台发请求computed做不到，只能watch去做 监听到某一个数据变化，去做指定的操作</span><br><span class="line"> 如想提升性能，可以用字符串包裹想要监听的属性</span><br><span class="line">         &#x27;obj.a&#x27;: &#123;</span><br><span class="line">         handler () &#123;</span><br><span class="line">             console.log(&quot;obj.a changed&quot;);</span><br><span class="line">         &#125;,</span><br><span class="line">         // deep: true</span><br><span class="line"></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>methods 和 computed 的区别</p><p>定义在methods中的函数：1.函数内依赖了data中属性，2.这些属性发生了改变。</p><p>methods函数主动调用时，像普通函数一样执行</p><p>定义在computed的函数：1.函数内依赖了vue的属性，2.这些属性发生了改变，3.这些属性被页面引用。</p><p>computed的函数主动调用时，其是否会执行和内部的依赖属性是否发生改变有关。</p><p>**不建议在computed和watch中修改任何值，可能会导致无限循环触发  ** </p><h2 id="Vue的原生指令"><a href="#Vue的原生指令" class="headerlink" title="Vue的原生指令"></a>Vue的原生指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">v-text</span><br><span class="line">&lt;div v-text=&quot;text&quot;&gt;&lt;/text&gt; // 等价 </span><br><span class="line">&lt;div v-text=&quot; &#x27;Text:&#x27; + text&quot;&gt;&lt;/text&gt; // 标签内放入其他内容需要写成</span><br><span class="line">&lt;div&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt; // 等价</span><br><span class="line"></span><br><span class="line">v-html 可以写html代码片段</span><br><span class="line">&lt;div v-html=&quot;html&quot;&gt;&lt;/div&gt; // html: &#x27;&lt;h2&gt;text&lt;/h3&gt;&#x27;</span><br><span class="line"></span><br><span class="line">v-show 通过控制display:none的切换显示隐藏</span><br><span class="line"></span><br><span class="line">v-if 通过渲染生成新的DOM节点显示隐藏 搭配 v-else-if v-else</span><br><span class="line"></span><br><span class="line">v-on = @ v-bind = :</span><br><span class="line"></span><br><span class="line">v-model </span><br><span class="line">用于输入组件 &lt;input v-model=&quot;text&quot;&gt;&lt;/input&gt;</span><br><span class="line">可以给自定义组件使用v-model</span><br><span class="line"></span><br><span class="line">&lt;input type=&quot;checkbox&quot; v-model=&quot;active&quot;&gt;&lt;/input&gt; // active: false</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;input type=&quot;checkbox&quot; :value=&quot;1&quot; v-model=&quot;arr&quot;&gt;&lt;/input&gt; // 如使用value=&quot;1&quot; ‘1’是字符串 :value=&quot;1&quot; 是数字</span><br><span class="line">  &lt;input type=&quot;checkbox&quot; :value=&quot;1&quot; v-model=&quot;arr&quot;&gt;&lt;/input&gt;</span><br><span class="line">  &lt;input type=&quot;checkbox&quot; :value=&quot;1&quot; v-model=&quot;arr&quot;&gt;&lt;/input&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  </span><br><span class="line"> &lt;input type=&quot;radio&quot; value=&quot;one&quot; v-model=&quot;picked&quot;&gt;&lt;/input&gt;</span><br><span class="line"> &lt;input type=&quot;radio&quot; value=&quot;two&quot; v-model=&quot;picked&quot;&gt;&lt;/input&gt; // 单选框</span><br><span class="line"> </span><br><span class="line"> 修饰符</span><br><span class="line"> .number 转换成数字</span><br><span class="line"> .trim 删除首位空格</span><br><span class="line"> .lazy 失去焦点修改数据</span><br><span class="line"> </span><br><span class="line"> v-pre 不编译内容</span><br><span class="line"> v-cloak 在vue代码没加载前，v-cloak相当于加一个样式 display:none 代码加载完显示</span><br><span class="line"> v-once 只修改一次 适用于静态内容 不做虚拟 DOM 对比，节约性能</span><br></pre></td></tr></table></figure><h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><p>定义组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">全局注册</span><br><span class="line">const component = &#123;</span><br><span class="line">  template: `</span><br><span class="line">  &lt;div&gt;this is component&lt;/div&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;</span><br><span class="line">Vue.component(&#x27;CompOne&#x27;, component) // 最好使用大写开头 Vue的组件可以看作是一个类 </span><br><span class="line">new Vue (&#123;</span><br><span class="line">  el: &quot;#root&quot;,</span><br><span class="line">  template: `&lt;comp-one&gt;&lt;/comp-one&gt;` // 使用连接符</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">局部注册</span><br><span class="line">new Vue (&#123;</span><br><span class="line">  el: &quot;#root&quot;,</span><br><span class="line">  template: `&lt;comp&gt;&lt;/comp&gt;`,</span><br><span class="line">  components: &#123;</span><br><span class="line">    CompOne: component</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">使用data定义组件内数据时，如果不是通过new Vue注册的，而是通过全局注册到某个Vue实例中使用时，要使用data function</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      text: &#x27;123&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, // 保证每一个组件的data都是一个新对象，防止变量污染其他组件 不能使用全局对象</span><br><span class="line"></span><br><span class="line">写法：</span><br><span class="line">const data = &#123;text: &#x27;123&#x27;&#125;</span><br><span class="line">const component = &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return data</span><br><span class="line">  &#125;,</span><br><span class="line">  template: `</span><br><span class="line">  &lt;input v-model=&quot;text&quot;&gt;&lt;/input&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;</span><br><span class="line">new Vue (&#123;</span><br><span class="line">  el: &quot;#root&quot;,</span><br><span class="line">  template: `</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;comp-one/&gt;</span><br><span class="line">    &lt;comp-one/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  `,</span><br><span class="line">  components: &#123;</span><br><span class="line">    CompOne: component</span><br><span class="line">  &#125;</span><br><span class="line">&#125;) // 输出时，保持对一个 data 的引用，改变一个，另外一个也随着改变</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">props</span><br><span class="line">定义组件被外部组件使用时，可变的行为。组织组件可配置的行为。从父组件接收属性。</span><br></pre></td></tr></table></figure><p><strong>数据不使用：绑定，以字符串的形式输出</strong>  <strong>绑定会解析传入的字符串</strong></p><p>单项数据流 子组件不能修改父组件传来的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">修改传来属性的方法</span><br><span class="line">&lt;span @click=&quot;handleChange&quot;&gt;&#123;&#123;propsOne&#125;&#125;&lt;/span&gt;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleChange() &#123;</span><br><span class="line">      this.$emit(&#x27;change&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, // 子组件$emit 通过Vue实例的$emit comp-one 是一个Vue的实例</span><br><span class="line">  </span><br><span class="line">&lt;comp-one :active=&quot;true&quot; :props-one=&quot;propsOne&quot; @change=&quot;handleChange&quot;/&gt;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleChange() &#123;</span><br><span class="line">      this.propsOne += 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; // 父组件$on  @change = this.$on(&#x27;change&#x27;)</span><br><span class="line">  </span><br><span class="line">  &lt;comp-one :active=&quot;true&quot; </span><br><span class="line">  :props-one=&quot;propsOne&quot;</span><br><span class="line">            ref=&quot;comp1&quot; </span><br><span class="line">            @change=&quot;handleChange&quot;/&gt;</span><br><span class="line">  // comp-one 是一个Vue的实例 有refs属性 效果与new Vue一样</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">props的数据验证</span><br><span class="line">    active: &#123;</span><br><span class="line">      type: Boolean,</span><br><span class="line">      required: true,</span><br><span class="line">      default: false // 如果props接收一个对象 需要声明一个方法，在里面return 道理同data()</span><br><span class="line">       validator: function (value) &#123;</span><br><span class="line">        // 这个值必须匹配下列字符串中的一个</span><br><span class="line">        return [&#x27;success&#x27;, &#x27;warning&#x27;, &#x27;danger&#x27;].indexOf(value) !== -1</span><br><span class="line">      &#125;    // 自定义验证函数</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>组件继承</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const CompVue = Vue.extend(component)</span><br><span class="line"></span><br><span class="line">new CompVue(&#123;</span><br><span class="line">  name: &quot;root&quot;, // name 挂载到 $options 而不是挂载在生成的实例上</span><br><span class="line">  el: &quot;#root&quot;,</span><br><span class="line">  propsData: &#123;</span><br><span class="line">    propsOne: &quot;xxx&quot;</span><br><span class="line">  &#125; // 通过propsData 传入数据</span><br><span class="line">  data: &#123;</span><br><span class="line">    text: &#x27;1220&#x27;</span><br><span class="line">  &#125; // 可以覆盖默认值</span><br><span class="line">&#125;) // 声明了一个组件</span><br><span class="line"></span><br><span class="line">const component2 = &#123;</span><br><span class="line">  extends: component, // 继承</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      text: &#x27;180&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line">  this.$parent.text = &#x27;123&#x27; // 不建议这样修改！</span><br><span class="line">&#125;</span><br><span class="line">子组件可以通过$parent直接调用父组件属性</span><br><span class="line">const component2 = &#123;</span><br><span class="line">parent: parent, // 不生效 vue渲染时指定 没办法修改</span><br><span class="line">extends: component,</span><br><span class="line">&#125;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">parent: parent // new Vue(实例)的时候才能指定parent </span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><h3 id="组件高级特性"><a href="#组件高级特性" class="headerlink" title="组件高级特性"></a>组件高级特性</h3><h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  template: `</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;comp-one&gt;</span><br><span class="line">        &lt;span&gt;this is content&lt;/span&gt;</span><br><span class="line">      &lt;/comp-one&gt;</span><br><span class="line">      &#123;&#123;value&#125;&#125;</span><br><span class="line">    &lt;/div&gt; // 实现span的显示</span><br><span class="line">    `</span><br><span class="line"></span><br><span class="line">  template: `</span><br><span class="line">    &lt;div :style=&quot;style&quot;&gt;</span><br><span class="line">      &lt;slot&gt;&lt;/slot&gt; // 可以在里面放默认内容，它只会在没有提供内容的时候被渲染</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  `, // 可以实现span 将span放在组件模板里面</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  具名插槽</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;!-- 我们希望把页头放这里 --&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;!-- 我们希望把主要内容放这里 --&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">    &lt;!-- 我们希望把页脚放这里 --&gt;</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; // 不能有默认</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;slot&gt;默认&lt;/slot&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">一个不带 name 的 &lt;slot&gt; 出口会带有隐含的名字“default”。</span><br><span class="line">// 默认写法可以不带&lt;template&gt;</span><br></pre></td></tr></table></figure><p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">在向具名插槽提供内容的时候，我们可以在一个 &lt;template&gt; 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称：</span><br><span class="line">&lt;base-layout&gt;</span><br><span class="line">  &lt;template v-slot:header&gt;</span><br><span class="line">    &lt;h1&gt;Here might be a page title&lt;/h1&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template v-slot:footer&gt;</span><br><span class="line">    &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/base-layout&gt;</span><br><span class="line">注意 v-slot 只能添加在 &lt;template&gt; 上 (只有一种例外情况)，这一点和已经废弃的 slot attribute 不同。 v-slot ==== #</span><br></pre></td></tr></table></figure><h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;slot name=&quot;c&quot; :slotData=&quot;title&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template #c=&quot;slotProps&quot;&gt;</span><br><span class="line">    &#123;&#123;slotProps.slotData.a&#125;&#125;</span><br><span class="line">  &lt;/template&gt; // 父组件访问子组件内容</span><br><span class="line">  </span><br><span class="line">  可以使用解构赋值</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  &lt;slot name=&quot;c&quot; :slotData=&quot;&#123;value, title&#125;&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>ref 用在组件返回该组件，用在html返回标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">provide 和 inject 主要在开发高阶插件/组件库时使用。并不推荐用于普通应用程序代码中。</span><br><span class="line"></span><br><span class="line">  provide () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      grandFather: this,</span><br><span class="line">      value: this.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">    inject: [&#x27;grandFather&#x27;, &#x27;value&#x27;],</span><br><span class="line">    mounted() &#123;</span><br><span class="line">    console.log(this.grandFather, this.value);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">处理父子、爷孙组件通讯。需要有上下关系。不具有响应式</span><br><span class="line">如需要具有响应式：</span><br><span class="line">  provide () &#123;</span><br><span class="line">    const data = &#123;&#125;</span><br><span class="line">    Object.defineProperty(data, &#x27;value&#x27; &#123;</span><br><span class="line">  get: () =&gt; this.value, // 需要箭头函数</span><br><span class="line">      enumerable:true // 可被读取</span><br><span class="line">    &#125;)</span><br><span class="line">    return data // 不建议使用</span><br></pre></td></tr></table></figure><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>使用template 会使用生命周期的一个过程——编译 编译成JS函数 通过render()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">render (createElement) &#123;</span><br><span class="line">  return createElement()</span><br><span class="line">&#125; // 等价于</span><br><span class="line">render () &#123;</span><br><span class="line">// 每一个实例都有$createElement方法</span><br><span class="line">return this.$createElement()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  render (createElement) &#123;</span><br><span class="line">  return createElement(&#x27;comp-one&#x27;, &#123;attrs&#125;, [children])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">routes.js</span><br><span class="line">import Todo from &#x27;../views/todo/todo.vue&#x27;</span><br><span class="line">import Login from &#x27;../views/login/login.vue&#x27;</span><br><span class="line">export default [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/app&#x27;,</span><br><span class="line">    component: Todo</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/login&#x27;,</span><br><span class="line">    component: Login</span><br><span class="line">  &#125;</span><br><span class="line">] // 最基本的配置</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">touter.js</span><br><span class="line">import Router from &#x27;vue-router&#x27;</span><br><span class="line"></span><br><span class="line">import routes from &#x27;./routes&#x27;</span><br><span class="line"></span><br><span class="line">const router = new Router(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line">export default router // import 的router 都是同一个router</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import Router from &#x27;vue-router&#x27;</span><br><span class="line">import routes from &#x27;./routes&#x27;</span><br><span class="line">// export default router // import 的router 都是同一个router</span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line">  return new Router(&#123;</span><br><span class="line">    routes</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; // 项目需要用到服务端渲染，如果只引用一个 router 会有内存溢出问题 </span><br><span class="line">每次服务端渲染都会重新生成一个App</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">index.js配置路由</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./app.vue&#x27;</span><br><span class="line">import VueRouter from &#x27;vue-router&#x27;</span><br><span class="line"></span><br><span class="line">import &#x27;./assets/styles/global.styl&#x27;</span><br><span class="line">import createRouter from &#x27;./config/router&#x27;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line">const router = createRouter()</span><br><span class="line"></span><br><span class="line">const root = document.createElement(&#x27;div&#x27;)</span><br><span class="line">document.body.appendChild(root)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: (h) =&gt; h(App)</span><br><span class="line">&#125;).$mount(root)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">app.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;cover&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;Header&gt;&lt;/Header&gt;</span><br><span class="line">    &lt;!-- &lt;todo&gt;&lt;/todo&gt; --&gt;</span><br><span class="line">    &lt;router-view /&gt; // 添加路由跳转</span><br><span class="line">    &lt;Footer&gt;&lt;/Footer&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/&#x27;,</span><br><span class="line">    redirect: &#x27;/app&#x27;</span><br><span class="line">  &#125;, // 默认页面</span><br></pre></td></tr></table></figure><p><a href="http://localhost:8000/#/app">http://localhost:8000/#/app</a> hash路由不会被SEO </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> // router.js</span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line">  return new Router(&#123;</span><br><span class="line">    routes,</span><br><span class="line">    mode: &#x27;history&#x27;, // 改成H5路由，没有#</span><br><span class="line">    base: &#x27;/base/&#x27; // http://localhost:8000/base/app  基路径</span><br><span class="line">    linkActiveClass: &#x27;&#x27;,</span><br><span class="line">    linkExactActiveClass: &#x27;&#x27;，</span><br><span class="line">    scrollBehavior (to, from, savePosition) &#123;</span><br><span class="line">      if (savePosition) return savePosition</span><br><span class="line">      return &#123;x: 0, y: 0&#125;</span><br><span class="line">    &#125; // 记录上次访问页面滚动的位置</span><br><span class="line">    parseQuery (query) &#123;</span><br><span class="line">// 记录参数 http://localhost:8000/app?=undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    stringifyQuery (obj) &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    fallback: true // 检测到浏览器不支持H5， 转成hash路由</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">路由跳转</span><br><span class="line">    &lt;router-link to=&quot;/app&quot;&gt;app&lt;/router-link&gt;</span><br><span class="line">    &lt;router-link to=&quot;/login&quot;&gt;login&lt;/router-link&gt;</span><br><span class="line">    &lt;router-view /&gt; // 页面显示</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const devServer = &#123;</span><br><span class="line">  port: 8080,</span><br><span class="line">  host: &#x27;0.0.0.0&#x27;,</span><br><span class="line">  overlay: &#123;</span><br><span class="line">    errors: true, // 出现错误，编译器全屏覆盖</span><br><span class="line">  &#125;,</span><br><span class="line"> historyApiFallback: &#123;</span><br><span class="line">    index: &#x27;/index.html&#x27;</span><br><span class="line">  &#125;,  // webpack devServer没有做路径的映射关系，http://localhost:8000/app不认识/app路径，页面刷新时会与后端交互。在前端跳转没有问题   history路由 可以配置 historyApiFallback</span><br><span class="line">  hot: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由的命名</p><p>可以通过 name  进行路由跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123;name: &#x27;app&#x27;&#125;&quot;&gt;app&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">meta: &#123;</span><br><span class="line">// 保存路由信息 SEO</span><br><span class="line">title: &#x27;this is app&#x27;,</span><br><span class="line">discription: &#x27;asdasd&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">children: [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;text&#x27;,</span><br><span class="line">    component: Login</span><br><span class="line">  &#125;</span><br><span class="line">] // 需要在该组件声明&lt;router-view /&gt; 占位符</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt;</span><br><span class="line">  &lt;router-view /&gt;</span><br><span class="line">&lt;transition&gt; // 过渡动画</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">path: &#x27;/app/:id&#x27;, // 路由传参</span><br><span class="line">&lt;router-link to=&quot;/app/123&quot;&gt;app&lt;/router-link&gt;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(this.$route);</span><br><span class="line">  &#125;,</span><br><span class="line">  query: ?a=123&amp;b=46,</span><br><span class="line">  </span><br><span class="line">  path: &#x27;/app/:id&#x27;, </span><br><span class="line">  props: true, // 会把:id 作为prop传入组件</span><br><span class="line">  // props 可以指定传入的数据</span><br><span class="line">  // props: &#123;id: 456&#125;  props: (router) =&gt;( &#123;id: router.query.b&#125; )</span><br><span class="line">  </span><br><span class="line">  todo.vue</span><br><span class="line">  props: [&#x27;id&#x27;],</span><br></pre></td></tr></table></figure><h4 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">index.js</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line">const router = createRouter()</span><br><span class="line"></span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;beforeEach invoked&#x27;); </span><br><span class="line">  if (to.fullPath === &#x27;/login&#x27;)  // 进行数据校验 如页面需要用户登录 跳转登录页面</span><br><span class="line">  next(&quot;/login&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">router.beforeResolve((to, from, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;beforeResolve invoked&#x27;);</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line">router.afterEach((to, from) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;afterEach invoked&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">routes.js</span><br><span class="line">meta: &#123;</span><br><span class="line">      title: &#x27;this is app&#x27;,</span><br><span class="line">    discription: &#x27;asdasd&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="line">      // 进入路由之前被调用</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">todo.vue</span><br><span class="line">  beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">  // 不能调用this 页面没有渲染</span><br><span class="line">    console.log(&#x27;beforeRouterEnter invoked&#x27;);</span><br><span class="line">    next() //     next(vm =&gt; &#123;console.log(vm.$options.name)&#125;) 在next中调用</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouterUpdate (to, from, next) &#123;</span><br><span class="line">    console.log(&#x27;beforeRouterUpdate invoked&#x27;);</span><br><span class="line">    // 在当前路由改变，但是该组件被复用时调用</span><br><span class="line">    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span><br><span class="line">    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class="line">    不触发组件 mounted 生命周期</span><br><span class="line">    next()</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">    console.log(&#x27;beforeRouteLeave invoked&#x27;);</span><br><span class="line">    if ( confirm(&quot;are u sure?&quot;) ) next() // 用户确认是否要离开</span><br><span class="line">  &#125;,</span><br><span class="line">    顺序</span><br><span class="line">beforeEach invoked</span><br><span class="line">beforeEnter invoked</span><br><span class="line">beforeRouterEnter invoked</span><br><span class="line">beforeResolve invoked</span><br><span class="line">afterEach invoked</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view name=&quot;a&quot; /&gt;</span><br><span class="line"> // routes.js</span><br><span class="line">    components: &#123;</span><br><span class="line">      default: Todo, // 没名字的</span><br><span class="line">      a: Login</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h4 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">component: () =&gt; import(&#x27;../views/todo/todo.vue&#x27;) // 需要bebal-plugin-syntax-dynamic-import</span><br><span class="line"></span><br><span class="line">修改.babelrc</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;syntax-dynamic-import&quot;</span><br><span class="line">  ] // 首屏加载速度变快</span><br></pre></td></tr></table></figure><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>Flux 单向数据流</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">初始化store</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;，</span><br><span class="line">    mutations: &#123;</span><br><span class="line">    updateCount (state, num) &#123;</span><br><span class="line">      state.count = num</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default store // 一个Vuex实例</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store, // vue 是树形结构，放在最外面，所有子节点才能拿到</span><br><span class="line">  render: (h) =&gt; h(App)</span><br><span class="line">&#125;).$mount(root)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.vue</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(this.$store);</span><br><span class="line">  &#125;, // 调用 store 在每一个组件都加入了$store</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      return this.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">修改值</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(this.$store);</span><br><span class="line">    let i = 1;</span><br><span class="line">    setInterval(() =&gt; &#123;</span><br><span class="line">      this.$store.commit(&#x27;updateCount&#x27;, i++)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>最好把state单独拿出来，未声明的变量，设置一个null(触发响应式)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">getters.js</span><br><span class="line">export default &#123;</span><br><span class="line">  // 组件内的 computed 方便生成在应用中可以用的数据</span><br><span class="line">  fullName (state) &#123;</span><br><span class="line">    return state.fullName + &#x27; &#x27; + state.fullName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.vue</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName () &#123;</span><br><span class="line">      return this.$store.getters.fullName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">更方便的使用vuex</span><br><span class="line">app.vue</span><br><span class="line">import &#123;mapState, mapGetters&#125; from &#x27;vuex&#x27;</span><br><span class="line"></span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapState([&#x27;count&#x27;]), // 等价于</span><br><span class="line">    // count () &#123;</span><br><span class="line">    //   return this.$store.state.count</span><br><span class="line">    // &#125;,</span><br><span class="line">    </span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      counter: (state) =&gt; state.count</span><br><span class="line">    &#125;),// 重命名</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations // 同步</span><br><span class="line">updateCount (state, num) // 只能转2个参数，第二个参数是包含修改state的对象 </span><br><span class="line">updateCount (state, &#123;num: i++, num2: 2&#125;)</span><br><span class="line"></span><br><span class="line">所有的state数据修改都要放在mutations中</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">store.js</span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line">  return new Vuex.Store(&#123;</span><br><span class="line">    strict: true, // 无法在外部通过this.$store.state.xxx 修改数据 在开发环境规范代码使用</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const isDev = process.env.NODE_ENV === &#x27;development&#x27;</span><br><span class="line">strict: isDev,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">actions // 异步</span><br><span class="line"></span><br><span class="line">  updateCountAsync (store, data) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      store.commit(&quot;updateCount&quot;, data.num)</span><br><span class="line">    &#125;, data.time)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">app.vue</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.$store.dispatch(&quot;updateCountAsync&quot;, &#123;</span><br><span class="line">      num: 10,</span><br><span class="line">      time: 2000,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">更方便的使用 mapMutations, mapActions</span><br><span class="line">import &#123;mapMutations, mapActions&#125; from &#x27;vuex&#x27;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([&#x27;updateCountAsync&#x27;]),</span><br><span class="line">    ...mapMutations([&#x27;updateCount&#x27;])</span><br><span class="line">  &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">    this.updateCountAsync(&#123;</span><br><span class="line">      num: 10,</span><br><span class="line">      time: 2000,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  对比：</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.$store.dispatch(&quot;updateCountAsync&quot;, &#123;</span><br><span class="line">      num: 10,</span><br><span class="line">      time: 2000,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h4 id="Vuex-模块"><a href="#Vuex-模块" class="headerlink" title="Vuex 模块"></a>Vuex 模块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">store.js</span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line">  return new Vuex.Store(&#123;</span><br><span class="line">    modules: &#123;</span><br><span class="line">      a: &#123;</span><br><span class="line">      // namespaced: true</span><br><span class="line">        state: &#123;</span><br><span class="line">          text: 1</span><br><span class="line">        &#125;,</span><br><span class="line">         mutations: &#123;</span><br><span class="line">          updateText (state, text) &#123;</span><br><span class="line">            // 这里的state是 a 模块的state 默认把所有的mutations 放在全局命名空间 如需要单独命名空间 需要声明一个属性，namespaced: true</span><br><span class="line">            state.text = text</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      b: &#123;</span><br><span class="line">        state: &#123;</span><br><span class="line">          text: 2</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  app.vue</span><br><span class="line">  computed: &#123;</span><br><span class="line">  textA () &#123;</span><br><span class="line">  return this.$store.state.a.text</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  使用 mapState 不能通过名字来调用</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">  textA: state =&gt; state.a.text</span><br><span class="line">  &#125;) // 通过对象映射关系</span><br><span class="line">  </span><br><span class="line">  使用 mapMutations 可以通过名字调用</span><br><span class="line">  使用 namespaced 时：</span><br><span class="line">  ...mapMutations([&#x27;updateCount&#x27;, &#x27;a/updateText&#x27;])</span><br><span class="line">  this[&#x27;a/updateText&#x27;](&#x27;321&#x27;)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  textPlus (state, getters, rootState) &#123;</span><br><span class="line">    return state.text +rootState.count // 第三个参数：全局state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> actions: &#123;</span><br><span class="line">  add ( &#123;state, commit, rootState&#125; ) &#123;</span><br><span class="line">    commit(&#x27;updateText&#x27;, rootState.count)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">// 需要从全局mutations调用:commit(&#x27;updateText&#x27;, rootState.count &#123;root:true&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">index.js</span><br><span class="line">store.registerModule(&#x27;c&#x27;, &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    text: 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;) // 动态加载模块</span><br><span class="line"></span><br><span class="line">store.unregisterModule(&#x27;c&#x27;) // 解绑</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">修改store 需要刷新页面更新 </span><br><span class="line">使用热更替</span><br><span class="line"></span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line">  const store =  new Vuex.Store(&#123;</span><br><span class="line">    strict: isDev,</span><br><span class="line">    state: defaultState,</span><br><span class="line">    mutations,</span><br><span class="line">    getters,</span><br><span class="line">    actions,</span><br><span class="line">    </span><br><span class="line">  if (module.hot) &#123;</span><br><span class="line">    module.hot.accept([</span><br><span class="line">      &#x27;./state/state.js&#x27;,</span><br><span class="line">      &#x27;./mutations/mutations&#x27;,</span><br><span class="line">      &#x27;./getters/getters&#x27;,</span><br><span class="line">      &#x27;./actions/actions&#x27;</span><br><span class="line">    ], () =&gt; &#123;</span><br><span class="line">      const newState = require(&#x27;./state/state&#x27;).default</span><br><span class="line">      const newMutations = require(&#x27;./mutations/mutations&#x27;).default</span><br><span class="line">      const newGetters = require(&#x27;./getters/getters&#x27;).default</span><br><span class="line">      const newActions = require(&#x27;./actions/actions&#x27;).default</span><br><span class="line"></span><br><span class="line">      store.hotUpdate(&#123;</span><br><span class="line">        state: newState,</span><br><span class="line">        mutations: newMutations,</span><br><span class="line">        getters: newGetters,</span><br><span class="line">        actions: newActions</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return store</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">index.js</span><br><span class="line">监听 制作插件使用 vuex中的插件就一个function</span><br><span class="line">store.watch((state) =&gt; state.count + 1, (newCount) =&gt; &#123;</span><br><span class="line">  console.log(newCount)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.subscribe((mutations, state) =&gt; &#123;</span><br><span class="line">  console.log(mutations.type, state);</span><br><span class="line">    console.log(mutations.payload, state); // 调用的方法</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.subscribeAction((action, state) =&gt; &#123;</span><br><span class="line">  console.log(action);</span><br><span class="line">&#125;)  // 规定mutations action 第二个参数必须是obj,在subcribe时能把所有参数拿到，一目了然的去操作一些东西</span><br><span class="line"></span><br><span class="line">    plugins: [</span><br><span class="line">      (store) =&gt; &#123;</span><br><span class="line">        // 初始化调用</span><br><span class="line">        console.log(store.subscribe);</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 变量</title>
      <link href="/2021/06/16/css-bian-liang/"/>
      <url>/2021/06/16/css-bian-liang/</url>
      
        <content type="html"><![CDATA[<h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p><a href="https://v833.github.io/javscript-projects/03-CSS%20Variables/">点击查看</a></p><p>用 JavaScript 和 CSS3 实现拖动滑块时，实时调整图片的模糊度、背景颜色，同时标题中 JS 两字的颜色也随图片背景颜色而变化。</p><h2 id="涉及特性"><a href="#涉及特性" class="headerlink" title="涉及特性"></a>涉及特性</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:root"><code>:root</code></a></li><li><code>var(--xxx)</code>：CSS 变量（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_variables">CSS Variables</a>）</li><li><code>filter: blur()</code></li><li>事件 <code>change</code>、<code>mousemove</code></li></ul><h2 id="HTML源码"><a href="#HTML源码" class="headerlink" title="HTML源码"></a>HTML源码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Update CSS Variables with <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&#x27;hl&#x27;</span>&gt;</span>JS<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;controls&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;spacing&quot;</span>&gt;</span>Spacing:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;spacing&quot;</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">name</span>=<span class="string">&quot;spacing&quot;</span> <span class="attr">min</span>=<span class="string">&quot;10&quot;</span> <span class="attr">max</span>=<span class="string">&quot;200&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> <span class="attr">data-sizing</span>=<span class="string">&quot;px&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;blur&quot;</span>&gt;</span>Blur:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;blur&quot;</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">name</span>=<span class="string">&quot;blur&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;25&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> <span class="attr">data-sizing</span>=<span class="string">&quot;px&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;base&quot;</span>&gt;</span>Base Color<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;base&quot;</span> <span class="attr">type</span>=<span class="string">&quot;color&quot;</span> <span class="attr">name</span>=<span class="string">&quot;base&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#ffc600&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;result&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;showText&quot;</span>&gt;</span>&#123;spacing:<span class="tag">&lt;<span class="name">label</span> <span class="attr">id</span>=<span class="string">&quot;label_spacing&quot;</span>&gt;</span>#ffc600<span class="tag">&lt;/<span class="name">label</span>&gt;</span>&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;showText&quot;</span>&gt;</span>&#123;blur:<span class="tag">&lt;<span class="name">label</span> <span class="attr">id</span>=<span class="string">&quot;label_blur&quot;</span>&gt;</span>10px<span class="tag">&lt;/<span class="name">label</span>&gt;</span>&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;showText&quot;</span>&gt;</span>&#123;base:<span class="tag">&lt;<span class="name">label</span> <span class="attr">id</span>=<span class="string">&quot;label_base&quot;</span>&gt;</span>10px<span class="tag">&lt;/<span class="name">label</span>&gt;</span>&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img.jpg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="CSS源码"><a href="#CSS源码" class="headerlink" title="CSS源码"></a>CSS源码</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">   <span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">    <span class="attr">--base</span>: <span class="number">#ffc600</span>;</span><br><span class="line">    <span class="attr">--spacing</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attr">--blur</span>: <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">img</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="built_in">var</span>(--spacing);</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">var</span>(--base);</span><br><span class="line">    <span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="built_in">var</span>(--blur));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.hl</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">var</span>(--base);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#193549</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;helvetica neue&#x27;</span>, sans-serif;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">100</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.controls</span> &#123;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">50px</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">input</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="JS源码"><a href="#JS源码" class="headerlink" title="JS源码"></a>JS源码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> inputs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.controls input&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> suffix = <span class="variable language_">this</span>.<span class="property">dataset</span>.<span class="property">sizing</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">`--<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>, <span class="variable language_">this</span>.<span class="property">value</span> + suffix);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">`label_<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>).<span class="property">innerText</span> = <span class="variable language_">this</span>.<span class="property">value</span> + suffix;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inputs.<span class="title function_">forEach</span>(<span class="function"><span class="params">input</span> =&gt;</span> input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;change&#x27;</span>, handleUpdate));</span><br><span class="line">  inputs.<span class="title function_">forEach</span>(<span class="function"><span class="params">input</span> =&gt;</span> input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, handleUpdate));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="过程指南"><a href="#过程指南" class="headerlink" title="过程指南"></a>过程指南</h2><h3 id="CSS-部分准备"><a href="#CSS-部分准备" class="headerlink" title="CSS 部分准备"></a>CSS 部分准备</h3><ol><li>声明全局（<code>:root</code>）的 CSS 变量</li><li>将变量应用到页面中对应元素 <code>&lt;img&gt;</code> </li><li>处理标题的 CSS 值</li></ol><h3 id="JS-实时更新-CSS-值"><a href="#JS-实时更新-CSS-值" class="headerlink" title="JS 实时更新 CSS 值"></a>JS 实时更新 CSS 值</h3><ol><li>获取页面中 <code>input</code> 元素</li><li>给每个 <code>input</code> 添加监听事件，使其在值变动，触发更新操作</li><li>同 2 ，添加鼠标滑过时的事件监听</li><li>编写处理更新操作的方法<ol><li> 获取参数值后缀</li></ol><ul><li>获取参数名（blur、spacing、color）</li><li>获取参数值（12px、#efefef）</li><li>赋值给对应的 CSS 变量</li></ul></li></ol><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li><p>NodeList 和 Array 的区别</p><p> 可以打开 <strong>proto</strong> 查看它的方法，其中有 <code>forEach()</code>、<code>item()</code>、<code>keys()</code> 等。而 Array 的 prototype 中有 <code>map()</code>、<code>pop()</code> 等数组才有的方法。</p></li><li><p>HTML5 中的自定义数据属性 <code>dataset</code></p><p> HTML5 中可以为元素添加非标准的自定义属性，只需要加上 <code>data-</code> 前缀，可以随便添加和命名。添加之后，可以通过元素的 <code>dataset</code> 属性来访问这些值，<code>dataset</code> 的值是 DOMStringMap 的一个实例化对象，其中包含之前所设定的自定义属性的“名-值”对。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_variables">CSS variable</a></p><p> 这是一个 CSS3 的新特性，<a href="http://caniuse.com/#feat=css-variables">IE 和 Edge 目前都还不支持</a>。命名写法是 <code>--变量名</code>，在引用这个变量时写法是 <code>var(--变量名)</code>。具体实例见下一条代码。</p></li><li><p><code>:root</code> 伪类</p><p> 这个伪元素匹配的是文档的根元素，也就是 <code>&lt;html&gt;</code> 标签。</p><p> 所以常用于声明全局的 CSS 变量：</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attr">--color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在使用时：</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>CSS 滤镜 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter">filter</a></p><p> CSS 的滤镜提供了一些图形特效，比如高斯模糊、锐化、变色等。它带有一些预设的函数，在使用时加上参数调用这些函数即可。<a href="http://caniuse.com/#search=filter">在 Chrome、Firefox 中都支持。</a></p></li></ol><h2 id="解决难点"><a href="#解决难点" class="headerlink" title="解决难点"></a>解决难点</h2><ol><li><p><strong>如何处理参数值（一个有 px 、另一个没有）</strong></p><p> 运用 <code>dataset</code> 储存后缀，有 px 后缀的标签中设置 <code>&lt;input data-sizing: px&gt;</code>：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">name</span>=<span class="string">&quot;blur&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;25&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> <span class="attr">data-sizing</span>=<span class="string">&quot;px&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;color&quot;</span> <span class="attr">name</span>=<span class="string">&quot;base&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#8aa8af&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p> JS 中通过 <code>dataset.sizing</code> 来获取后缀值：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> suffix = <span class="variable language_">this</span>.<span class="property">dataset</span>.<span class="property">sizing</span> || <span class="string">&#x27;&#x27;</span>; </span><br></pre></td></tr></table></figure><p> 此时 suffix 获取到的值，针对颜色为空，而针对长度类的则为 ‘px’。</p></li><li><pre><code>**如何用 JavaScript 改变 CSS 属性值？**</code></pre></li></ol><pre><code>在 JavaScript 中 `document.documentElement` 即代表文档根元素。所以要改变全局的 CSS 变量，可以这样写：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;--base&#x27;</span>, <span class="string">&#x27;#fff&#x27;</span>);</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      <categories>
          
          <category> 原生js项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>audio 爵士鼓音乐敲击特效</title>
      <link href="/2021/06/16/audio-jue-shi-gu-yin-le-qiao-ji-te-xiao/"/>
      <url>/2021/06/16/audio-jue-shi-gu-yin-le-qiao-ji-te-xiao/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>项目效果</strong>：<a href="https://v833.github.io/javscript-projects/02-JavaScript%20Drum%20Kit/">点击查看</a></p><p>用JS制作一个爵士鼓的页面，通过敲击键盘上不同的字母，会发出不同的声音，并且页面上会伴随着敲击的动画。</p><p>想要实现以上效果，大致思路和解决方案如下：</p><ul><li>检测到键盘上什么键被按下–监听<code>keydown</code>事件</li><li>在按键被按下的时候，播放音效–<code>audio.play()</code></li><li>在按键被按下的同时，播放动画–<code>Element.classList.add(&#39;className&#39;)</code></li><li>在动画结束后，移除动画，不然之后再点击不会有任何效果–<code>Element.classList.remove(&#39;className&#39;)</code></li></ul><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="一些-ES6-语法"><a href="#一些-ES6-语法" class="headerlink" title="一些 ES6 语法"></a>一些 ES6 语法</h3><ol><li><p> <code>const</code> ：声明一个只读的常量，标识符的值只能赋值一次。</p></li><li><p> `字符串 ${ 变量、属性名 } `：模板字面量（Template literals）中用于表示模板字符串的标识。特点是字符串首尾用反引号（`），内部的模板部分用 ${ } 括起来表示，具体请看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings">MDN文档</a>。简单例子如下：</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//不用模板的写法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;三是&quot;</span> + (a + b) + <span class="string">&quot;不是&quot;</span> + (<span class="number">2</span> * a + b)); <span class="comment">//&quot;三是3不是4&quot;</span></span><br><span class="line"><span class="comment">//使用模板字符串的写法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`三是<span class="subst">$&#123;a + b&#125;</span>不是<span class="subst">$&#123;<span class="number">2</span> * a + b&#125;</span>`</span>); <span class="comment">//&quot;三是3不是4&quot;</span></span><br></pre></td></tr></table></figure><h3 id="forEach-与箭头函数"><a href="#forEach-与箭头函数" class="headerlink" title="forEach 与箭头函数"></a><code>forEach</code> 与箭头函数</h3><p>使用 <code>document.querySelector</code> 获取一组符合 CSS 选择符的元素快照，类型为 NodeList（此对象是对于文档的实时运行的动态查询），对其进行遍历时可采用 <code>forEach</code> 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line">nums.<span class="title function_">forEach</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (v % <span class="number">5</span> === <span class="number">0</span>)</span><br><span class="line">fives.<span class="title function_">push</span>(v);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line">nums.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">v</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (v % <span class="number">5</span> === <span class="number">0</span>)</span><br><span class="line">five.<span class="title function_">push</span>(v);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="页面基础布局"><a href="#页面基础布局" class="headerlink" title="页面基础布局"></a>页面基础布局</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Drum Kit<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;keys&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">data-key</span>=<span class="string">&quot;65&quot;</span> <span class="attr">class</span>=<span class="string">&quot;key&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>A<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;sound&quot;</span>&gt;</span>clap<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">data-key</span>=<span class="string">&quot;83&quot;</span> <span class="attr">class</span>=<span class="string">&quot;key&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>S<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;sound&quot;</span>&gt;</span>hihat<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">data-key</span>=<span class="string">&quot;68&quot;</span> <span class="attr">class</span>=<span class="string">&quot;key&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>D<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;sound&quot;</span>&gt;</span>kick<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">data-key</span>=<span class="string">&quot;70&quot;</span> <span class="attr">class</span>=<span class="string">&quot;key&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>F<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;sound&quot;</span>&gt;</span>openhat<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">data-key</span>=<span class="string">&quot;71&quot;</span> <span class="attr">class</span>=<span class="string">&quot;key&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>G<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;sound&quot;</span>&gt;</span>boom<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">data-key</span>=<span class="string">&quot;72&quot;</span> <span class="attr">class</span>=<span class="string">&quot;key&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>H<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;sound&quot;</span>&gt;</span>ride<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">data-key</span>=<span class="string">&quot;74&quot;</span> <span class="attr">class</span>=<span class="string">&quot;key&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>J<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;sound&quot;</span>&gt;</span>snare<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">data-key</span>=<span class="string">&quot;75&quot;</span> <span class="attr">class</span>=<span class="string">&quot;key&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>K<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;sound&quot;</span>&gt;</span>tom<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">data-key</span>=<span class="string">&quot;76&quot;</span> <span class="attr">class</span>=<span class="string">&quot;key&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>L<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;sound&quot;</span>&gt;</span>tink<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">audio</span> <span class="attr">data-key</span>=<span class="string">&quot;65&quot;</span> <span class="attr">src</span>=<span class="string">&quot;sounds/clap.wav&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">audio</span> <span class="attr">data-key</span>=<span class="string">&quot;83&quot;</span> <span class="attr">src</span>=<span class="string">&quot;sounds/hihat.wav&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">audio</span> <span class="attr">data-key</span>=<span class="string">&quot;68&quot;</span> <span class="attr">src</span>=<span class="string">&quot;sounds/kick.wav&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">audio</span> <span class="attr">data-key</span>=<span class="string">&quot;70&quot;</span> <span class="attr">src</span>=<span class="string">&quot;sounds/openhat.wav&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">audio</span> <span class="attr">data-key</span>=<span class="string">&quot;71&quot;</span> <span class="attr">src</span>=<span class="string">&quot;sounds/boom.wav&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">audio</span> <span class="attr">data-key</span>=<span class="string">&quot;72&quot;</span> <span class="attr">src</span>=<span class="string">&quot;sounds/ride.wav&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">audio</span> <span class="attr">data-key</span>=<span class="string">&quot;74&quot;</span> <span class="attr">src</span>=<span class="string">&quot;sounds/snare.wav&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">audio</span> <span class="attr">data-key</span>=<span class="string">&quot;75&quot;</span> <span class="attr">src</span>=<span class="string">&quot;sounds/tom.wav&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">audio</span> <span class="attr">data-key</span>=<span class="string">&quot;76&quot;</span> <span class="attr">src</span>=<span class="string">&quot;sounds/tink.wav&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><kbd> 标签定义键盘文本</li></ul><p>说到技术概念上的特殊样式时，就要提到 <kbd> 标签。正如你已经猜到的，它用来表示文本是从键盘上键入的。<br>浏览器通常用等宽字体来显示该标签中包含的文本。<br><kbd> 标签经常用在于计算机相关的文档和手册中。例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">键入 &lt;kbd&gt;quit&lt;/kbd&gt; 来退出程序，或者键入 &lt;kbd&gt;menu&lt;/kbd&gt; 来返回主菜单。</span><br></pre></td></tr></table></figure><ul><li>使用 data-* 属性来嵌入自定义数据</li></ul><p>页面里通过data-key将页面展示的内容和audio关联起来。使用方法如下介绍：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">data-animal-type</span>=<span class="string">&quot;bird&quot;</span>&gt;</span>Owl<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">data-animal-type</span>=<span class="string">&quot;fish&quot;</span>&gt;</span>Salmon<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">data-animal-type</span>=<span class="string">&quot;spider&quot;</span>&gt;</span>Tarantula<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>① data-* 属性用于存储页面或应用程序的私有自定义数据。<br>② data-* 属性赋予我们在所有 HTML 元素上嵌入自定义 data 属性的能力。<br>③ 属性名不应该包含任何大写字母，并且在前缀 “data-“ 之后必须有至少一个字符<br>④ 属性值可以是任意字符串</p><p><strong>语法:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;element data-*=&quot;somevalue&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>属性值:</strong></p><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">somevalue</td><td align="center">规定属性的值（以字符串）。</td></tr></tbody></table><h2 id="主要CSS代码"><a href="#主要CSS代码" class="headerlink" title="主要CSS代码"></a>主要CSS代码</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;./3.jpg&#x27;</span>) bottom center;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span>,</span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.keys</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">min-height</span>: <span class="number">100vh</span>; </span><br><span class="line">  <span class="attribute">align-items</span>: center;  </span><br><span class="line">  <span class="attribute">justify-content</span>: center; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.key</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: .<span class="number">4rem</span> solid black;</span><br><span class="line">  <span class="attribute">border-radius</span>: .<span class="number">5rem</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5rem</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1rem</span> .<span class="number">5rem</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all .<span class="number">07s</span> ease;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10rem</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: white; </span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.4</span>);</span><br><span class="line">  <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">0</span> .<span class="number">5rem</span> black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.playing</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.1</span>);</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#ffc600</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1rem</span> <span class="number">#ffc600</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">kbd</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block; </span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">4rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sound</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2rem</span>;</span><br><span class="line">  <span class="attribute">text-transform</span>: uppercase;</span><br><span class="line">  <span class="attribute">letter-spacing</span>: .<span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ffc600</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要属性有以下几个：</p><ul><li><code>html</code>中有一个样式为<code>font-size: 10px;</code>，在本案例中，<code>1rem</code>就是10px，rem是以html中的<code>font-size</code>为参照物，<code>1.2rem</code>就是<code>12px</code>。</li><li><code>transform: scale(1.1);</code>–该属性在键盘被点击时将该元素缩放至原来的1.1倍。</li><li><code>.key&#123;border: .4rem solid black;&#125; .playing&#123;border-color: #ffc600;&#125;</code>–这两条属性在按键点击的时候改变边框颜色。</li><li><code>.key&#123;text-shadow: 0 0 .5rem black;&#125; .playing&#123;box-shadow: 0 0 1rem #ffc600;&#125;</code>–这两条属性在按键点击的时候改变阴影的效果</li><li><code>transition: all .07s ease;</code>–定义以上动画在0.07秒内完成。<br>我们注意到我们定义了<code>.palying</code>类，在按键按下的时侯为该元素添加<code>playing</code>类，在结束后移除<code>playing</code>类。</li></ul><h2 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h2><h3 id="按键监听-amp-音效播放-amp-添加动画"><a href="#按键监听-amp-音效播放-amp-添加动画" class="headerlink" title="按键监听&amp;音效播放&amp;添加动画"></a>按键监听&amp;音效播放&amp;添加动画</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">playSound</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> audio = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">`audio[data-key=&quot;<span class="subst">$&#123;e.keyCode&#125;</span>&quot;]`</span>);</span><br><span class="line">    <span class="keyword">const</span> key = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">`div[data-key=&quot;<span class="subst">$&#123;e.keyCode&#125;</span>&quot;]`</span>);</span><br><span class="line">    <span class="keyword">if</span> (!audio) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    key.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;playing&#x27;</span>);</span><br><span class="line">    audio.<span class="property">currentTime</span> = <span class="number">0</span>;</span><br><span class="line">    audio.<span class="title function_">play</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 监听页面的keydown事件，触发playAudio函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>, playSound);</span><br></pre></td></tr></table></figure><ul><li>监听页面的keydown事件，触发playAudio函数。</li><li>通过KeyCode检测我们按下的键盘按钮是哪个按钮。<ul><li>A -&gt; 65</li><li>B -&gt; 66</li><li>C -&gt; 67</li><li>D -&gt; 68</li><li>E -&gt; 69</li><li>F -&gt; 70</li><li>G -&gt; 71</li><li>H -&gt; 72</li><li>I -&gt; 73</li><li>J -&gt; 74</li><li>K -&gt; 75</li><li>L -&gt; 76</li><li>M -&gt; 77</li><li>N -&gt; 78</li><li>O -&gt; 79</li><li>P -&gt; 80</li><li>Q -&gt; 81</li><li>R -&gt; 82</li><li>S -&gt; 83</li><li>T -&gt; 84</li><li>U -&gt; 85</li><li>V -&gt; 86</li><li>W -&gt; 87</li><li>X -&gt; 88</li><li>Y -&gt; 89</li><li>Z -&gt; 90</li></ul></li><li>在这里我们用到了ES6的模板字符串，<code>$&#123;e.keyCode&#125;</code>,可以动态的将按键的<code>Keycode</code>传过去，以使<code>audio</code>动态的获取每一个按键绑定的<code>audio</code>。需要注意的是模板字符串一定要使用”`”(Esc下面那个键)包裹，而不是双引号。</li><li>我们注意到<code>audio.play();</code>前面一行是<code>audio.currentTime = 0;</code>，这是因为，如果没有在播放音效前将该音乐重置，会发生以下情况，当我连续点击某一按键的时候，只有第一次点击会响，第二次第三次连续的点击可能没声音。所以在每一次点击之前重置音效是很有必要的。</li><li><code>key.classList.add(&#39;playing&#39;);</code>可以在按键点击的同时为该元素添加playing类，展示小动画。</li><li><code>if(!audio) return; if(!key) return;</code>因为并不是每一个按键都有音效，当用户点击了非绑定音效按键，及时退出函数是很好的习惯。</li></ul><h3 id="动画结束后移除动画"><a href="#动画结束后移除动画" class="headerlink" title="动画结束后移除动画"></a>动画结束后移除动画</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">removeTransition</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">propertyName</span> !== <span class="string">&#x27;transform&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    e.<span class="property">target</span>.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;playing&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> keys = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.key&#x27;</span>));</span><br><span class="line">keys.<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> key.<span class="title function_">addEventListener</span>(<span class="string">&#x27;transitionend&#x27;</span>,stopTransition));  </span><br></pre></td></tr></table></figure><ul><li><p>监听每一个按键元素的<code>transitionend</code>事件，当按键元素的动画结束后会触发<code>removeTransition</code>函数。</p></li><li><p>首先在<code>removeTransition</code>函数中可以输出事件e的内容，会输出该动画每一步具体的变化，发现其中会有<code>propertyName</code>属性，可以通过判断<code>propertyName</code>等于其中的一个值（例如’transform’），等于该值就移除<code>playing</code>类，也即移除动画。</p></li><li><p>在定位元素的时候，可以使用<code>this</code>也可以使用<code>e.target</code>,可以简单这么理解，<code>this</code>值的是谁出发了这次事件，也就是<code>key</code>，就等同于事件的目标（e.target）.</p></li></ul><h2 id="解决难点"><a href="#解决难点" class="headerlink" title="解决难点"></a>解决难点</h2><h3 id="如何将键盘按键与页面按钮对应起来？"><a href="#如何将键盘按键与页面按钮对应起来？" class="headerlink" title="如何将键盘按键与页面按钮对应起来？"></a>如何将键盘按键与页面按钮对应起来？</h3><p>连接的帮手是 <code>keydown</code> 事件中的 <code>keyCode</code> 属性，<code>keyCode</code> 属性的值和 ASCII 编码值相同（对应小写字母）。在<a href="http://keycode.info/">这个网站</a>可以用按键盘来查看对应的键码。</p><p>我们能获取到的初始页面中，按钮 <code>div</code> 和音频 <code>audio</code> 标签中都添加了一个属性 <code>data-key</code> 用于存储对应的键码，这样做的目的是，添加键盘事件监听后，触发键盘事件时即可获取事件的 <code>keyCode</code> 属性值，以此为线索，操作对应的按钮及音频。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> audio = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">`audio[data-key=&quot;<span class="subst">$&#123;e.keyCode&#125;</span>&quot;]`</span>);</span><br><span class="line"><span class="keyword">const</span> key = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">`div[data-key=&quot;<span class="subst">$&#123;e.keyCode&#125;</span>&quot;]`</span>);</span><br></pre></td></tr></table></figure><h3 id="如何保证按键被按住不放时，可以马上响起连续鼓点声？"><a href="#如何保证按键被按住不放时，可以马上响起连续鼓点声？" class="headerlink" title="如何保证按键被按住不放时，可以马上响起连续鼓点声？"></a>如何保证按键被按住不放时，可以马上响起连续鼓点声？</h3><p>每次播放音频之前，设置播放时间戳为 0：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> audio = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;video&quot;</span>); </span><br><span class="line">audio.<span class="property">currentTime</span> = <span class="number">0</span>;</span><br><span class="line">audio.<span class="title function_">play</span>();</span><br></pre></td></tr></table></figure><h3 id="如何使页面按钮恢复原状？"><a href="#如何使页面按钮恢复原状？" class="headerlink" title="如何使页面按钮恢复原状？"></a>如何使页面按钮恢复原状？</h3><p>利用一个叫 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/transitionend"><code>transitionened</code></a> 的事件，它在 CSS transition 结束后会被触发。我们就可以利用这个事件，在每次打鼓的效果（尺寸变大、颜色变化）完成之后，去除相应样式。</p><p>在这个页面中，发生 <code>transition</code> 的样式属性不止一个（<code>box-shadow</code>, <code>transform</code>, <code>border-color</code>），所以需要添加一个判断语句，使每发生一次按键事件时，只去除一次样式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">funciton remove(event) &#123;</span><br><span class="line">  if (event.propertyName !== &#x27;border-left-color&#x27;) return;</span><br><span class="line">  this.classList.remove(&#x27;playing&#x27;);</span><br><span class="line">  // event.target.classList.remove(&#x27;playing&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 原生js项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>canvas 实现彩虹画笔绘画板</title>
      <link href="/2021/06/15/canvas-shi-xian-cai-hong-hua-bi-hui-hua-ban/"/>
      <url>/2021/06/15/canvas-shi-xian-cai-hong-hua-bi-hui-hua-ban/</url>
      
        <content type="html"><![CDATA[<h2 id="项目效果"><a href="#项目效果" class="headerlink" title="项目效果"></a>项目效果</h2><p><a href="https://v833.github.io/javscript-projects/01-Rainbow-brush-painting-board/">效果预览</a></p><h2 id="涉及特性"><a href="#涉及特性" class="headerlink" title="涉及特性"></a>涉及特性</h2><p>Canvas：</p><ul><li>模板骨架</li><li>基本属性<ul><li><code>getContext()</code></li><li><code>strokeStyle</code></li><li><code>fillStyle</code></li><li><code>fillRect</code></li><li><code>lineCap</code></li><li><code>lineJoin</code></li></ul></li><li>路径绘制<ul><li><code>beginPath()</code></li><li><code>lineTo()</code></li><li><code>moveTo()</code></li></ul></li></ul><p>鼠标事件处理：</p><ul><li><code>mousemove</code></li><li><code>mousedown</code></li><li><code>mouseup</code></li><li><code>mouseout</code></li></ul><h2 id="过程指南"><a href="#过程指南" class="headerlink" title="过程指南"></a>过程指南</h2><ol><li>获取 HTML 中的 <code>&lt;canvas&gt;</code> 元素，并设定宽度和高度</li><li><code>.getContext(&#39;2d&#39;)</code> 获取上下文，下面以 ctx 表示</li><li>设定 ctx 基本属性<ul><li>描边和线条颜色</li><li>线条宽度</li><li>线条末端形状</li></ul></li><li>绘画效果<ol><li>设定一个用于标记绘画状态的变量</li><li>鼠标事件监听，不同类型的事件将标记变量设为不同值</li><li>编写发生绘制时触发的函数，设定绘制路径起点、终点</li></ol></li><li>线条彩虹渐变效果（运用 hsl 的 <code>h</code> 值的变化，累加）</li><li>线条粗细渐变效果（设定一个范围，当超出这个范围时，线条粗细进行逆向改变</li></ol><h2 id="Canvas相关知识"><a href="#Canvas相关知识" class="headerlink" title="Canvas相关知识"></a>Canvas相关知识</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API">Canvas_API</a></p><h3 id="彩虹画笔绘画板简单介绍"><a href="#彩虹画笔绘画板简单介绍" class="headerlink" title="彩虹画笔绘画板简单介绍"></a>彩虹画笔绘画板简单介绍</h3><h4 id="一、-模板骨架"><a href="#一、-模板骨架" class="headerlink" title="一、 模板骨架"></a>一、 模板骨架</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML5 Canvas 实现彩虹画笔绘画板<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="selector-tag">canvas</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;150&quot;</span> <span class="attr">height</span>=<span class="string">&quot;150&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  &lt; script&gt;&lt;/ script&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>&lt; canvas&gt; 元素</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=<span class="string">&quot;canvas&quot;</span> width=<span class="string">&quot;150&quot;</span> height=<span class="string">&quot;150&quot;</span>&gt;&lt;/canvas&gt;</span><br></pre></td></tr></table></figure><p><code>canvas</code> 看起来和 <code>img</code> 元素很相像，唯一的不同就是它并没有 <code>src</code> 和<code>alt</code> 属性。实际上，<code>canvas</code> 标签只有两个属性——<code>width</code>和<code>height</code>。这些都是可选的，并且同样利用 <code>DOM properties</code> 来设置。当没有设置宽度和高度的时候，<code>canvas</code>会初始化宽度为<code>300</code>像素和高度为<code>150</code>像素。该元素可以使用CSS来定义大小，但在绘制时图像会伸缩以适应它的框架尺寸：如果CSS的尺寸与初始画布的比例不一致，它会出现扭曲。</p><ul><li>渲染上下文（The rendering context）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br></pre></td></tr></table></figure><p><code>canvas</code>元素创造了一个固定大小的画布，它公开了一个或多个渲染上下文，其可以用来绘制和处理要展示的内容。</p><p><code>canvas</code>起初是空白的。为了展示，首先脚本需要找到渲染上下文，然后在它的上面绘制。<code>canvas</code>元素有一个叫做 <code>getContext()</code> 的方法，这个方法是用来获得渲染上下文和它的绘画功能。<code>getContext()</code>只有一个参数，上下文的格式。对于2D图像而言，基本教程，你可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D">CanvasRenderingContext2D</a></p><h2 id="项目源码分析"><a href="#项目源码分析" class="headerlink" title="项目源码分析"></a>项目源码分析</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>实现彩虹画笔绘画板😊<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    * &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="attribute">margin</span>: <span class="number">0</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="attribute">padding</span>: <span class="number">0</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="selector-tag">canvas</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;800&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  &lt; script type=&quot;text/javascript&quot;&gt;</span></span><br><span class="line"><span class="language-xml">    // 获取canvas节点</span></span><br><span class="line"><span class="language-xml">    let canvas = document.querySelector(&#x27;#canvas&#x27;);</span></span><br><span class="line"><span class="language-xml">    let ctx = canvas.getContext(&quot;2d&quot;);</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    let colorDeg = 0;</span></span><br><span class="line"><span class="language-xml">    let lineWidth = 50;</span></span><br><span class="line"><span class="language-xml">    let direction = true;</span></span><br><span class="line"><span class="language-xml">    // hsl 色相(0 - 360) 饱和度 明度</span></span><br><span class="line"><span class="language-xml">    ctx.strokeStyle = `hsl($&#123;colorDeg&#125;, 90%, 50%)`;</span></span><br><span class="line"><span class="language-xml">    ctx.lineWidth = `$&#123;lineWidth&#125;`;</span></span><br><span class="line"><span class="language-xml">    ctx.lineCap = &#x27;round&#x27;;</span></span><br><span class="line"><span class="language-xml">    ctx.lineJoin = &#x27;round&#x27;;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    let drawing = false;</span></span><br><span class="line"><span class="language-xml">    let [x, y] = [0, 0]</span></span><br><span class="line"><span class="language-xml">    function draw(e) &#123;</span></span><br><span class="line"><span class="language-xml">      if (!drawing) return;</span></span><br><span class="line"><span class="language-xml">      ctx.beginPath();</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      // 控制笔触大小</span></span><br><span class="line"><span class="language-xml">      colorDeg = colorDeg &lt; 360 ? colorDeg + 1 : 0;</span></span><br><span class="line"><span class="language-xml">      if (lineWidth &gt; 50 || lineWidth &lt; 10) &#123;</span></span><br><span class="line"><span class="language-xml">        direction = !direction</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">      direction ? lineWidth++ : lineWidth--;</span></span><br><span class="line"><span class="language-xml">      ctx.lineWidth = `$&#123;lineWidth&#125;`;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      // 彩虹效</span></span><br><span class="line"><span class="language-xml">      ctx.strokeStyle = `hsl($&#123;colorDeg&#125;, 90%, 50%)`;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      // 控制绘制路径</span></span><br><span class="line"><span class="language-xml">      ctx.moveTo(x, y);</span></span><br><span class="line"><span class="language-xml">      console.log(x, y);</span></span><br><span class="line"><span class="language-xml">      ctx.lineTo(e.offsetX, e.offsetY);</span></span><br><span class="line"><span class="language-xml">      [x, y] = [e.offsetX, e.offsetY];</span></span><br><span class="line"><span class="language-xml">      ctx.stroke();</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">    canvas.addEventListener(&quot;mousedown&quot;, (e) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">      drawing = true;</span></span><br><span class="line"><span class="language-xml">      // 括号，方括号，正则开头的斜杠，加号，减号，反引号 作为行首的时候必须要加分号</span></span><br><span class="line"><span class="language-xml">      [x, y] = [e.offsetX, e.offsetY]</span></span><br><span class="line"><span class="language-xml">    &#125;);</span></span><br><span class="line"><span class="language-xml">    canvas.addEventListener(&#x27;mousemove&#x27;, draw)</span></span><br><span class="line"><span class="language-xml">    canvas.addEventListener(&#x27;mouseup&#x27;, () =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">      drawing = false</span></span><br><span class="line"><span class="language-xml">    &#125;);</span></span><br><span class="line"><span class="language-xml">    canvas.addEventListener(&#x27;mouseleave&#x27;, () =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">      drawing = false</span></span><br><span class="line"><span class="language-xml">    &#125;)</span></span><br><span class="line"><span class="language-xml">  &lt;/ script&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API">Canvas</a></p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul><li><code>lineCap</code>：笔触的形状，有 round | butt | square 圆、平、方三种。</li><li><code>lineJoin</code>：线条相交的样式，有 round | bevel | miter 圆交、斜交、斜接三种。</li><li><code>lineWidth</code>：线条的宽度</li><li><code>strokeStyle</code>：线条描边的颜色</li><li><code>fillStyle</code>：填充的颜色</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li><code>beginPath()</code>：新建一条路径</li><li><code>stroke()</code>：绘制轮廓</li><li><code>moveTo()</code>：（此次）绘制操作的起点</li><li><code>lineTo()</code>：路径的终点</li></ul><h3 id="彩虹渐变颜色——HSL"><a href="#彩虹渐变颜色——HSL" class="headerlink" title="彩虹渐变颜色——HSL"></a>彩虹渐变颜色——HSL</h3><p>在这个挑战中，涉及到改变线条的颜色，如何实现彩虹的渐变效果？我们需要利用 HSL 色彩模式，首先可以去这个网站 <a href="http://mothereffinghsl.com/">http://mothereffinghsl.com</a> 感受一下 HSL 不同色彩值对应的效果。</p><ul><li>H(hue) 代表色调，取值为 0~360，专业术语叫色相</li><li>S 是饱和度，可以理解为掺杂进去的灰度值，取值为 0~1</li><li>L 则是亮度，取值也是 0~1，或者百分比。</li></ul><p>这之中 H 值从 0 到 360 的变化代表了色相的角度的值域变化，利用这一点就可以实现绘制时线条颜色的渐变了，只需要在它的值超过 360 时恢复到 0 重新累加即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colorDeg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ctx.<span class="property">strokeStyle</span> = <span class="string">`hsl(<span class="subst">$&#123; colorDeg &#125;</span>, 90%, 50%)`</span>;</span><br><span class="line">colorDeg = colorDeg &lt; <span class="number">360</span> ? colorDeg + <span class="number">1</span> : <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>除此之外，如果想实现黑白水墨的颜色，可以将颜色设置为黑色，通过透明度的改变来实现深浅不一的颜色。</p><h3 id="控制笔触大小"><a href="#控制笔触大小" class="headerlink" title="控制笔触大小"></a>控制笔触大小</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//控制笔触大小</span></span><br><span class="line">     <span class="keyword">if</span> (lineWidth &gt; <span class="number">50</span> || lineWidth &lt; <span class="number">10</span>) &#123;</span><br><span class="line">       direction = !direction</span><br><span class="line">     &#125;</span><br><span class="line">     direction ? lineWidth++ : lineWidth--;</span><br><span class="line">     ctx.<span class="property">lineWidth</span> = <span class="string">`<span class="subst">$&#123;lineWidth&#125;</span>`</span>;</span><br></pre></td></tr></table></figure><p>上面的代码中，根据线条的宽度的变化来控制<code>direction</code>的值，根据<code>direction</code>的值来控制线宽是增加还是减少。</p><h3 id="控制线条路径"><a href="#控制线条路径" class="headerlink" title="控制线条路径"></a>控制线条路径</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 控制绘制路径</span></span><br><span class="line">ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">   ctx.<span class="title function_">moveTo</span>(x, y);</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">   ctx.<span class="title function_">lineTo</span>(e.<span class="property">offsetX</span>, e.<span class="property">offsetY</span>);</span><br><span class="line">   [x, y] = [e.<span class="property">offsetX</span>, e.<span class="property">offsetY</span>];</span><br><span class="line">   ctx.<span class="title function_">stroke</span>();</span><br></pre></td></tr></table></figure><h3 id="事件监听代码逻辑分析"><a href="#事件监听代码逻辑分析" class="headerlink" title="事件监听代码逻辑分析"></a>事件监听代码逻辑分析</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">canvas.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 开始绘图</span></span><br><span class="line"> drawing = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 绘图起始坐标初始化</span></span><br><span class="line"> [x, y] = [e.<span class="property">offsetX</span>, e.<span class="property">offsetY</span>]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标移动时，调用draw方法</span></span><br><span class="line">canvas.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, draw);</span><br><span class="line"><span class="comment">// 鼠标抬起时，将drawing置为false</span></span><br><span class="line">canvas.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseup&#x27;</span>, <span class="function">() =&gt;</span> drawing = <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 当鼠标不在可绘图区域范围内时，将drawing置为false</span></span><br><span class="line">canvas.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseout&#x27;</span>, <span class="function">() =&gt;</span> drawing = <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 原生js项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解 ES6 的 Map 数据结构</title>
      <link href="/2021/06/14/li-jie-es6-de-map-shu-ju-jie-gou/"/>
      <url>/2021/06/14/li-jie-es6-de-map-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h2 class="bamboo-h " id="Map">Map</h2><br/><p>ES6 新增了一种数据结构 Map，与传统的对象字面量类似，它的本质是一种<strong>键值对的组合</strong>。但是与对象字面量不同的是，对象字面量的键只能是<strong>字符串</strong>，对于非字符串类型的值会采用强制类型转换成字符串，而 Map 的键却可以由各种类型的值组成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统的对象类型</span></span><br><span class="line"><span class="keyword">let</span> xx = &#123;<span class="attr">name</span>: <span class="string">&#x27;xx&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj[xx] = <span class="string">&#x27;123&#x27;</span> <span class="comment">// &#123;[object Object]: &quot;123&quot;&#125;</span></span><br><span class="line"><span class="title function_">alert</span>( obj[<span class="string">&quot;[object Object]&quot;</span>] ) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>在上面案例中，采用的是传统的对象处理方式，我们将对一个对象作为对象的键，在输出时会将所有的键如 xx  转换为字符串。所以我们得到字符串键 “[object Object]”。这显然不是我们想要的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xx = &#123;<span class="attr">name</span>: <span class="string">&#x27;xx&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map.<span class="title function_">set</span>(xx, <span class="number">123</span>) <span class="comment">// Map(1) &#123;&#123;…&#125; =&gt; 123&#125;</span></span><br><span class="line"><span class="title function_">alert</span>( map.<span class="title function_">get</span>(xx) ) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>使用 Map 处理方法，将一个对象作为键添加到 map 实例中，在输出时发现，键的值为对象的真实值，并没有转换成字符串。</p><p>当创建一个 Map 后，我们可以传入一个带有键值对的数组（或其它可迭代对象）来进行初始化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;xx&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;age&#x27;</span>, <span class="number">23</span>]</span><br><span class="line">])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map) <span class="comment">// Map(2) &#123;&quot;name&quot; =&gt; &quot;xx&quot;, &quot;age&quot; =&gt; 23&#125;</span></span><br></pre></td></tr></table></figure><h2 class="bamboo-h " id="Map 的属性和方法">Map 的属性和方法</h2><br/><ul><li>new Map() —— 创建 map。</li><li>map.set(key, value) —— 根据键存储值。</li><li>map.get(key) —— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined。</li><li>map.has(key) —— 如果 key 存在则返回 true，否则返回 false。</li><li>map.delete(key) —— 删除指定键的值。</li><li>map.clear() —— 清空 map。</li><li>map.size —— 返回当前元素个数。<blockquote><p>map[key] 不是使用 Map 的正确方式</p><p>虽然 map[key] 也有效，例如我们可以设置 map[key] = 23，这样会将 map 视为 JavaScript 的 plainobject，因此它暗含了所有相应的限制（没有对象键等）。<br>所以我们应该使用 map 方法：set 和 get 等。</p></blockquote></li></ul><p>在 Map 数据结构中，所有的键都必须具有<strong>唯一性</strong>。如果对同一个键进行多次赋值，那么后面的值会覆盖前面的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;aa&#x27;</span>)</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;bb&#x27;</span>)</span><br><span class="line">map.<span class="title function_">get</span>(<span class="number">1</span>) <span class="comment">// &#x27;bb&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>Map 是怎么比较键的？</p><p>Map 使用 SameValueZero 算法来比较键是否相等。它和严格等于 === 差不多，但区别是 NaN 被看成是等于 NaN。所以 NaN 也可以被用作键。</p></blockquote><blockquote><p>链式调用</p><p>每一次 map.set 调用都会返回 map 本身，所以我们可以进行“链式”调用：</p><p>map.set(‘name’, ‘xx1’).set(‘age’, 23)</p></blockquote><h2 class="bamboo-h " id="Map 的遍历">Map 的遍历</h2><br/><ul><li>map.keys() —— 遍历并返回所有的键，</li><li>map.values() —— 遍历并返回所有的值，</li><li>map.entries() —— 遍历并返回所有的实体[key, value]，<strong>for..of 在默认情况下使用的就是这个</strong>，</li><li>map.forEach(item, key) —— 第一个参数表示值，第二个参数表示键。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;xx&#x27;</span>)</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;age&#x27;</span>, <span class="number">23</span>)</span><br><span class="line"></span><br><span class="line">map.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value, key); </span><br><span class="line">  <span class="comment">// xx name </span></span><br><span class="line">  <span class="comment">// 23 age</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">  <span class="comment">// name</span></span><br><span class="line">  <span class="comment">// age</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">  <span class="comment">// xx</span></span><br><span class="line">  <span class="comment">// 23</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">    <span class="comment">// name xx</span></span><br><span class="line">    <span class="comment">// age 23</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>map.entries === map[Symbol.iterator]</p></blockquote><blockquote><p>使用插入顺序</p><p>迭代的顺序与插入值的顺序相同。与普通的 Object 不同，Map 保留了此顺序。</p></blockquote><h2 class="bamboo-h " id="Map 与其他数据类型的转换">Map 与其他数据类型的转换</h2><br/><h3 class="bamboo-h warning" id="数组转换成 Map">数组转换成 Map</h3><br/><p>数组转换成 Map，可以通过 Map 构造函数实现，使用 new 操作符生成 Map 实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;xx&#x27;</span>], [<span class="string">&#x27;age&#x27;</span>, <span class="number">23</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(arr)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map) <span class="comment">// Map(2) &#123;&quot;name&quot; =&gt; &quot;xx&quot;, &quot;age&quot; =&gt; 23&#125;</span></span><br></pre></td></tr></table></figure><h3 class="bamboo-h warning" id="Map 转换成数组">Map 转换成数组</h3><br/><p>Map 转换成数组，可以通过扩展运算符实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;xx&#x27;</span>)</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;age&#x27;</span>, <span class="number">23</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [...map]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">// (2) [Array(2), Array(2)]</span></span><br></pre></td></tr></table></figure><h3 class="bamboo-h warning" id="对象转换成 Map">对象转换成 Map</h3><br/><p>如果我们想从一个已有的普通对象来创建一个 Map，那么我们可以使用内建方法 Object.entries(obj)，该方法返回对象的键/值对数组，该数组格式完全按照 Map 所需的格式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;xx&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;age&#x27;</span>: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map) <span class="comment">// Map(2) &#123;&quot;name&quot; =&gt; &quot;xx&quot;, &quot;age&quot; =&gt; 23&#125;</span></span><br></pre></td></tr></table></figure><h3 class="bamboo-h warning" id="Map 转换成对象">Map 转换成对象</h3><br/><p>我们刚刚已经学习了如何使用 Object.entries(obj) 从普通对象创建 Map。</p><p>Object.fromEntries 方法的作用是相反的：给定一个具有 [key, value] 键值对的数组，它会根据给定数组创建一个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&#x27;xx&#x27;</span>)</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;age&quot;</span>, <span class="number">23</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(map)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// &#123;name: &quot;xx&quot;, age: 23&#125;</span></span><br></pre></td></tr></table></figure><h3 class="bamboo-h warning" id="Map 转换成 Json">Map 转换成 Json</h3><br/><h4 class="bamboo-h red" id="当 Map 的键名都是字符串">当 Map 的键名都是字符串</h4><br/><p>当 Map 的键名都是字符串时，可以先将 Map 转换成对象，然后调用JSON.stringify()函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&#x27;xx&#x27;</span>).<span class="title function_">set</span>(<span class="string">&quot;age&quot;</span>, <span class="number">23</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> json = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(map))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(json) <span class="comment">//&#123;&quot;name&quot;:&quot;xx&quot;,&quot;age&quot;:23&#125;</span></span><br></pre></td></tr></table></figure><h4 class="bamboo-h red" id="当 Map 的键名有非字符串">当 Map 的键名有非字符串</h4><br/><p>当 Map 的键名有非字符串时，我们可以先将 Map 转换成数组，然后调用JSON.stringify()函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map.<span class="title function_">set</span>(&#123;<span class="attr">fn</span>: <span class="string">&#x27;foo&#x27;</span>&#125;, <span class="string">&#x27;xx&#x27;</span>).<span class="title function_">set</span>(<span class="literal">true</span>, <span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> json = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>([...map])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(json) <span class="comment">// [[&#123;&quot;fn&quot;:&quot;foo&quot;&#125;,&quot;xx&quot;],[true,&quot;abc&quot;]]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Flexbox Froggy 游戏中搞定flex布局</title>
      <link href="/2021/06/13/zai-flexbox-froggy-you-xi-zhong-gao-ding-flex-bu-ju/"/>
      <url>/2021/06/13/zai-flexbox-froggy-you-xi-zhong-gao-ding-flex-bu-ju/</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>最近发现了一款学习flex布局的游戏,分享给大家 =&gt; <a href="http://flexboxfroggy.com/">Flexbox Froggy</a></p></div><p class='p primary'>一共 24 关</p><h2 class="bamboo-h " id="附上参考答案">附上参考答案</h2><br/><div class="note success"><p>1、justify-content: flex-end</p></div><div class="note success"><p>2、justify-content: center</p></div><div class="note success"><p>3、justify-content: space-around</p></div><div class="note success"><p>4、justify-content: space-between</p></div><div class="note success"><p>5、align-items: flex-end</p></div><div class="note success"><p>6、justify-content: center;</br> &nbsp; &nbsp;&nbsp; align-items: center</p></div><div class="note success"><p>7、justify-content: space-around;</br>&nbsp; &nbsp;&nbsp;&nbsp;align-items: flex-end</p></div><div class="note success"><p>8、flex-direction: row-reverse</p></div><div class="note success"><p>9、flex-direction: column</p></div><div class="note success"><p>10、flex-direction: row-reverse;</br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; justify-content: flex-end</p></div><div class="note success"><p>11、flex-direction: column;</br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; justify-content: flex-end</p></div><div class="note success"><p>12、flex-direction: column-reverse;</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; justify-content: space-between</p></div><div class="note success"><p>13、flex-direction: row-reverse;</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; justify-content: center;</br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; align-items: flex-end</p></div><div class="note success"><p>14、order: 1</p></div><div class="note success"><p>15、order: -1</p></div><div class="note success"><p>16、align-self: flex-end</p></div><div class="note success"><p>17、order: 1;</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; align-self: flex-end</p></div><div class="note success"><p>18、flex-wrap: wrap;</p></div><div class="note success"><p>19、flex-direction: column;</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flex-wrap: wrap</p></div><div class="note success"><p>20、flex-flow: column wrap</p></div><div class="note success"><p>21、align-content: flex-start</p></div><div class="note success"><p>22、align-content: flex-end</p></div><div class="note success"><p>23、flex-direction: column-reverse;</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; align-content: center</p></div><div class="note success"><p>24、flex-flow: column-reverse wrap-reverse;</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; justify-content: center;</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; align-content: space-between</p></div><h2 class="bamboo-h " id="总结">总结</h2><br/><blockquote><p>Flex 布局原理就是：给父盒子添加 flex 属性，来控制子盒子的位置排列方式从而实现 flex 布局。<br>当我们为父盒子设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</p></blockquote><h3 class="bamboo-h warning" id="flex-direction">flex-direction</h3><br/><p>Flex 布局中默认的主轴是 row，x轴。</p><p>如果想改变主轴方向可通过设置 flex-direction 来改变。</p><p>flex-direction:column;将主轴改为y轴，纵轴。</p><p>flex-direction:row; 将主轴改为x轴，横轴。</p><p>flex-direction:row- reverse;主轴为x轴，<strong>并且翻转</strong>。</p><p>flex-direction:column- reverse;主轴为y轴，<strong>并且翻转</strong>。</p><h3 class="bamboo-h warning" id="justify-content">justify-content</h3><br/><p>通过 justify-content 能够设置主轴子元素排列形式。</p><p>值为 flex-start 所有子元素在主轴头部显示。</p><p>值为 flex-end 所有子元素在主轴尾部显示。</p><p>值为 flex-center 所有子元素在主轴居中对齐。</p><p>值为 space-around 所有子元素平分剩余空间。</p><p>值为 space-between 所有子元素先两边贴边在平分剩余空间。</p><h3 class="bamboo-h warning" id="flex-wrap">flex-wrap</h3><br/><p>flex-wrap<br>控制子元素是否换行。</p><p>开启 flex 布局后默认为不换行。</p><p>如果想要换行效果设置 flex-wrap：wrap。</p><h3 class="bamboo-h warning" id="align-items">align-items</h3><br/><p>align-items 设置侧轴子元素排列。</p><p>利用align-items 能够设置侧轴元素对齐的方式在子项为单项（单行）的时候使用。</p><p>align-items 的值为flex-start 表示从头开始。</p><p>align-items 的值为flex-end 表示从结尾开始。</p><p>align-items 的值为center 表示居中显示。</p><p>align-items 的值为stretch 会将子元素拉伸。</p><h3 class="bamboo-h warning" id="align-content">align-content</h3><br/><p>align-content 设置侧轴子元素排列。</p><p> Align-content 适应于换行（多行）的情况下（单行情况下无效），可以设置上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值。</p><p> Align-item 和 align-content 的区别单行找 align-items 多行找 align-content。</p><h3 class="bamboo-h warning" id="flex-flow">flex-flow</h3><br/><p> flex-flow 就是 flex-direction 和 flex-wrap 的合写。</p><h3 class="bamboo-h warning" id="order">order</h3><br/><p>order是设置在items里面的属性,具体作用是可以决定本身的排列先后顺序。</p><p>子元素可以通过设置 order 数值的大小来设定在页面中出现的顺序，数值小的在前，数值大的在后。</p><h3 class="bamboo-h warning" id="align-self">align-self</h3><br/><p>align-self 属性定义 flex 子项单独在侧轴（纵轴）方向上的对齐方式，并覆盖已有的 align-items 的值。</p><p>此属性接受与align-items特定项目的值相同的值。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-mall 商城项目</title>
      <link href="/2021/06/12/vue-mall/"/>
      <url>/2021/06/12/vue-mall/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/v833/vue-mall">vue-mall项目地址</a> </p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>项目以Vue全家桶作为主要的技术体系，开发网页和交互功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create &#x27;xxx&#x27; // 初始化项目</span><br></pre></td></tr></table></figure><h3 id="前端跨域解决方案"><a href="#前端跨域解决方案" class="headerlink" title="前端跨域解决方案"></a>前端跨域解决方案</h3><p>跨域是浏览器为了安全做出的限制策略。</p><p>浏览器必须请求同源策略：同域名、同协议、同端口</p><h4 id="CORS跨域"><a href="#CORS跨域" class="headerlink" title="CORS跨域"></a>CORS跨域</h4><p>服务端设置，前端直接调用</p><p>说明：后台允许前端某个站点进行访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">App.vue</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import axios from &#x27;axios&#x27;</span><br></pre></td></tr></table></figure><p>Access-Control-Allow-Credentials: true // 前端跨域发送cookie</p><h4 id="JSONP跨域"><a href="#JSONP跨域" class="headerlink" title="JSONP跨域"></a>JSONP跨域</h4><p>jsonp跨域，前端适配，后台配合 // 前端发callback</p><p>说明：前后台同时改造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jsonp (url, () =&gt; &#123;&#125;) // js 文件</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      let url = &#x27;https://www.imooc.com/search/hotwords&#x27;;</span><br><span class="line">      jsonp(url, (err,res) =&gt; &#123;</span><br><span class="line">        this.data = res</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h4 id="代理跨域"><a href="#代理跨域" class="headerlink" title="代理跨域"></a>代理跨域</h4><p>接口代理-通过修改nginx服务器配置来实现</p><p>说明：前端修改，后台不动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  host:&#x27;localhost&#x27;,</span><br><span class="line">  port: 8082,</span><br><span class="line">  proxy: &#123;</span><br><span class="line">    // /search/hotwords</span><br><span class="line">    &#x27;/api&#x27;: &#123;</span><br><span class="line">      target: &#x27;https://www.imooc.com/&#x27;,</span><br><span class="line">      changeOrigin: true,</span><br><span class="line">      pathRewrite: &#123;</span><br><span class="line">        &#x27;/api&#x27;: &#x27;&#x27; // 将接口设置为空</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="需求梳理"><a href="#需求梳理" class="headerlink" title="需求梳理"></a>需求梳理</h3><p>熟悉文档，查看原型、读懂需求</p><p>了解前端设计稿-设计前端业务架构</p><p>了解后台接口文档-指定相关对接规范</p><p>协调资源</p><p>搭建前端框架</p><h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><p>建议大图片放在public， 小图片放在assets (base64)</p><h3 id="路由封装"><a href="#路由封装" class="headerlink" title="路由封装"></a>路由封装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/&#x27;,</span><br><span class="line">    name: &#x27;home&#x27;,</span><br><span class="line">    component: Home,</span><br><span class="line">    redirect: &#x27;/index&#x27;,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#x27;index&#x27;,</span><br><span class="line">        name: &#x27;index&#x27;,</span><br><span class="line">        component: Index</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#x27;product/:id&#x27;,</span><br><span class="line">        name: &#x27;product&#x27;,</span><br><span class="line">        component: Product</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#x27;detail/:id&#x27;,</span><br><span class="line">        name: &#x27;detail&#x27;,</span><br><span class="line">        component: Detail</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="Storage-封装"><a href="#Storage-封装" class="headerlink" title="Storage 封装"></a>Storage 封装</h3><h5 id="Cookie、localStorage、sessionStorage-三者区别？"><a href="#Cookie、localStorage、sessionStorage-三者区别？" class="headerlink" title="Cookie、localStorage、sessionStorage 三者区别？"></a>Cookie、localStorage、sessionStorage 三者区别？</h5><p>都是缓存技术</p><p>存储大小：Cookie 4K、Storage 5M</p><p>有效期：Cookie 拥有有效期、Storage 永久存储 (localStorage)</p><p>Cookie 会发送到服务端，存储在内存中，Storage 只存储在浏览器端</p><p>路径：Cookie 有路径限制，Storage 只存储在域名下</p><p>API：Cookie 没有特定的API，Storage 有特定的API</p><p>document.cookie setItem() localStorag.getItem</p><h5 id="为什么要封装Storage，本身已经是API？"><a href="#为什么要封装Storage，本身已经是API？" class="headerlink" title="为什么要封装Storage，本身已经是API？"></a>为什么要封装Storage，本身已经是API？</h5><p>Storage 本身有API，但是只是简单的key/value 形式</p><p>Storage 只存储字符串，需要人工传换成json对象</p><p>Storage 只能一次性清空，不能单个清空</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// storage 封装</span><br><span class="line"></span><br><span class="line">const STORAGE_KEY = &#x27;mall&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  // 存储值</span><br><span class="line">  setItem (key, value, module_name) &#123;</span><br><span class="line">    if (module_name) &#123;</span><br><span class="line">      let val = this.getItem(module_name)</span><br><span class="line">      val[key] = value</span><br><span class="line">      this.setItem(module_name, val)</span><br><span class="line">    &#125;</span><br><span class="line">    let val = this.getStorage();</span><br><span class="line">    val[key] = value</span><br><span class="line">    window.sessionStorage.setItem(STORAGE_KEY, JSON.stringify(val))</span><br><span class="line">  &#125;,</span><br><span class="line">  // 获取某一个模块下面的属性</span><br><span class="line">  getItem (key, module_name) &#123;</span><br><span class="line">    if (module_name) &#123;</span><br><span class="line">      let val = this.getItem(module_name)</span><br><span class="line">      if (val) return val[key]</span><br><span class="line">    &#125;</span><br><span class="line">    return this.getStorage()[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  // 获取整个数据</span><br><span class="line">  getStorage () &#123;</span><br><span class="line">    return JSON.parse(window.sessionStorage.getItem(STORAGE_KEY) || &#x27;&#123;&#125;&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 清空</span><br><span class="line">  clear (key, module_name) &#123;</span><br><span class="line">    let val = this.getStorage()</span><br><span class="line">    if (module_name) &#123;</span><br><span class="line">      delete val[module_name][key]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      delete val[key]</span><br><span class="line">    &#125;</span><br><span class="line">    window.sessionStorage.setItem(STORAGE_KEY, JSON.stringify(val))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口错误拦截"><a href="#接口错误拦截" class="headerlink" title="接口错误拦截"></a>接口错误拦截</h3><p>统一报错</p><p>未登录统一拦截</p><p>请求值、返回值统一处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios 传参 get 加params post 不加</span><br><span class="line"></span><br><span class="line">同时发多个请求？ axios.all([]).then()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">main.js</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">import router from &#x27;./router&#x27;</span><br><span class="line">import store from &#x27;./store&#x27;</span><br><span class="line">import axios from &#x27;axios&#x27; // 每个页面都要去写，导入</span><br><span class="line">import VueAxios from &#x27;vue-axios&#x27; // 作用域对象挂载在vue实例上</span><br><span class="line"></span><br><span class="line">// 根据前端的跨域方式做调整 (接口代理除外)</span><br><span class="line">axios.defaults.baseURL = &#x27;/api&#x27;</span><br><span class="line"></span><br><span class="line">axios.defaults.timeout = 8000; // 超时时间</span><br><span class="line"></span><br><span class="line">// 接口错误拦截</span><br><span class="line">axios.interceptors.response.use(function (response) &#123;</span><br><span class="line">  let res = response.data;</span><br><span class="line">  if (res.status == 0) &#123; // 成功</span><br><span class="line">    return res.data</span><br><span class="line">  &#125; else if (res.status == 10) &#123; // 未登录 自定义状态码</span><br><span class="line">    window.location.href = &#x27;/#/login&#x27;</span><br><span class="line">    // 路由是挂载在vue实例中 这里是js文件 不能用路由跳转</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    alert (res.msg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.use(VueAxios, axios)</span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure><h3 id="接口环境配置"><a href="#接口环境配置" class="headerlink" title="接口环境配置"></a>接口环境配置</h3><p>开发上线的不同阶段，需要不同的配置</p><p>不同的跨域方式，配置不同</p><p>打包的时候统一注入环境参数，统一管理环境，输出不同的版本包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;serve&quot;: &quot;vue-cli-service serve --mode=development&quot;, // 注入参数，把环境变量传给mode</span><br><span class="line">&quot;build&quot;: &quot;vue-cli-service build --mode=production&quot;,</span><br><span class="line">&quot;test&quot;: &quot;vue-cli-service test --mode=test&quot;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">env.js</span><br><span class="line">let baseURL; // 用cors 和 jsons 使用</span><br><span class="line">switch (process.env.NODE_ENV) &#123; // nodejs 的环境变量</span><br><span class="line">  case &#x27;development&#x27;:</span><br><span class="line">    baseURL = &#x27;http://dev-mall-pre.springboot.cn/api&#x27;</span><br><span class="line">    break;</span><br><span class="line">  case &#x27;test&#x27;: // 不能随便书写 需要写一个.env.(name) 文件 配置NODE_ENV = &#x27;name&#x27;</span><br><span class="line">    baseURL = &#x27;http://test-mall-pre.springboot.cn/api&#x27;</span><br><span class="line">    break;</span><br><span class="line">  case &#x27;production&#x27;:</span><br><span class="line">    baseURL = &#x27;http://mall-pre.springboot.cn/api&#x27;</span><br><span class="line">    break;</span><br><span class="line">    default:</span><br><span class="line">    baseURL = &#x27;http://mall-pre.springboot.cn/api&#x27;</span><br><span class="line">    break</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  baseURL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mock-设置"><a href="#Mock-设置" class="headerlink" title="Mock 设置"></a>Mock 设置</h3><p>开发阶段，为了高效率，需要提前Mock</p><p>减少代码冗余，灵活拔插</p><p>减少沟通，减少接口联调时间</p><h5 id="三种方案"><a href="#三种方案" class="headerlink" title="三种方案:"></a>三种方案:</h5><p>1、本地创建json</p><p>2、easy-mock 平台</p><p>3、集成Mock API</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">json</span><br><span class="line">mounted() &#123;</span><br><span class="line">// 本地加载请求静态json</span><br><span class="line">   this.axios.get(&#x27;/mock/user/login.json&#x27;).then(res =&gt; &#123;</span><br><span class="line">     this.res = res // localhost:8080 =&gt; 默认在 public 下导入 根目录</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">集成Mock API</span><br><span class="line">main.js</span><br><span class="line">const mock = true;// 希望mock开关打开时被拦截，用require而不是import</span><br><span class="line">// import 预编译加载 require 执行加载，如果未需要，不加载</span><br><span class="line">if (mock) &#123;require(&#x27;./mock/api&#x27;)&#125;</span><br><span class="line"></span><br><span class="line">api.js</span><br><span class="line">import Mock from &#x27;mockjs&#x27;</span><br><span class="line">Mock.mock(&#x27;/api/user/login&#x27;, data)</span><br><span class="line">// 本地集成mockjs实现数据mock 没有发送真正的请求，代码阶段拦截 </span><br></pre></td></tr></table></figure><h3 id="nav-header"><a href="#nav-header" class="headerlink" title="nav-header"></a>nav-header</h3><p>给网站设置最小宽度 min-weight</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">安装sass</span><br><span class="line">npm config set registry=&quot;https://registry.npmjs.org/&quot;</span><br><span class="line">registry = &quot;https://registry.npm.taobao.org/&quot;</span><br><span class="line">$ set SASS_BINARY_SITE=http://npm.taobao.org/mirrors/node-sass&amp;&amp;npm i node-sass</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">导入sass</span><br><span class="line">@import &#x27;./assets/sass/reset.scss&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">          a &#123;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            width: 110px;</span><br><span class="line">            height: 55px;</span><br><span class="line">            border: 1px solid red;</span><br><span class="line">            &amp;:before &#123; // sass 给a加伪类</span><br><span class="line">              </span><br><span class="line">            &#125;</span><br><span class="line">            cursor: pointer</span><br><span class="line">            设置背景图片</span><br><span class="line">            background: url() no-repeat center;</span><br><span class="line">            background-size: contain</span><br><span class="line">            </span><br><span class="line">&lt;input  autocomplete=&quot;off&quot;/&gt; // 历史搜索</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// flex 布局复用</span><br><span class="line">@mixin flex ($hov:space-between, $col: center) &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: $hov;</span><br><span class="line">  align-items: $col;</span><br><span class="line">&#125;</span><br><span class="line">使用</span><br><span class="line">@include flex();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@mixin bgImg ($w: 0, $h: 0, $img: &#x27;&#x27;, $size: contain) &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: $w;</span><br><span class="line">  height: $h;</span><br><span class="line">  background: url($img) no-repeat center;</span><br><span class="line">  background-size: $size;</span><br><span class="line">  margin-right: 4px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a target=&quot;_blank&quot;&gt;&lt;/a&gt; // 新页面打开</span><br><span class="line">图片一般自适应展开，要么定义高度，要么定义宽度</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">过滤器</span><br><span class="line">  filters: &#123;</span><br><span class="line">    currency (val) &#123;</span><br><span class="line">      if (!val) return &#x27;0.00&#x27;;</span><br><span class="line">      return &#x27;￥&#x27; + val.toFixed(2) + &#x27;元&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  &#123;&#123;item.price | currency&#125;&#125; // 使用</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">路由跳转 $router.push()</span><br><span class="line">路由取参：$router.params 或者 $router.query</span><br></pre></td></tr></table></figure><h3 id="首页轮播"><a href="#首页轮播" class="headerlink" title="首页轮播"></a>首页轮播</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install --save vue-awesome-swiper@3.1.3 </span><br><span class="line">对应swiper 4</span><br><span class="line"></span><br><span class="line">import &#123; swiper, swiperSlide&#125; from &#x27;vue-awesome-swiper&#x27; // swiper组件很大，按需加载</span><br><span class="line">import &#x27;swiper/dist/css/swiper.css&#x27;</span><br><span class="line"></span><br><span class="line">2 报错  Error in render: &quot;TypeError: Cannot set property &#x27;params&#x27; of undefined&quot;  ---跟版本号有关系，4.0 版本首字母大写，3.0版本，首字母小写。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;swiper :options=&quot;swiperOption&quot;&gt;</span><br><span class="line">  &lt;swiper-slide v-for=&quot;(item, index) in slideList&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">    &lt;a href=&quot;&#x27;/#/product/&#x27; + item.id&quot;&gt;&lt;img :src=&quot;item.img&quot;&gt;&lt;/a&gt;</span><br><span class="line">  &lt;/swiper-slide&gt;</span><br><span class="line">&lt;/swiper&gt;</span><br><span class="line">分页器</span><br><span class="line">  &lt;div class=&quot;swiper-pagination&quot;  slot=&quot;pagination&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;swiper-button-prev&quot; slot=&quot;button-prev&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;swiper-button-next&quot; slot=&quot;button-next&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;swiper-scrollbar&quot;   slot=&quot;scrollbar&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">swiperOption: &#123;</span><br><span class="line">  autoplay: true,</span><br><span class="line">  // 循环播放</span><br><span class="line">  loop: true,</span><br><span class="line">  // 切换效果</span><br><span class="line">  effect: &#x27;cube&#x27;,</span><br><span class="line">  slidesPerView: 3,  // 显示的数目</span><br><span class="line">spaceBetween: 30,  // 元素之间的距离</span><br><span class="line">  pagination: &#123;</span><br><span class="line">    el: &#x27;.swiper-pagination&#x27;,</span><br><span class="line">    // 点击分页器切换</span><br><span class="line">    clickable :true,</span><br><span class="line">  &#125;,</span><br><span class="line">  navigation: &#123;</span><br><span class="line">    nextEl: &#x27;.swiper-button-next&#x27;,</span><br><span class="line">    prevEl: &#x27;.swiper-button-prev&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">opacity 会把内容全部加透明度</span><br><span class="line">rgba 内容不会有透明度</span><br></pre></td></tr></table></figure><p>可以用二维数组实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;children&quot;&gt;</span><br><span class="line">            &lt;ul v-for=&quot;(item, index1) in menuList&quot; :key=&quot;index1&quot;&gt;</span><br><span class="line">              &lt;li v-for=&quot;(sub, index) in item&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">                &lt;a :href=&quot;sub ? &#x27;/#/product/&#x27; + sub.id : &#x27;&#x27; &quot;&gt;</span><br><span class="line">                  &lt;img :src=&quot;sub ? sub.img : &#x27;/imgs/item-box-1.png&#x27;&quot; alt=&quot;&quot;&gt;</span><br><span class="line">                  &#123;&#123;sub ? sub.name : &#x27;小米9&#x27;&#125;&#125;</span><br><span class="line">                &lt;/a&gt;</span><br><span class="line">              &lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">          &lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.phoneList = [res.list.slice(0, 4), res.list.slice(4, 8)] // 赋值</span><br></pre></td></tr></table></figure><h3 id="modal组件-transition"><a href="#modal组件-transition" class="headerlink" title="modal组件(transition)"></a>modal组件(transition)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  // 弹框类型: 小框，中框，大框，表单</span><br><span class="line">  modalType: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    default: &#x27;form&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  title: String,</span><br><span class="line">  btnType: String, // 按钮类型： 1.确定按钮 2.取消按钮 3.确定取消按钮</span><br><span class="line">  sureText: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    default: &#x27;确定&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  cancelText: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    default: &#x27;取消&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  showModal: Boolean</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@mixin position($pos, $top, $left, $w, $h) &#123;</span><br><span class="line">  position: $pos;</span><br><span class="line">  top: $top;</span><br><span class="line">  left: $left;</span><br><span class="line">  width: $w;</span><br><span class="line">  height: $h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transition </span><br><span class="line">样式先定义 -active 因为样式会覆盖</span><br></pre></td></tr></table></figure><h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-lazyload -S</span><br><span class="line"></span><br><span class="line">import VueLazyLoad from &#x27;vue-lazyload&#x27;</span><br><span class="line">Vue.use(VueLazyLoad, &#123;</span><br><span class="line">  loading: &#x27;/imgs/loading-svg/loading-bars.svg&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;item.img&quot; alt=&quot;&quot;&gt; =&gt; &lt;img v-lazy=&quot;item.img&quot; alt=&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">// 注意，指令里面的是变量</span><br><span class="line">&lt;img v-lazy=&quot;&#x27;/imgs/banner-1.png&#x27;&quot; alt=&quot;&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="登录交互"><a href="#登录交互" class="headerlink" title="登录交互"></a>登录交互</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  methods: &#123;</span><br><span class="line">    login () &#123;</span><br><span class="line">      let &#123;username, password&#125; = this // 数据绑定在this上</span><br><span class="line">      this.axios.post(&#x27;/user/login&#x27; &#123;username, password&#125;).then(res =&gt; ...)</span><br><span class="line">      this.$cookie.set(&#x27;userId&#x27;, res.id, &#123; expires:&#x27;1M&#x27; &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">main.js</span><br><span class="line">Vue.use(VueCookie) // 保存token</span><br><span class="line"></span><br><span class="line">单页面应用，刷新会丢失数据，需要在App.vue中重新拉取</span><br><span class="line">Cookie: JSESSIONID=25E86D07E1B121DB1C6B38ECCF6CCADA; userId=2840</span><br><span class="line">// java写的</span><br></pre></td></tr></table></figure><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>vue 中数据是单项流通的，如果 A 与 B 之间没有任何关系，而A想用B的变量。兄弟组件传递数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vuex state 中的数据不具有响应式， state中的数据发生变化，不会主动通知调用该数据的对象，我们可以用computed监听数据</span><br></pre></td></tr></table></figure><h3 id="产品站参数"><a href="#产品站参数" class="headerlink" title="产品站参数"></a>产品站参数</h3><h4 id="吸顶功能"><a href="#吸顶功能" class="headerlink" title="吸顶功能"></a>吸顶功能</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">  window.addEventListener(&#x27;scroll&#x27;, this.initHeight) // 方法抽离出来，为了移除事件使用，使用function() 事件在组件销毁时不会移除</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">data () &#123;</span><br><span class="line">return &#123;</span><br><span class="line">  isFixed: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">  window.addEventListener(&#x27;scroll&#x27;, this.initHeight)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  initHeight () &#123;</span><br><span class="line">    let scrollTop = window.scrollY || document.documentElement.scrollTop || document.scrollTop; // 兼容浏览器</span><br><span class="line">    console.log(scrollTop);</span><br><span class="line">    this.isFixed = scrollTop &gt; 152</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> destroyed() &#123;</span><br><span class="line">  window.removeEventListener(&#x27;scroll&#x27;, this.initHeight, false)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box-shadow:X轴偏移量、Y轴偏移量、模糊半径、扩散半径和颜色。</span><br></pre></td></tr></table></figure><h3 id="video"><a href="#video" class="headerlink" title="video"></a>video</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt; // 遮罩</span><br><span class="line">&lt;video src=&quot;/imgs/product/video.mp4&quot; muted autoplay controls=&quot;controls&quot;&gt;&lt;/video&gt;</span><br><span class="line">设置自动播放 需要先数值muted    loop</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object-fit:cover // 类似backgroundimg 这个CSS属性可以达到最佳最完美的居中自动剪裁图片的功能。</span><br><span class="line">background-size只能作用于有背景图的，</span><br><span class="line">object-fit可以作用于类似 img, video等的标签。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">closeVideo () &#123;</span><br><span class="line">  this.showSlide = &#x27;slideUp&#x27;;</span><br><span class="line">  setTimeout (() =&gt; &#123;</span><br><span class="line">    this.showSlide = false</span><br><span class="line">  &#125;, 600)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.router是VueRouter的一个对象,通过Vue.use(VueRouter)和VueRouter构造函数得到一个router的实例对象,这个对象中是一个全局的对象,他包含了所有的路由包含了许多关键的...</span><br><span class="line">2.route是一个跳转的路由对象,每一个路由都会有一个route对象,是一个局部的对象,可以获取对应的name,path,params,query等 我们可以从vue devtools中看到每个路由对象的不同.当前的路由信息，包含了当前 URL 解析得到的信息。包含当前的路径，参数，query对象等。</span><br></pre></td></tr></table></figure><h3 id="商品详情页面"><a href="#商品详情页面" class="headerlink" title="商品详情页面"></a>商品详情页面</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">浮动及清除浮动</span><br><span class="line">.fl&#123;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br><span class="line">.fr&#123;</span><br><span class="line">  float: right;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:before,.clearfix:after&#123;</span><br><span class="line">  content:&#x27; &#x27;;</span><br><span class="line">  display:table;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line">  clear: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container clearfix&quot;&gt; 父元素添加清除浮动</span><br></pre></td></tr></table></figure><h3 id="购物车页面"><a href="#购物车页面" class="headerlink" title="购物车页面"></a>购物车页面</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &#x27;./&#x27;  // 不带./默认是插件 去node_modules中查找</span><br></pre></td></tr></table></figure><p>数据一般放在后台，防止前端篡改数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 公共赋值</span><br><span class="line">renderData(res)&#123;</span><br><span class="line">  this.list = res.cartProductVoList || [];</span><br><span class="line">  this.allChecked = res.selectedAll;</span><br><span class="line">  this.cartTotalPrice = res.cartTotalPrice;</span><br><span class="line">  this.checkedNum = this.list.filter(item=&gt;item.productSelected).length;</span><br><span class="line">&#125;, // 某项数据改变后，与其相关联的数据不变化，需要重新赋值</span><br></pre></td></tr></table></figure><h3 id="Element-UI"><a href="#Element-UI" class="headerlink" title="Element UI"></a>Element UI</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a&gt; 优先级高于class</span><br><span class="line">&lt;h2&gt; 优先级高于class</span><br></pre></td></tr></table></figure><p>主要用于B端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Message &#125; from &#x27;element-ui&#x27;</span><br><span class="line">import &#x27;element-ui/lib/theme-chalk/index.css&#x27;</span><br><span class="line">Vue.prototype.$message = Message;</span><br></pre></td></tr></table></figure><h3 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h3><p><code>babel.config.js</code>和 <code>.babelrc </code>不会被合并</p><p>js.map 源码存放 上线后删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;plugins&quot;: [</span><br><span class="line">  [</span><br><span class="line">    &quot;component&quot;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;libraryName&quot;: &quot;element-ui&quot;,</span><br><span class="line">      &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">] // 按需加载</span><br></pre></td></tr></table></figure><h3 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h3><p>因为是单页面，所以把数据存储在Vuex中，Vuex中的数据存储在内存，页面刷新后，内存中的数据自动消失。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">      this.$router.push(&#123;</span><br><span class="line">        path: &#x27;/index&#x27;,</span><br><span class="line">        query: &#123;</span><br><span class="line">          from: &#x27;login&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;) // query传参</span><br><span class="line">      </span><br><span class="line">       this.$router.push(&#123;</span><br><span class="line">        name: &#x27;index&#x27;,</span><br><span class="line">        params: &#123;</span><br><span class="line">          from: &#x27;login&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;) // params 传参，用 name</span><br><span class="line">      </span><br><span class="line"> if (this.$route.params &amp;&amp; this.$route.params.from == &#x27;login&#x27;)</span><br><span class="line">  this.getCartCount()</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (this.$cookie.get(&#x27;userId&#x27;)) &#123;</span><br><span class="line">  this.getUser();</span><br><span class="line">  this.getCartCount()</span><br><span class="line">&#125; // 如果未登录 不需要调取登录信息 判断 cookie </span><br><span class="line">清除cookie this.$cookie.set(&#x27;xx&#x27;, &#x27;&#x27;, &#123;expires: -1&#125;)</span><br><span class="line">expires 和后端保持一致 登录有效期</span><br><span class="line">会话级别：Session 把整个浏览器关闭coookie消失</span><br></pre></td></tr></table></figure><h3 id="订单确认"><a href="#订单确认" class="headerlink" title="订单确认"></a>订单确认</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">  let path = this.$route.path;</span><br><span class="line">  if (path == &#x27;/order/confirm&#x27;) &#123;</span><br><span class="line">    this.title = &quot;确认订单&quot;</span><br><span class="line">    this.tip = &quot;请认真填写收获地址&quot;</span><br><span class="line">  &#125; else if (path == &#x27;order/list&#x27;) &#123;</span><br><span class="line">    this.title = &#x27;订单列表&#x27;</span><br><span class="line">    this.tip = &quot;请谨防钓鱼链接或诈骗电话&quot;</span><br><span class="line"></span><br><span class="line">  &#125; else if (path == &#x27;/order/pay&#x27;) &#123;</span><br><span class="line">    this.title = &#x27;订单支付&#x27;</span><br><span class="line">    this.tip = &quot;请谨防钓鱼链接或诈骗电话&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// axios的封装</span><br><span class="line">  submitAddress() &#123;</span><br><span class="line">     let &#123; checkedItem, userAction &#125; = this;</span><br><span class="line">     let method,</span><br><span class="line">         url,</span><br><span class="line">         params = &#123;&#125;;</span><br><span class="line">     if (userAction == 0) &#123;</span><br><span class="line">       (method = &quot;post&quot;), (url = &quot;/shippings&quot;);</span><br><span class="line">     &#125; else if (userAction == 1) &#123;</span><br><span class="line">       (method = &quot;put&quot;), (url = `/shippings/$&#123;checkedItem.id&#125;`);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       (method = &quot;delete&quot;), (url = `/shippings/$&#123;checkedItem.id&#125;`);</span><br><span class="line">     &#125;</span><br><span class="line">     if (userAction == 0 || userAction == 1) &#123;</span><br><span class="line">       let &#123;</span><br><span class="line">           receiverName,</span><br><span class="line">           receiverMobile,</span><br><span class="line">           receiverProvince,</span><br><span class="line">           receiverCity,</span><br><span class="line">           receiverDistrict,</span><br><span class="line">           receiverAddress,</span><br><span class="line">           receiverZip</span><br><span class="line">           &#125; = checkedItem;</span><br><span class="line">       let errMsg = &quot;&quot;;</span><br><span class="line">       if (!receiverName) &#123;</span><br><span class="line">         errMsg = &quot;请输入收货人名称&quot;;</span><br><span class="line">       &#125; else if (!receiverMobile || !/\d&#123;11&#125;/.test(receiverMobile)) &#123;</span><br><span class="line">         errMsg = &quot;请输入正确格式的手机号&quot;;</span><br><span class="line">       &#125; else if (!receiverProvince) &#123;</span><br><span class="line">         errMsg = &quot;请选择省份&quot;;</span><br><span class="line">       &#125; else if (!receiverCity) &#123;</span><br><span class="line">         errMsg = &quot;请选择对应的城市&quot;;</span><br><span class="line">       &#125; else if (!receiverAddress || !receiverDistrict) &#123;</span><br><span class="line">         errMsg = &quot;请输入收货地址&quot;;</span><br><span class="line">       &#125; else if (!/\d&#123;6&#125;/.test(receiverZip)) &#123;</span><br><span class="line">         errMsg = &quot;请输入六位邮编&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">       if (errMsg) &#123;</span><br><span class="line">         this.$message.error(errMsg);</span><br><span class="line">         return;</span><br><span class="line">       &#125;</span><br><span class="line">       params = &#123;</span><br><span class="line">         receiverName,</span><br><span class="line">         receiverMobile,</span><br><span class="line">         receiverProvince,</span><br><span class="line">         receiverCity,</span><br><span class="line">         receiverDistrict,</span><br><span class="line">         receiverAddress,</span><br><span class="line">         receiverZip</span><br><span class="line">       &#125;;</span><br><span class="line">     &#125;</span><br><span class="line">     this.axios[method](url, params).then(() =&gt; &#123;</span><br><span class="line">       this.closeModal();</span><br><span class="line">       this.getAddressList();</span><br><span class="line">       this.$message.success(&quot;操作成功&quot;);</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\d&#123;11&#125;/.text(arg) </span><br></pre></td></tr></table></figure><h3 id="订单支付"><a href="#订单支付" class="headerlink" title="订单支付"></a>订单支付</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">paySubmit(payType)&#123;</span><br><span class="line">  if(payType == 1)&#123;</span><br><span class="line">    window.open(&#x27;/#/order/alipay?orderId=&#x27;+this.orderId,&#x27;_blank&#x27;);</span><br><span class="line">    // 可以打开新窗口 window.open(URL,name,specs,replace) specs: &#x27;_blank&amp;_self&#x27;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    this.axios.post(&#x27;/pay&#x27;,&#123;</span><br><span class="line">      orderId:this.orderId,</span><br><span class="line">      orderName:&#x27;Vue高仿小米商城&#x27;,</span><br><span class="line">      amount:0.01,//单位元</span><br><span class="line">      payType:2 //1支付宝，2微信</span><br><span class="line">    &#125;).then((res)=&gt;&#123;</span><br><span class="line">      QRCode.toDataURL(res.content)</span><br><span class="line">      .then(url =&gt; &#123;</span><br><span class="line">        this.showPay = true;</span><br><span class="line">        this.payImg = url;</span><br><span class="line">        this.loopOrderState();</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(() =&gt; &#123;</span><br><span class="line">        this.$message.error(&#x27;微信二维码生成失败，请稍后重试&#x27;);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">paySubmit () &#123;</span><br><span class="line">  this.axios.post(&#x27;/pay&#x27;, &#123;</span><br><span class="line">    orderId: this.orderId,</span><br><span class="line">    orderName: &#x27;Vue高仿小米&#x27;,</span><br><span class="line">    amount: 0.01,</span><br><span class="line">    payType: 1</span><br><span class="line">  &#125;).then((res) =&gt; &#123;</span><br><span class="line">    this.content = res.content</span><br><span class="line">    setTimeout (() =&gt; &#123; document.forms[0].submit() &#125;, 100) // 提交表单</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="支付对接"><a href="#支付对接" class="headerlink" title="支付对接"></a>支付对接</h3><p>调用后端接口，</p><p>传入订单id，商品名称，金额，支付类型，</p><p>得到表单 通过v-html赋值 通过document.forms[0].submit() 提交 (做一个中间页面)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QRCode.toDataURL(res.content)</span><br><span class="line">.then(url =&gt; &#123; // 转换成base64</span><br><span class="line">  this.showPay = true;</span><br><span class="line">  this.payImg = url;</span><br><span class="line">  this.loopOrderState();</span><br><span class="line">&#125;)</span><br><span class="line">.catch(() =&gt; &#123;</span><br><span class="line">  this.$message.error(&#x27;微信二维码生成失败，请稍后重试&#x27;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 轮询当前订单支付状态</span><br><span class="line">loopOrderState()&#123;</span><br><span class="line">  this.T = setInterval(()=&gt;&#123;</span><br><span class="line">    this.axios.get(`/orders/$&#123;this.orderId&#125;`).then((res)=&gt;&#123;</span><br><span class="line">      if(res.status == 20)&#123;</span><br><span class="line">        clearInterval(this.T);</span><br><span class="line">        this.goOrderList();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,1000);</span><br><span class="line">&#125;, // 如果用户已经支付，自动跳转</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use(function (response) &#123;</span><br><span class="line">  let res = response.data;</span><br><span class="line">  let path = location.hash;</span><br><span class="line">  if (res.status == 0) &#123; // 成功</span><br><span class="line">    return res.data</span><br><span class="line">  &#125; else if (res.status == 10) &#123; // 未登录 自定义状态码</span><br><span class="line">    if (path !== &#x27;#/index&#x27;) &#123; // 处于首页不需要跳转login</span><br><span class="line">      window.location.href = &#x27;/#/login&#x27;</span><br><span class="line">      // 路由是挂载在vue实例中 这里是js文件 不能用路由跳转</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    Message.warning(res.msg)</span><br><span class="line">    return Promise.reject(res) // 不抛出认为是成功状态</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, (error) =&gt; &#123; // 状态码拦截 请求发送失败</span><br><span class="line">  let res = error.response;</span><br><span class="line">  Message.error(res.data.message)</span><br><span class="line">  return Promise.reject(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="订单列表"><a href="#订单列表" class="headerlink" title="订单列表"></a>订单列表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Pagination,Button &#125; from &#x27;element-ui&#x27;</span><br><span class="line">import infiniteScroll from &#x27;vue-infinite-scroll&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-pagination</span><br><span class="line">        v-if=&quot;false&quot;</span><br><span class="line">        class=&quot;pagination&quot;</span><br><span class="line">        background</span><br><span class="line">        layout=&quot;prev, pager, next&quot;</span><br><span class="line">        :pageSize=&quot;pageSize&quot;    // :pageSize=&quot;pageSize&quot;</span><br><span class="line">        :total=&quot;total&quot;</span><br><span class="line">        @current-change=&quot;handleChange&quot;</span><br><span class="line">        &gt;</span><br><span class="line">      &lt;/el-pagination&gt;</span><br><span class="line">components:&#123;</span><br><span class="line">  OrderHeader,</span><br><span class="line">  Loading,</span><br><span class="line">  NoData,</span><br><span class="line">  [Pagination.name]:Pagination, // 使用方法</span><br><span class="line">  [Button.name]:Button</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 第一种方法：分页器</span><br><span class="line">handleChange(pageNum)&#123;</span><br><span class="line">  this.pageNum = pageNum;</span><br><span class="line">  this.getOrderList();</span><br><span class="line">&#125;,    // 向右：添加text-align: right</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> // 第二种方法：加载更多按钮</span><br><span class="line">loadMore()&#123;</span><br><span class="line">    this.pageNum++;</span><br><span class="line">    this.getOrderList();</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 第三种方法：滚动加载，通过npm插件实现</span><br><span class="line">npm i infinite-scroll 是一个指令</span><br><span class="line"> directives: &#123;</span><br><span class="line"> infiniteScroll</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">    &lt;div class=&quot;scroll-more&quot;</span><br><span class="line">      v-infinite-scroll=&quot;scrollMore&quot;</span><br><span class="line">      infinite-scroll-disabled=&quot;true&quot;</span><br><span class="line">      infinite-scroll-distance=&quot;410&quot;</span><br><span class="line">      v-if=&quot;true&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;img src=&quot;/imgs/loading-svg/loading-spinning-bubbles.svg&quot; alt=&quot;&quot; v-show=&quot;loading&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">scrollMore()&#123;</span><br><span class="line">  this.busy = true;</span><br><span class="line">  setTimeout(()=&gt;&#123;</span><br><span class="line">    this.pageNum++;</span><br><span class="line">    this.getList();</span><br><span class="line">  &#125;,500);</span><br><span class="line">&#125;,</span><br><span class="line">// 专门给scrollMore使用</span><br><span class="line">getList()&#123;</span><br><span class="line">  this.loading = true;</span><br><span class="line">  this.axios.get(&#x27;/orders&#x27;,&#123;</span><br><span class="line">    params:&#123;</span><br><span class="line">      pageSize:10,</span><br><span class="line">      pageNum:this.pageNum</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).then((res)=&gt;&#123;</span><br><span class="line">    this.list = this.list.concat(res.list);</span><br><span class="line">    this.loading = false;</span><br><span class="line">    if(res.hasNextPage)&#123;</span><br><span class="line">      this.busy=false;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      this.busy=true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">component: () =&gt; import(&#x27;../pages/product.vue&#x27;) // 预加载，文件加载进html，等待空闲时生成js文件。</span><br><span class="line">实现真正按需加载：</span><br><span class="line">    chainWebpack: (config) =&gt; &#123;</span><br><span class="line">      config.plugins.delete(&#x27;prefetch&#x27;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用js代码实现观察者模式</title>
      <link href="/2021/06/11/yong-js-dai-ma-shi-xian-guan-cha-zhe-mo-shi/"/>
      <url>/2021/06/11/yong-js-dai-ma-shi-xian-guan-cha-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 class="bamboo-h " id="用js代码实现观察者模式">用js代码实现观察者模式</h1><br/><p>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。观察者模式属于三种设计类型(创建型、组合型和行为型)中的行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯。</p><p>总结来说观察者模式有两个特点：</p><p>1.发布&amp;订阅</p><p>2.1对N</p><h1 class="bamboo-h yellow" id="观察者模式的现实举例">观察者模式的现实举例</h1><br/><p>想象一下，你是一位顶尖歌手，粉丝没日没夜地询问你下个单曲什么时候发。 为了从中解放，你承诺(<strong>发布</strong>)会在单曲发布的第一时间发给他们。你给了粉丝们一个列表。他们可以在上面填写他们的电子邮件地址，以便当歌曲发布后，让所有<strong>订阅</strong>了的人能够立即收到。即便遇到不测，例如录音室发生了火灾，以致你无法发布新歌，他们也能及时收到相关通知。</p><h1 class="bamboo-h warning" id="用js代码实现观察者模式">用js代码实现观察者模式</h1><br/><p>首先先画一个 UML 简图</p><p><img "" class="lazyload placeholder" data-original="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c67be8ca93ce4e6589afbdf147b881a6~tplv-k3u1fbpfcp-watermark.image" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210611001736865.png"></p><p>根据 UML 简图用js代码实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主题，保存状态，状态变化后触发所有观察者对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="number">0</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span> = []</span><br><span class="line">  &#125;</span><br><span class="line">  getState () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">  &#125;</span><br><span class="line">  setState (state) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">notifyAllObservers</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  notifyAllObservers () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">      observer.<span class="title function_">update</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  attach (observer) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">push</span>(observer)</span><br><span class="line">  &#125;</span><br><span class="line">  remove (observer) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span> = <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">sub</span> =&gt;</span> sub !== observer)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> (name, subject) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subject</span> = subject</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subject</span>.<span class="title function_">attach</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> update, state: <span class="subst">$&#123;<span class="variable language_">this</span>.subject.getState()&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Subject</span>()</span><br><span class="line"><span class="keyword">let</span> o1 = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&#x27;o1&#x27;</span>, s)</span><br><span class="line"><span class="keyword">let</span> o2 = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&#x27;o2&#x27;</span>, s)</span><br><span class="line"><span class="keyword">let</span> o3 = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&#x27;o3&#x27;</span>, s)</span><br><span class="line">s.<span class="title function_">setState</span>(<span class="number">1</span>)</span><br><span class="line">s.<span class="title function_">setState</span>(<span class="number">2</span>)</span><br><span class="line">s.<span class="title function_">setState</span>(<span class="number">3</span>)</span><br><span class="line">s.<span class="title function_">remove</span>(o1)</span><br><span class="line">s.<span class="title function_">setState</span>(<span class="number">4</span>)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h1 class="bamboo-h red" id="设计原则">设计原则</h1><br/><p>主题和观察者分离，不是主动触发而是被动监听，两者解耦</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常见命令总结</title>
      <link href="/2021/06/08/git-chang-jian-ming-ling-zong-jie/"/>
      <url>/2021/06/08/git-chang-jian-ming-ling-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;url&gt;</span><br><span class="line">git init </span><br><span class="line">git status 查看状态</span><br><span class="line">git diff 查看变更内容</span><br><span class="line">git pull </span><br><span class="line">git push 3 // master 分支</span><br><span class="line">git push origin &lt;branch&gt; // 其他分支</span><br><span class="line">git add . 1</span><br><span class="line">git add &lt;file&gt;</span><br><span class="line">git commit -m &#x27;xxx&#x27; 2</span><br><span class="line">git commit -m &#x27;xxx -a // 新增所有</span><br><span class="line">git branch &lt;new branch&gt;</span><br><span class="line">git branch &lt;branch&gt; -d // 删除分支</span><br><span class="line">git checkout 切换分支</span><br><span class="line">git merge &lt;branch&gt;</span><br><span class="line">git mv &lt;file&gt; &lt;newfilename&gt; 修改文件名字</span><br><span class="line">git rm &lt;file&gt; // 删除文件</span><br><span class="line">git log // 查看历史</span><br><span class="line">git tag &lt;tagname&gt;</span><br><span class="line">git checkout a.js // 撤销</span><br><span class="line">git revert &lt;commit&gt; // 回滚 撤销指定的提交 有历史记录</span><br><span class="line">git reset --hard &lt;commit&gt; // 撤销指定的提交 无历史记录</span><br><span class="line">=&gt; git push &#x27;xx&#x27; --force</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(1). 基本使用</span><br><span class="line">git pull 拉取并merge代码</span><br><span class="line">git add .; //添加 暂存区</span><br><span class="line">git commit -m &#x27;zhu shi&#x27;// 提交到本地仓库并加上注释</span><br><span class="line">git push origin master //往远程仓库推送代码</span><br><span class="line">(2). 多人协作方式</span><br><span class="line">git branch -a 查看所有的分支</span><br><span class="line">git checkout -b aaa 创建新的分支aaa</span><br><span class="line">git checkout aaa 切换到aaa分支</span><br><span class="line">git push origin aaa 推送aaa 分支到远程仓库aaa分支</span><br><span class="line">git push origin master:aaa 推送master 到远程的aaa 分支</span><br><span class="line">git branch -d 删除一个分支</span><br></pre></td></tr></table></figure><p><strong>vscode 安装 git history diff</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 的生命周期</title>
      <link href="/2021/06/07/vue-de-sheng-ming-zhou-qi/"/>
      <url>/2021/06/07/vue-de-sheng-ming-zhou-qi/</url>
      
        <content type="html"><![CDATA[<h1 class="bamboo-h " id="beforeCreate(创建前)">beforeCreate(创建前)</h1><br/><div class="note success"><p>在数据观测和初始化事件还未开始</p></div><h1 class="bamboo-h " id="created(创建后)">created(创建后)</h1><br/><div class="note success"><p>完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来。</p></div><h1 class="bamboo-h " id="beforeMount(载入前)">beforeMount(载入前)</h1><br/><div class="note success"><p>在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。</p></div><h1 class="bamboo-h " id="mounted（载入后）">mounted（载入后）</h1><br/><div class="note success"><p>在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。</p></div><h1 class="bamboo-h " id="beforeUpdate（更新前）">beforeUpdate（更新前）</h1><br/><div class="note success"><p>在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。</p></div><h1 class="bamboo-h " id="updated（更新后）">updated（更新后）</h1><br/><div class="note success"><p>在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</p></div><h1 class="bamboo-h " id="beforeDestroy（销毁前）">beforeDestroy（销毁前）</h1><br/><div class="note success"><p>在实例销毁之前调用。实例仍然完全可用。</p></div><h1 class="bamboo-h " id="destroyed（销毁后）">destroyed（销毁后）</h1><br/><div class="note success"><p>在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</p></div>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>questions(持续更新)</title>
      <link href="/2021/06/05/questions/"/>
      <url>/2021/06/05/questions/</url>
      
        <content type="html"><![CDATA[<h5 id="1-var-和-let-const-的区别？"><a href="#1-var-和-let-const-的区别？" class="headerlink" title="1.var 和 let const 的区别？"></a>1.var 和 let const 的区别？</h5><p>使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象；<br>        使用let const声明的变量，其作用域为该语句所在的代码块内，不存在变量提升；<br>        使用const声明的是常量，在后面出现的代码中不能再修改该常量的值。</p><p>let声明的全局变量不是全局对象的属性</p><p>let声明的变量拥有块级作用域。</p><p>用let重定义变量会抛出一个语法错误（SyntaxError）。</p><p>形如for (let x…)的循环在每次迭代时都为x创建新的绑定。</p><p>声明会被提升，但是赋值不会。</p><h5 id="2-typeof能返回哪些类型？"><a href="#2-typeof能返回哪些类型？" class="headerlink" title="2.typeof能返回哪些类型？"></a>2.typeof能返回哪些类型？</h5><p>numer string undefinend boolean symbol object function</p><h5 id="3、列举强制类型转换和隐式类型转换"><a href="#3、列举强制类型转换和隐式类型转换" class="headerlink" title="3、列举强制类型转换和隐式类型转换"></a>3、列举强制类型转换和隐式类型转换</h5><p>强制类型转换：parseInt parseFloat toString</p><p>隐式类型转换： if、逻辑运算、==、+拼接字符串</p><h5 id="4、手写深度比较，模拟lodash-isEqual"><a href="#4、手写深度比较，模拟lodash-isEqual" class="headerlink" title="4、手写深度比较，模拟lodash isEqual"></a>4、手写深度比较，模拟lodash isEqual</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function isObject(obj) &#123;</span><br><span class="line">          return typeof obj === &#x27;object&#x27; &amp;&amp; obj !== null</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      function isEqual(a, b) &#123;</span><br><span class="line">          if (!isObject(a) || !isObject(b)) return a === b // 是否是对象</span><br><span class="line">          if (a === b) return true // 是否是同一个引用</span><br><span class="line">          if (Object.keys(a).length !== Object.keys(b).length) return false</span><br><span class="line">          for (let k in a) &#123;</span><br><span class="line">              const res = isEqual(a[k], b[k]);</span><br><span class="line">              if (!res) return false</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          return true</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h5 id="5、split-和join-区别"><a href="#5、split-和join-区别" class="headerlink" title="5、split()和join()区别"></a>5、split()和join()区别</h5><p>split() 将字符串分解成数组</p><p>使用指定的分隔符字符串将一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>String</code></a>对象分割成子字符串数组，以一个指定的分割字串来决定每个拆分的位置。 </p><p>split()只有一个参数时：分割的字符串或正则表达式；两个参数时，第二个参数是指返回的数组中元素的个数；</p><p>join() 将数组分解成字符串</p><p>用于连接多个字符或字符串，返回值为一个字符串 默认分割号为逗号</p><p><strong>String.split() 执行的操作与 Array.join() 执行的操作是相反的。</strong></p><h5 id="6、pop-push-unshift-shift-返回值？"><a href="#6、pop-push-unshift-shift-返回值？" class="headerlink" title="6、pop push unshift shift 返回值？"></a>6、pop push unshift shift 返回值？</h5><p><code>push()</code> 和 <code>unshift()</code> 会返回新数组的长度，而 <code>pop()</code> 和 <code>shift()</code> 会返回被移除的元素（当数组为空时返回 <code>undefined</code>）</p><h5 id="7、数组的API有哪些是纯函数？"><a href="#7、数组的API有哪些是纯函数？" class="headerlink" title="7、数组的API有哪些是纯函数？"></a>7、数组的API有哪些是纯函数？</h5><p>纯函数：1.不改变原数组  2.返回一个数组</p><p>arr.slice()arr.map()arr.forEach()arr.every()arr.some()arr.filter()arr.reduce()arr.entries()arr.find()</p><p>arr.concat</p><p>会改变原数组的方法：arr.splice()<br>        arr.reverse()arr.fill()arr.copyWithin()arr.sort()arr.push()arr.pop()arr.unshift()arr.shift()</p><h5 id="8、数组slice和splice的区别？"><a href="#8、数组slice和splice的区别？" class="headerlink" title="8、数组slice和splice的区别？"></a>8、数组slice和splice的区别？</h5><p>slice切片 splice剪切</p><p>slice() 返回一个数组，不改原数组 </p><p>splice() 返回一个数组，改变原数组</p><h5 id="9、-10-20-30-map-parseInt-返回值？"><a href="#9、-10-20-30-map-parseInt-返回值？" class="headerlink" title="9、[10,20,30].map(parseInt)返回值？"></a>9、[10,20,30].map(parseInt)返回值？</h5><p>[10, NaN, NaN]</p><h5 id="10、ajax请求get和post的区别"><a href="#10、ajax请求get和post的区别" class="headerlink" title="10、ajax请求get和post的区别"></a>10、ajax请求get和post的区别</h5><p>get请求一般用于查询，post一般用于用户提交</p><p>get参数拼接再url上，post放在请求体内(数据体积可更大)</p><h5 id="11、函数call和apply-bind区别？"><a href="#11、函数call和apply-bind区别？" class="headerlink" title="11、函数call和apply bind区别？"></a>11、函数call和apply bind区别？</h5><p>它们的共同点是，都能够<strong>改变函数执行时的上下文</strong>，将一个对象的方法交给另一个对象来执行，并且是立即执行的。</p><p>区别在参数上，call是零散传入，apply是传入一个数组或者类数组</p><p><strong>调用 call 和 apply 的对象，必须是一个函数 Function</strong></p><p><strong>类数组无法使用 forEach、splice、push 等数组原型链上的方法</strong></p><p><strong>bind 方法的返回值是函数，并且需要稍后调用，才会执行</strong>。而 apply 和 call 则是立即调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function add (a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sub (a, b) &#123;</span><br><span class="line">    return a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add.bind(sub, 5, 3); // 这时，并不会返回 8</span><br><span class="line">add.bind(sub, 5, 3)(); // 调用后，返回 8</span><br></pre></td></tr></table></figure><h5 id="12、事件代理-委托-是什么？"><a href="#12、事件代理-委托-是什么？" class="headerlink" title="12、事件代理(委托)是什么？"></a>12、事件代理(委托)是什么？</h5><p>原本需要绑定在子元素的响应事件委托给父元素，让父元素担当事件监听的职务。 事件代理的原理是DOM元素的事件冒泡。</p><h5 id="13、闭包是什么，有什么特性？有什么负面影响？"><a href="#13、闭包是什么，有什么特性？有什么负面影响？" class="headerlink" title="13、闭包是什么，有什么特性？有什么负面影响？"></a>13、闭包是什么，有什么特性？有什么负面影响？</h5><p>函数可以记住并访问所在的词法作用域 。</p><p>父函数先于子函数销毁，子函数需要用到的变量保存在[[scoped]]中</p><p>影响：变量会常驻内存(<strong>可达性</strong>)，得不到释放。闭包不要乱用。</p><p>函数作为返回值–内存不会释放</p><h5 id="14、如何阻止事件冒泡和默认行为？"><a href="#14、如何阻止事件冒泡和默认行为？" class="headerlink" title="14、如何阻止事件冒泡和默认行为？"></a>14、如何阻止事件冒泡和默认行为？</h5><p>e.prventDefault()</p><p>e.stopPropagation()</p><h5 id="15、查找、添加、删除、移动DOM节点的方法？"><a href="#15、查找、添加、删除、移动DOM节点的方法？" class="headerlink" title="15、查找、添加、删除、移动DOM节点的方法？"></a>15、查找、添加、删除、移动DOM节点的方法？</h5><p>appendChild() removeChild() insertBefore() replaceChild()</p><h5 id="16、如何减少DOM操作？"><a href="#16、如何减少DOM操作？" class="headerlink" title="16、如何减少DOM操作？"></a>16、如何减少DOM操作？</h5><p>缓存DOM查询结果</p><p>多次DOM操作，合并到一次插入</p><p>document.createDocumentFragment() 创建一个文档片段</p><h5 id="17、解释jsonp的原理，为什么它不是真正的ajax？"><a href="#17、解释jsonp的原理，为什么它不是真正的ajax？" class="headerlink" title="17、解释jsonp的原理，为什么它不是真正的ajax？"></a>17、解释jsonp的原理，为什么它不是真正的ajax？</h5><p>浏览器的同源策略（<strong>服务器端没有同源策略</strong>）和跨域</p><p>哪些html标签可以跨域？ img script css</p><p>利用&lt; script&gt;标签可以跨域，让服务器端返回可执行的Javascript函数，参数为要回发的数据。</p><h5 id="18、document-load-和-ready-的区别？"><a href="#18、document-load-和-ready-的区别？" class="headerlink" title="18、document.load 和 ready 的区别？"></a>18、document.load 和 ready 的区别？</h5><p>load 网页全部资源加载完之后执行 </p><p>ready DOM加载完执行</p><h5 id="19、-和-的区别？"><a href="#19、-和-的区别？" class="headerlink" title="19、== 和 === 的区别？"></a>19、== 和 === 的区别？</h5><p>=== 严格相等 == 会进行类型转换</p><h5 id="20、函数声明和函数表达式的区别？"><a href="#20、函数声明和函数表达式的区别？" class="headerlink" title="20、函数声明和函数表达式的区别？"></a>20、函数声明和函数表达式的区别？</h5><p>函数声明会被提升，函数表达式不会提升</p><h5 id="21、new-Object-和-Object-create-的区别？"><a href="#21、new-Object-和-Object-create-的区别？" class="headerlink" title="21、new Object() 和 Object.create()的区别？"></a>21、new Object() 和 Object.create()的区别？</h5><p>字面量和<code>new</code>关键字创建的对象是<code>Object</code>的实例，原型指向<code>Object.prototype</code>，继承内置对象<code>Object</code></p><p><code>Object.create(arg, pro)</code>创建的对象的原型取决于<code>arg</code>，<code>arg</code>为<code>null</code>，新对象是空对象，没有原型，不继承任何对象；<code>arg</code>为指定对象，新对象的原型指向指定对象，继承指定对象</p><h5 id="22、关于this的场景题？"><a href="#22、关于this的场景题？" class="headerlink" title="22、关于this的场景题？"></a>22、关于this的场景题？</h5><p>由new调用？绑定到新创建的对象</p><p>由call(apply, bind)调用？绑定到指定的对象</p><p>由上下文对象调用？绑定到那个上下文</p><p>默认：严格模式绑定到undefined 否则绑定到全局对象</p><h5 id="23、setInterval-方法的返回值是什么？"><a href="#23、setInterval-方法的返回值是什么？" class="headerlink" title="23、setInterval 方法的返回值是什么？"></a>23、<code>setInterval</code> 方法的返回值是什么？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setInterval(fn, delay, arg1, arg2...)</span><br></pre></td></tr></table></figure><p><code>setInterval</code> 返回一个唯一的 id。此 id 可被用于 <code>clearInterval</code> 函数来取消定时。</p><h5 id="24、输出是什么"><a href="#24、输出是什么" class="headerlink" title="24、输出是什么?"></a>24、输出是什么?</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const name = &quot;Lydia&quot;;</span><br><span class="line">age = 21;</span><br><span class="line"></span><br><span class="line">console.log(delete name);</span><br><span class="line">console.log(delete age);</span><br></pre></td></tr></table></figure><p><code>delete</code>操作符返回一个布尔值： <code>true</code>指删除成功，否则返回<code>false</code>. 但是通过 <code>var</code>, <code>const</code> 或 <code>let</code> 关键字声明的变量无法用 <code>delete</code> 操作符来删除。</p><p><code>name</code>变量由<code>const</code>关键字声明，所以删除不成功:返回 <code>false</code>. 而我们设定<code>age</code>等于<code>21</code>时,我们实际上添加了一个名为<code>age</code>的属性给全局对象。对象中的属性是可以删除的，全局对象也是如此，所以<code>delete age</code>返回<code>true</code>.</p><h5 id="25、输出是什么"><a href="#25、输出是什么" class="headerlink" title="25、输出是什么?"></a>25、输出是什么?</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const value = &#123; number: 10 &#125;;</span><br><span class="line"></span><br><span class="line">const multiply = (x = &#123; ...value &#125;) =&gt; &#123;</span><br><span class="line">  console.log(x.number *= 2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">multiply(); 20</span><br><span class="line">multiply(); 20</span><br><span class="line">multiply(value); 20</span><br><span class="line">multiply(value); 40</span><br></pre></td></tr></table></figure><p>在ES6中，我们可以使用默认值初始化参数。如果没有给函数传参，或者传的参值为 <code>&quot;undefined&quot;</code> ，那么参数的值将是默认值。上述例子中，我们将 <code>value</code> 对象进行了解构并传到一个新对象中，因此 <code>x</code> 的默认值为 <code>&#123;number：10&#125;</code> 。</p><p>默认参数在调用时才会进行计算，每次调用函数时，都会创建一个新的对象。我们前两次调用 <code>multiply</code> 函数且不传递值，那么每一次 <code>x</code> 的默认值都为 <code>&#123;number：10&#125;</code> ，因此打印出该数字的乘积值为<code>20</code>。</p><p>第三次调用 <code>multiply</code> 时，我们传递了一个参数，即对象<code>value</code>。 <code>*=</code>运算符实际上是<code>x.number = x.number * 2</code>的简写，我们修改了<code>x.number</code>的值，并打印出值<code>20</code>。</p><p>第四次，我们再次传递<code>value</code>对象。 <code>x.number</code>之前被修改为<code>20</code>，所以<code>x.number * = 2</code>打印为<code>40</code></p><h5 id="26、输出什么"><a href="#26、输出什么" class="headerlink" title="26、输出什么?"></a>26、输出什么?</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4].reduce((x, y) =&gt; console.log(x, y));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1` `2` and `undefined` `3` and `undefined` `4</span><br></pre></td></tr></table></figure><p><code>reducer</code> 函数接收4个参数:</p><ol><li>Accumulator (acc) (累计器)</li><li>Current Value (cur) (当前值)</li><li>Current Index (idx) (当前索引)</li><li>Source Array (src) (源数组)</li></ol><p><code>reducer</code> 函数的返回值将会分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。</p><p><code>reducer</code> 函数还有一个可选参数<code>initialValue</code>, 该参数将作为第一次调用回调函数时的第一个参数的值。如果没有提供<code>initialValue</code>，则将使用数组中的第一个元素。</p><p>在上述例子，<code>reduce</code>方法接收的第一个参数(Accumulator)是<code>x</code>, 第二个参数(Current Value)是<code>y</code>。</p><p>在第一次调用时，累加器<code>x</code>为<code>1</code>，当前值<code>“y”</code>为<code>2</code>，打印出累加器和当前值：<code>1</code>和<code>2</code>。</p><p>例子中我们的回调函数没有返回任何值，只是打印累加器的值和当前值。如果函数没有返回值，则默认返回<code>undefined</code>。 在下一次调用时，累加器为<code>undefined</code>，当前值为“3”, 因此<code>undefined</code>和<code>3</code>被打印出。</p><p>在第四次调用时，回调函数依然没有返回值。 累加器再次为 <code>undefined</code> ，当前值为“4”。 <code>undefined</code>和<code>4</code>被打印出。</p><h5 id="27、判断字符串以字母开头，后面字母数字下划线，长度6-30？"><a href="#27、判断字符串以字母开头，后面字母数字下划线，长度6-30？" class="headerlink" title="27、判断字符串以字母开头，后面字母数字下划线，长度6-30？"></a>27、判断字符串以字母开头，后面字母数字下划线，长度6-30？</h5><p><strong>js把以0开头的数字转换成字符串时，当成8进制</strong></p><p>regExp检测的是<strong>字符串</strong></p><h5 id="28、手写字符串trim方法，保证浏览器兼容性"><a href="#28、手写字符串trim方法，保证浏览器兼容性" class="headerlink" title="28、手写字符串trim方法，保证浏览器兼容性"></a>28、手写字符串trim方法，保证浏览器兼容性</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.trim = function () &#123;</span><br><span class="line">           return this.replace(/^\s+/, &#x27;&#x27;).replace(/\s+$/, &#x27;&#x27;)</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h5 id="29、如何获取多个数字中的最大值"><a href="#29、如何获取多个数字中的最大值" class="headerlink" title="29、如何获取多个数字中的最大值"></a>29、如何获取多个数字中的最大值</h5><p>Math.max()</p><h5 id="30、如何用JS实现继承？"><a href="#30、如何用JS实现继承？" class="headerlink" title="30、如何用JS实现继承？"></a>30、如何用JS实现继承？</h5><p>class继承</p><p>prototype继承</p><h5 id="31、将类数组变为数组？"><a href="#31、将类数组变为数组？" class="headerlink" title="31、将类数组变为数组？"></a>31、将类数组变为数组？</h5><p>Array.from()</p><p>Array.prototye.slice.call(arguments) </p><p>[].slice.call(arguments)</p><p>[…args]</p><h5 id="32、如何捕获JS程序中的异常？"><a href="#32、如何捕获JS程序中的异常？" class="headerlink" title="32、如何捕获JS程序中的异常？"></a>32、如何捕获JS程序中的异常？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">      &#125; catch (ex) &#123;</span><br><span class="line">          console.error(ex);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      window.onerror = function(message, source, lineNum, colNum, error)</span><br></pre></td></tr></table></figure><h5 id="33、什么是JSON？"><a href="#33、什么是JSON？" class="headerlink" title="33、什么是JSON？"></a>33、什么是JSON？</h5><p>json是一种数据格式，本质是一段<strong>字符串</strong></p><p>json格式和JS对象结构一致，对JS语言更友好</p><h5 id="34、获取当前页面url参数？"><a href="#34、获取当前页面url参数？" class="headerlink" title="34、获取当前页面url参数？"></a>34、获取当前页面url参数？</h5><p>location.search</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function query(name) &#123;</span><br><span class="line">          let search = location.search</span><br><span class="line">          const p = new URLSearchParams(search)</span><br><span class="line">          return p.get(name)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h5 id="35、输出什么？"><a href="#35、输出什么？" class="headerlink" title="35、输出什么？"></a>35、输出什么？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const &#123; name: myName &#125; = &#123; name: &quot;Lydia&quot; &#125;;</span><br><span class="line"></span><br><span class="line">console.log(name);</span><br></pre></td></tr></table></figure><p>当我们从右侧的对象解构属性<code>name</code>时，我们将其值<code>Lydia</code>分配给名为<code>myName</code>的变量。</p><p>使用<code>&#123;name：myName&#125;</code>，我们是在告诉JavaScript我们要创建一个名为<code>myName</code>的新变量，并且其值是右侧对象的<code>name</code>属性的值。</p><p>当我们尝试打印<code>name</code>，一个未定义的变量时，就会引发<code>ReferenceError</code>。</p><h5 id="36、什么是纯函数？"><a href="#36、什么是纯函数？" class="headerlink" title="36、什么是纯函数？"></a>36、什么是纯函数？</h5><p>纯函数在相同的输入值时，需产生相同的输出，纯函数不会产生副作用。</p><h5 id="37、输出什么？"><a href="#37、输出什么？" class="headerlink" title="37、输出什么？"></a>37、输出什么？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function checkAge(age) &#123;</span><br><span class="line">  if (age &lt; 18) &#123;</span><br><span class="line">    const message = &quot;Sorry, you&#x27;re too young.&quot;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    const message = &quot;Yay! You&#x27;re old enough!&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(checkAge(21))</span><br></pre></td></tr></table></figure><p><code>const</code>和<code>let</code>声明的变量是具有<strong>块级作用域</strong>的，块是大括号（<code>&#123;&#125;</code>）之间的任何东西, 即上述情况<code>if / else</code>语句的花括号。 由于块级作用域，我们无法在声明的块之外引用变量，因此抛出<code>ReferenceError</code>。</p><h5 id="38、将url参数解析为js对象？"><a href="#38、将url参数解析为js对象？" class="headerlink" title="38、将url参数解析为js对象？"></a>38、将url参数解析为js对象？</h5><h5 id="39、手写数组flatern，考虑多层级"><a href="#39、手写数组flatern，考虑多层级" class="headerlink" title="39、手写数组flatern，考虑多层级"></a>39、手写数组flatern，考虑多层级</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[].concat(arr) // 一层flat</span><br><span class="line">function flat (arr) &#123;</span><br><span class="line">            const isDeep = arr.some(item =&gt; item instanceof Array)</span><br><span class="line">            if (!isDeep) return arr</span><br><span class="line">            const res = [].concat.apply([], arr)</span><br><span class="line">            return flat(res)</span><br><span class="line">        &#125; // 多层级</span><br></pre></td></tr></table></figure><h5 id="40、数组去重"><a href="#40、数组去重" class="headerlink" title="40、数组去重"></a>40、数组去重</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">          const res = []</span><br><span class="line">          arr.forEach(item =&gt; &#123;</span><br><span class="line">              if (res.indexOf(item) &lt; 0) &#123;</span><br><span class="line">                  res.push(item)</span><br><span class="line">              &#125;       </span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          return res</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      Array.from(new Set(arr))</span><br><span class="line">      [...new Set(arr)]</span><br></pre></td></tr></table></figure><h5 id="41、介绍一下RAF-window-requestAnimationFrame"><a href="#41、介绍一下RAF-window-requestAnimationFrame" class="headerlink" title="41、介绍一下RAF window.requestAnimationFrame"></a>41、介绍一下RAF window.requestAnimationFrame</h5><p>想要动画流畅，更新频率要60帧/s，即16.67ms更新一次视图</p><p>setTimeout要手动控制频率，而RAF浏览器会自动控制</p><p>后台标签或隐藏iframe,Raf会暂停，而timeout依然运行</p><h5 id="42、前端性能优化-一般从哪些方面考虑？"><a href="#42、前端性能优化-一般从哪些方面考虑？" class="headerlink" title="42、前端性能优化?一般从哪些方面考虑？"></a>42、前端性能优化?一般从哪些方面考虑？</h5><p>原则：多使用内存、缓存，减少计算，减少网络请求</p><p>方向：加载页面，页面渲染，页面操作流畅度</p><h5 id="43、"><a href="#43、" class="headerlink" title="43、"></a>43、</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;span class=span-a&gt;</span><br><span class="line">      &#123;&#123;obj.a&#125;&#125; </span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;span class=span-b&gt;</span><br><span class="line">      &#123;&#123;obj.b&#125;&#125;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">  // js</span><br><span class="line">  var app = new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    obj: &#123;</span><br><span class="line">      a: &#x27;a&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">app.obj.a = &#x27;a2&#x27;</span><br><span class="line">app.obj.b = &#x27;b&#x27;</span><br></pre></td></tr></table></figure><p><strong>深入分析：</strong></p><ul><li>要理解为什么 span-b 会更新，要点是理解视图更新其实是<strong>异步</strong>的。</li><li>当我们让 a 从 ‘a1’ 变成 ‘a2’ 时，Vue 会监听到这个变化，但是 Vue 并不能马上更新视图，因为 Vue 是使用 Object.defineProperty 这样的方式来监听变化的，监听到变化后会创建一个视图更新任务到任务队列里。</li><li>所以在视图更新之前，要先把余下的代码运行完才行，也就是会运行 b = ‘b’。</li><li>等到视图更新的时候，由于 Vue 会去做 diff（文档中有写），于是 Vue 就会发现 a 和 b 都变了，自然会去更新 span-a 和 span-b。</li></ul><h5 id="44、如何理解暂时性死区？"><a href="#44、如何理解暂时性死区？" class="headerlink" title="44、如何理解暂时性死区？"></a>44、如何理解暂时性死区？</h5><p>从程序执行进入代码块（或函数）的那一刻起，变量就开始进入“未初始化”状态。它一直保持未初始化状态，直至程序执行到相应的 <code>let</code> 语句。</p><p>换句话说，一个变量从技术的角度来讲是存在的，但是在 <code>let</code> 之前还不能使用。</p><p>引擎从函数开始就知道局部变量 x，  但是变量 x 一直处于“未初始化”（无法使用）的状态，直到结束 let（“死区”） </p><h5 id="45、下面这段代码的结果会是什么？"><a href="#45、下面这段代码的结果会是什么？" class="headerlink" title="45、下面这段代码的结果会是什么？"></a>45、下面这段代码的结果会是什么？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let x = 1;</span><br><span class="line"></span><br><span class="line">function func() &#123;</span><br><span class="line">  console.log(x); // ?</span><br><span class="line"></span><br><span class="line">  let x = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(); //error</span><br></pre></td></tr></table></figure><ol><li>当脚本开始运行，词法环境预先填充了所有声明的变量。<ul><li>最初，它们处于“未初始化（Uninitialized）”状态。这是一种特殊的内部状态，这意味着引擎知道变量，但是在用 <code>let</code> 声明前，不能引用它。几乎就像变量不存在一样。</li></ul></li><li>然后 <code>let phrase</code> 定义出现了。它尚未被赋值，因此它的值为 <code>undefined</code>。从这一刻起，我们就可以使用变量了。</li></ol><h5 id="46、href-url-src"><a href="#46、href-url-src" class="headerlink" title="46、href url src ?"></a>46、href url src ?</h5><p>href 目的不是为了引用资源，而是为了建立联系，让当前标签能够链接到目标地址。</p><p>source（缩写），指向外部资源的位置，指向的内容将会应用到文档中当前标签所在位置。</p><p>在请求 src 资源时会将其指向的资源下载并应用到文档中，比如 JavaScript 脚本，img 图片；</p><p>（1）href 用于在当前文档和引用资源之间确立联系；</p><p>（2）src 用于替换当前内容；</p><h5 id="47、token"><a href="#47、token" class="headerlink" title="47、token?"></a>47、token?</h5><p>这里说一下token，一般是在登录完成之后，将用户的token通过localStorage或者cookie存在本地，然后用户每次在进入页面的时候（即在main.js中），会首先从本地存储中读取token，如果token存在说明用户已经登陆过，则更新vuex中的token状态。然后，在每次请求接口的时候，都会在请求的header中携带token，后台人员就可以根据你携带的token来判断你的登录是否过期，如果没有携带，则说明没有登录过。这时候或许有些小伙伴会有疑问了，就是每个请求都携带token，那么要是一个页面不需要用户登录就可以访问的怎么办呢？其实，你前端的请求可以携带token，但是后台可以选择不接收啊！</p><h5 id="48、重绘和重排-回流-？"><a href="#48、重绘和重排-回流-？" class="headerlink" title="48、重绘和重排(回流)？"></a>48、重绘和重排(回流)？</h5><p>当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。<strong>重绘是指一个元素外观的改变</strong>所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。 </p><p><strong>触发重绘的条件：改变元素外观属性。如：color，background-color等。</strong></p><p><strong>注意：</strong>table及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用table布局页面的原因之一。</p><p><strong>重排（重构/回流/reflow）：</strong>当渲染树中的一部分(或全部)因为元素的**规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)**。每个页面至少需要一次回流，就是在页面第一次加载的时候。</p><p><strong>重绘和重排的关系</strong>：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。</p><p>我们要减少重绘和重排就是要减少对<strong>渲染树</strong>的操作</p><p><strong>将需要多次重排的元素，position属性设为absolute或fixed</strong>，元素脱离了文档流，它的变化不会影响到其他元素</p><h5 id="49、页面渲染过程？"><a href="#49、页面渲染过程？" class="headerlink" title="49、页面渲染过程？"></a>49、页面渲染过程？</h5><p>解析 =&gt; 布局=&gt; 绘制=&gt; 光栅化</p><h5 id="50、对async、await的理解，内部原理？"><a href="#50、对async、await的理解，内部原理？" class="headerlink" title="50、对async、await的理解，内部原理？"></a>50、对async、await的理解，内部原理？</h5><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p><h5 id="51、flex"><a href="#51、flex" class="headerlink" title="51、flex"></a>51、flex</h5><p><strong>flex-grow ：</strong>flex-grow属性定义盒子的<strong>放大</strong>比例，默认为0 不放大  其他数字按比例放大</p><p><strong>flex-shrink：</strong>如果所有项目的flex-shrink属性都为1，当空间不足时，都将<strong>等比例缩小</strong>。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者<strong>0的不缩小 其他缩小</strong></p><h5 id="52、cookie"><a href="#52、cookie" class="headerlink" title="52、cookie?"></a>52、cookie?</h5><p>cookie 做什么? 一般用来存储数据  比如 用户的登录状态  不过现在经常用token 和localStorage了</p><p><strong>HTTP协议本身是无状态的</strong>。什么是无状态呢，即服务器无法判断用户身份。Cookie实际上是一小段的文本信息（key-value格式）。客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。<strong>服务器检查该Cookie，以此来辨认用户等状态</strong>。</p><h5 id="53、输出是什么"><a href="#53、输出是什么" class="headerlink" title="53、输出是什么?"></a>53、输出是什么?</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123; name: &quot;Lydia&quot; &#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(person, &quot;age&quot;, &#123; value: 21 &#125;);</span><br><span class="line"></span><br><span class="line">console.log(person);</span><br><span class="line">console.log(Object.keys(person));</span><br></pre></td></tr></table></figure><ul><li><p>A: <code>&#123; name: &quot;Lydia&quot;, age: 21 &#125;</code>, <code>[&quot;name&quot;, &quot;age&quot;]</code></p></li><li><p>B: <code>&#123; name: &quot;Lydia&quot;, age: 21 &#125;</code>, <code>[&quot;name&quot;]</code></p></li><li><p>C: <code>&#123; name: &quot;Lydia&quot;&#125;</code>, <code>[&quot;name&quot;, &quot;age&quot;]</code></p></li><li><p>D: <code>&#123; name: &quot;Lydia&quot;&#125;</code>, <code>[&quot;age&quot;]</code></p></li><li><p>答案: B</p><p>通过<code>defineProperty</code>方法，我们可以给对象添加一个新属性，或者修改已经存在的属性。而我们使用<code>defineProperty</code>方法给对象添加了一个属性之后，属性默认为 <em>不可枚举(not enumerable)</em>. <code>Object.keys</code>方法仅返回对象中 <em>可枚举(enumerable)</em> 的属性，因此只剩下了<code>&quot;name&quot;</code>.</p><p>用<code>defineProperty</code>方法添加的属性默认不可变。你可以通过<code>writable</code>, <code>configurable</code> 和 <code>enumerable</code>属性来改变这一行为。这样的话， 相比于自己添加的属性，<code>defineProperty</code>方法添加的属性有了更多的控制权。</p></li></ul><h5 id="54、输出什么"><a href="#54、输出什么" class="headerlink" title="54、输出什么?"></a>54、输出什么?</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4].reduce((x, y) =&gt; console.log(x, y));</span><br></pre></td></tr></table></figure><ul><li>A: <code>1</code> <code>2</code> and <code>3</code> <code>3</code> and <code>6</code> <code>4</code></li><li>B: <code>1</code> <code>2</code> and <code>2</code> <code>3</code> and <code>3</code> <code>4</code></li><li>C: <code>1</code> <code>undefined</code> and <code>2</code> <code>undefined</code> and <code>3</code> <code>undefined</code> and <code>4</code> <code>undefined</code></li><li>D: <code>1</code> <code>2</code> and <code>undefined</code> <code>3</code> and <code>undefined</code> <code>4</code></li></ul><p>答案: <strong>D</strong></p><p><code>reducer</code> 函数接收4个参数:</p><ol><li>Accumulator (acc) (累计器)</li><li>Current Value (cur) (当前值)</li><li>Current Index (idx) (当前索引)</li><li>Source Array (src) (源数组)</li></ol><p><code>reducer</code> 函数的返回值将会分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。</p><p><code>reducer</code> 函数还有一个可选参数<code>initialValue</code>, 该参数将作为第一次调用回调函数时的第一个参数的值。如果没有提供<code>initialValue</code>，则将使用数组中的第一个元素。</p><p>在上述例子，<code>reduce</code>方法接收的第一个参数(Accumulator)是<code>x</code>, 第二个参数(Current Value)是<code>y</code>。</p><p>在第一次调用时，累加器<code>x</code>为<code>1</code>，当前值<code>“y”</code>为<code>2</code>，打印出累加器和当前值：<code>1</code>和<code>2</code>。</p><p>例子中我们的回调函数没有返回任何值，只是打印累加器的值和当前值。如果函数没有返回值，则默认返回<code>undefined</code>。 在下一次调用时，累加器为<code>undefined</code>，当前值为“3”, 因此<code>undefined</code>和<code>3</code>被打印出。</p><p>在第四次调用时，回调函数依然没有返回值。 累加器再次为 <code>undefined</code> ，当前值为“4”。 <code>undefined</code>和<code>4</code>被打印出。</p><h5 id="55、输出什么"><a href="#55、输出什么" class="headerlink" title="55、输出什么?"></a>55、输出什么?</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// index.js</span><br><span class="line">console.log(&#x27;running index.js&#x27;);</span><br><span class="line">import &#123; sum &#125; from &#x27;./sum.js&#x27;;</span><br><span class="line">console.log(sum(1, 2));</span><br><span class="line"></span><br><span class="line">// sum.js</span><br><span class="line">console.log(&#x27;running sum.js&#x27;);</span><br><span class="line">export const sum = (a, b) =&gt; a + b;</span><br></pre></td></tr></table></figure><ul><li><p>A: <code>running index.js</code>, <code>running sum.js</code>, <code>3</code></p></li><li><p>B: <code>running sum.js</code>, <code>running index.js</code>, <code>3</code></p></li><li><p>C: <code>running sum.js</code>, <code>3</code>, <code>running index.js</code></p></li><li><p>D: <code>running index.js</code>, <code>undefined</code>, <code>running sum.js</code></p></li><li><p><strong>答案: B</strong></p><p><code>import</code>命令是编译阶段执行的，在代码运行之前。因此这意味着被导入的模块会先运行，而导入模块的文件会后执行。</p><p>这是CommonJS中<code>require（）</code>和<code>import</code>之间的区别。使用<code>require()</code>，您可以在运行代码时根据需要加载依赖项。 如果我们使用<code>require</code>而不是<code>import</code>，<code>running index.js</code>，<code>running sum.js</code>，<code>3</code>会被依次打印。</p></li></ul><h5 id="56、输出什么"><a href="#56、输出什么" class="headerlink" title="56、输出什么?"></a>56、输出什么?</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function addToList(item, list) &#123;</span><br><span class="line">  return list.push(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const result = addToList(&quot;apple&quot;, [&quot;banana&quot;]);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><ul><li><p>A: <code>[&#39;apple&#39;, &#39;banana&#39;]</code></p></li><li><p>B: <code>2</code></p></li><li><p>C: <code>true</code></p></li><li><p>D: <code>undefined</code></p></li><li><p><strong>答案: B</strong></p><p><code>push()</code>方法返回新数组的长度。一开始，数组包含一个元素（字符串<code>&quot;banana&quot;</code>），长度为1。 在数组中添加字符串<code>&quot;apple&quot;</code>后，长度变为2，并将从<code>addToList</code>函数返回。</p><p><code>push</code>方法修改原始数组，如果你想从函数返回数组而不是数组长度，那么应该在push <code>item</code>之后返回<code>list</code>。</p></li></ul><h5 id="57、输出什么"><a href="#57、输出什么" class="headerlink" title="57、输出什么?"></a>57、输出什么?</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function giveLydiaPizza() &#123;</span><br><span class="line">  return &quot;Here is pizza!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const giveLydiaChocolate = () =&gt; &quot;Here&#x27;s chocolate... now go hit the gym already.&quot;</span><br><span class="line"></span><br><span class="line">console.log(giveLydiaPizza.prototype)</span><br><span class="line">console.log(giveLydiaChocolate.prototype)</span><br></pre></td></tr></table></figure><ul><li><p>A: <code>&#123; constructor: ...&#125;</code> <code>&#123; constructor: ...&#125;</code></p></li><li><p>B: <code>&#123;&#125;</code> <code>&#123; constructor: ...&#125;</code></p></li><li><p>C: <code>&#123; constructor: ...&#125;</code> <code>&#123;&#125;</code></p></li><li><p>D: <code>&#123; constructor: ...&#125;</code> <code>undefined</code></p></li><li><p><strong>答案: D</strong></p><p>常规函数，例如<code>giveLydiaPizza</code>函数，有一个<code>prototype</code>属性，它是一个带有<code>constructor</code>属性的对象（原型对象）。 然而，箭头函数，例如<code>giveLydiaChocolate</code>函数，没有这个<code>prototype</code>属性。 尝试使用<code>giveLydiaChocolate.prototype</code>访问<code>prototype</code>属性时会返回<code>undefined</code>。</p></li></ul><h5 id="58、-args是剩余参数，剩余参数的值是一个包含所有剩余参数的数组，并且只能作为最后一个参数。上述示例中，剩余参数是第二个参数，这是不可能的，并会抛出语法错误。"><a href="#58、-args是剩余参数，剩余参数的值是一个包含所有剩余参数的数组，并且只能作为最后一个参数。上述示例中，剩余参数是第二个参数，这是不可能的，并会抛出语法错误。" class="headerlink" title="58、... args是剩余参数，剩余参数的值是一个包含所有剩余参数的数组，并且只能作为最后一个参数。上述示例中，剩余参数是第二个参数，这是不可能的，并会抛出语法错误。"></a>58、<code>... args</code>是剩余参数，剩余参数的值是一个包含所有剩余参数的数组，<strong>并且只能作为最后一个参数</strong>。上述示例中，剩余参数是第二个参数，这是不可能的，并会抛出语法错误。</h5><h5 id="59、输出什么"><a href="#59、输出什么" class="headerlink" title="59、输出什么?"></a>59、输出什么?</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const getList = ([x, ...y]) =&gt; [x, y]</span><br><span class="line">const getUser = user =&gt; &#123; name: user.name, age: user.age &#125;</span><br><span class="line"></span><br><span class="line">const list = [1, 2, 3, 4]</span><br><span class="line">const user = &#123; name: &quot;Lydia&quot;, age: 21 &#125;</span><br><span class="line"></span><br><span class="line">console.log(getList(list))</span><br><span class="line">console.log(getUser(user))</span><br></pre></td></tr></table></figure><ul><li><p>A: <code>[1, [2, 3, 4]]</code> and <code>undefined</code></p></li><li><p>B: <code>[1, [2, 3, 4]]</code> and <code>&#123; name: &quot;Lydia&quot;, age: 21 &#125;</code></p></li><li><p>C: <code>[1, 2, 3, 4]</code> and <code>&#123; name: &quot;Lydia&quot;, age: 21 &#125;</code></p></li><li><p>D: <code>Error</code> and <code>&#123; name: &quot;Lydia&quot;, age: 21 &#125;</code></p></li><li><p><strong>答案: A</strong></p><p><code>getList</code>函数接收一个数组作为其参数。 在<code>getList</code>函数的括号之间，我们立即解构这个数组。 您可以将其视为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, ...y] = [1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p>使用剩余的参数<code>... y</code>，我们将所有剩余参数放在一个数组中。 在这种情况下，其余的参数是<code>2</code>，<code>3</code>和<code>4</code>。 <code>y</code>的值是一个数组，包含所有其余参数。 在这种情况下，<code>x</code>的值等于<code>1</code>，所以当我们打印<code>[x，y]</code>时，会打印<code>[1，[2,3,4]]</code>。</p><p><code>getUser</code>函数接收一个对象。对于箭头函数，如果只返回一个值，我们不必编写花括号。但是，如果您想从一个箭头函数返回一个对象，您必须在圆括号之间编写它，否则不会返回任何值!下面的函数将返回一个对象:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const getUser = user =&gt; (&#123; name: user.name, age: user.age &#125;)</span><br></pre></td></tr></table></figure><p>由于在这种情况下不返回任何值，因此该函数返回<code>undefined</code>。</p></li></ul><h5 id="60、输出什么"><a href="#60、输出什么" class="headerlink" title="60、输出什么?"></a>60、输出什么?</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const output = `$&#123;[] &amp;&amp; &#x27;Im&#x27;&#125;possible!</span><br><span class="line">You should$&#123;&#x27;&#x27; &amp;&amp; `n&#x27;t`&#125; see a therapist after so much JavaScript lol`</span><br></pre></td></tr></table></figure><ul><li><p>A: <code>possible! You should see a therapist after so much JavaScript lol</code></p></li><li><p>B: <code>Impossible! You should see a therapist after so much JavaScript lol</code></p></li><li><p>C: <code>possible! You shouldn&#39;t see a therapist after so much JavaScript lol</code></p></li><li><p>D: <code>Impossible! You shouldn&#39;t see a therapist after so much JavaScript lol</code></p></li><li><p><strong>答案: B</strong></p><p><code>[]</code>是一个真值。 使用<code>&amp;&amp;</code>运算符，如果左侧值是真值，则返回右侧值。 在这种情况下，左侧值<code>[]</code>是一个真值，所以返回<code>Im</code>。</p><p><code>&quot;&quot;</code>是一个假值。 如果左侧值是假的，则不返回任何内容。 <code>n&#39;t</code>不会被退回。</p></li></ul><h5 id="61、结果是什么"><a href="#61、结果是什么" class="headerlink" title="61、结果是什么?"></a>61、结果是什么?</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(5) // Promise &#123;&lt;fulfilled&gt;: 5&#125;</span><br><span class="line">=== let promise = new Promise(resolve =&gt; resolve(5)) 一个reloved的promise</span><br></pre></td></tr></table></figure><h5 id="62、输出什么？"><a href="#62、输出什么？" class="headerlink" title="62、输出什么？"></a>62、输出什么？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function* generatorOne() &#123;</span><br><span class="line">  yield [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function* generatorTwo() &#123;</span><br><span class="line">  yield* [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const one = generatorOne()</span><br><span class="line">const two = generatorTwo()</span><br><span class="line"></span><br><span class="line">console.log(one.next().value)</span><br></pre></td></tr></table></figure><ul><li>A: <code>a</code> and <code>a</code></li><li>B: <code>a</code> and <code>undefined</code></li><li>C: <code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code> and <code>a</code></li><li>D: <code>a</code> and <code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></li><li>在函数 <code>generatorTwo</code> 中, 我们使用 <code>yield*</code> 关键字。就相当于函数<code>two</code>第一个<code>yield</code>的值, 等价于在迭代器中第一个 <code>yield</code> 的值。数组<code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code>就是这个迭代器. 第一个 <code>yield</code> 的值就是 <code>a</code>, 所以我们第一次调用 <code>two.next().value</code>时, 就返回<code>a</code>。</li></ul><h5 id="63、将会发生什么"><a href="#63、将会发生什么" class="headerlink" title="63、将会发生什么?"></a>63、将会发生什么?</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let config = &#123;</span><br><span class="line">  alert: setInterval(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Alert!&#x27;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config = null</span><br></pre></td></tr></table></figure><ul><li>A: <code>setInterval</code> 的回调不会被调用</li><li>B: <code>setInterval</code> 的回调被调用一次</li><li>C: <code>setInterval</code> 的回调仍然会被每秒钟调用</li><li>D: 我们从没调用过 <code>config.alert()</code>, config 为 <code>null</code></li></ul><p><strong>答案: C</strong></p><p>一般情况下当我们将对象赋值为 <code>null</code>, 那些对象会被进行 <em>垃圾回收（garbage collected）</em> 因为已经没有对这些对象的引用了。然而，<code>setInterval</code>的参数是一个箭头函数（所以上下文绑定到对象 <code>config</code> 了），回调函数仍然保留着对 <code>config</code>的引用。只要存在引用，对象就不会被垃圾回收。因为没有被垃圾回收，<code>setInterval</code> 的回调每1000ms (1s)会被调用一次。</p><h5 id="64、Event-Bus不方便之处"><a href="#64、Event-Bus不方便之处" class="headerlink" title="64、Event Bus不方便之处"></a>64、Event Bus不方便之处</h5><p>vue2里面可以用new Vue() 创建对象，调用对象的$enit和$on，在vue3里$on被废弃，只能自己实现或者用第三方的事件管理器(cookie, localStorage, sessionStorage, vuex)</p><p>在想拿到数据之前需要绑定事件监听，在发送数据时需要触发，很麻烦</p><p>对组件的生命周期也会对事件传递产生影响。比如一个组件在触发事件时，另外一个本需要该数据的组件可能尚未初始化未设置监听</p><h5 id="65、vuex和localStorage区别"><a href="#65、vuex和localStorage区别" class="headerlink" title="65、vuex和localStorage区别"></a>65、vuex和localStorage区别</h5><p>localStrage 会让数据永久保存在本地，Vuex只是让当前页面不同组件间能共享数据</p><p>页面刷新时，vuex数据初始化(菜单导航不能把控制变量放在vuex)</p><p>localStorage没有响应式，一个组件对localStorage数据的修改不能让另外一个使用该数据的组件视图重新渲染</p><p>vuex能规范不同组件对全局状态的修改</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arguments 对象的性质和应用</title>
      <link href="/2021/06/04/arguments-dui-xiang-de-xing-zhi-he-ying-yong/"/>
      <url>/2021/06/04/arguments-dui-xiang-de-xing-zhi-he-ying-yong/</url>
      
        <content type="html"><![CDATA[<h1 class="bamboo-h red" id="arguments 对象的性质">arguments 对象的性质</h1><br/><p>arguments 对象是所有函数都具有的一个内置局部变量，表示的是函数实际接收的参数，是一个<strong>类数组</strong>的结构。</p><p>之所以说 arguments 是类数组是因为它除了具有 length 属性外，不具有数组的其他属性。</p><h2 class="bamboo-h " id="函数外部无法访问">函数外部无法访问</h2><br/><p>arguments对象只能在函数内部使用，无法在函数外部访问到 arguments 对象。同时 arguments 对象存在于函数作用域中，一个函数无法直接访问另一个函数的 arguments。</p><blockquote><p>箭头函数没有 “arguments”</p><p>如果我们在箭头函数中访问 arguments，访问到的 arguments 并不属于箭头函数，而是属于箭头函数外部的“普通”函数。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="variable language_">arguments</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>); <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line">fn (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h2 class="bamboo-h " id="可通过索引访问">可通过索引访问</h2><br/><p>arguments 对象是一个类数组结构，可以通过索引访问，每一项表示对应传递的实参值，如果该项索引值不存在，则会返回 undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> (num1, num2) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>]); <span class="comment">// 1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">1</span>]); <span class="comment">// 2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">2</span>]); <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line">fn (<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 class="bamboo-h " id="由实参决定">由实参决定</h2><br/><p>arguments 对象的值有实参决定，而不是由定义的形参决定，形参与 arguments 对象占用独立的内存空间。关于arguments 对象与形参之间的关系，可以总结为以下几点。</p><blockquote><p>1、arguments 对象的 length 属性在函数调用的时候就已经确定，不会随着韩式的处理而变化。</p><p>2、指定的形参在传递实参的形况下，arguments 对象与形参值相同，并且可以互相改变。</p><p>3、指定的形参在未传递实参的情况下，arguments 对象对应索引值返回 undefined。</p><p>4、指定的形参在未传递实参的情况下，arguments 对象于形参值不能相互改变。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> (a, b, c) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">arguments</span>[<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">  b = <span class="number">12</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">1</span>]); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">arguments</span>[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  c = <span class="number">13</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">2</span>]); <span class="comment">// 3</span></span><br><span class="line">  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">fn (<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>通过上面的例子，很好的总结了 arguments 对象的性质。</p><h2 id="arguments-引发的问题：形参失去意义"><a href="#arguments-引发的问题：形参失去意义" class="headerlink" title="arguments 引发的问题：形参失去意义"></a>arguments 引发的问题：形参失去意义</h2><p>我们看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> (a, b, c) &#123;</span><br><span class="line">  <span class="variable language_">arguments</span>[<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 11</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">fn (<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：永远不要直接修改 arguments 对象</strong></p><p>如同上面的例子，arguments 对象与函数的形参的关系及其脆弱。修改 arguments 对象需要承担函数的形参失去意义的风险。在严格模式下，函数参数不支持对arguments对象的修改。</p></blockquote><h1 class="bamboo-h red" id="arguments 对象的应用">arguments 对象的应用</h1><br/><p>既然 arguments 有着致命的确定，那么我们该怎么应用它呢？我们来看下面几个应用。</p><h2 class="bamboo-h " id="实参的个数判断">实参的个数判断</h2><br/><p>定义一个函数，明确要求在调用时只能传递3个参数，如果传递的参数个数不等于3，则直接抛出异常。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> !== <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;传递的参数个数不为3&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 class="bamboo-h " id="任意个数的参数处理">任意个数的参数处理</h2><br/><p>定义一个函数，该函数只会特定处理传递的前几个参数，对于后面的参数不论传递多少个都会统一处理。</p><p>例如：定义一个函数，需求将多个字符串使用分隔符相连，并返回一个结果字符串。此时第一个参数表示分隔符，后面所有的参数表示待相连符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">joinStr</span> (seperator) &#123;</span><br><span class="line">  <span class="comment">// arguments 是一个类数组，并且不能直接操作 arguments</span></span><br><span class="line">  <span class="comment">// 可以通过call()函数间接调用 slice() 函数返回一个新的数组，操作这个数组</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">join</span>(seperator)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">joinStr</span>(<span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>) <span class="comment">// x-y-z</span></span><br><span class="line"><span class="title function_">joinStr</span>(<span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>) <span class="comment">// o,p,q</span></span><br></pre></td></tr></table></figure><h2 class="bamboo-h " id="模拟函数重载">模拟函数重载</h2><br/><p>函数重载就是在程序中有命名一样的函数，通过参数的判断实现相同函数的不同调用。</p><p>javascript 不能实现函数重载，因为命名一样的函数，后面的会把前面的覆盖掉。我们可以使用 arguments 来模拟函数重载。</p><p>定义一个函数，实现多值求和。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span> () &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [...<span class="variable language_">arguments</span>]</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pre + cur</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解 javascript 中的 new 操作符</title>
      <link href="/2021/06/03/shen-ru-liao-jie-javascript-zhong-de-new-cao-zuo-fu/"/>
      <url>/2021/06/03/shen-ru-liao-jie-javascript-zhong-de-new-cao-zuo-fu/</url>
      
        <content type="html"><![CDATA[<div class="note success"><p>new 操作符在执行过程中会改变 this 的指向，所以我们在了解 new 操作符之前，我们先解释一下 this 的用法。</p></div><h2 class="bamboo-h " id="构造函数中 this 的用法">构造函数中 this 的用法</h2><br/><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name, age) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;xx&#x27;</span>, <span class="number">18</span>)); <span class="comment">// Person &#123;name: &#x27;xx&#x27;, age: 18&#125;</span></span><br></pre></td></tr></table></figure><p>输出结果中包含了 name 和 age 的信息。</p><p>事实上，我们并没有通过 return 返回任何值，为什么输出信息中会包含 name 和 age 属性呢？ 其中起作用的就是 this 这个关键字。</p><p>我们通过以下代码输出 this ，看看 this 具体的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name, age) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// Peoson &#123;&#125;</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Person</span> (<span class="string">&#x27;xx&#x27;</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>我们发现 this 的实际值为 Person 空对象，后两句话就相当于给 Person 对象添加 name 和 age 属性，结果真的是这样吗？我们改写一下 Person 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name, age) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="title class_">Person</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="title class_">Person</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Person</span> (<span class="string">&#x27;xx&#x27;</span>, <span class="number">18</span>) <span class="comment">// Person &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>输出结果中并未包含 name 和 age 属性。</p><p>因为在Javascript中，如果构造函数没有 return 值，则默认 return this。而上面代码中，this 实际是一个 Person 空对象，name 和 age 属性只是被添加到了临时变量 Person 中，为了能让输出结果包含 name 和 age 属性，我们将临时变量 Person 进行 return 就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name, age) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">Person</span> = &#123;&#125;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="title class_">Person</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Person</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Person</span> (<span class="string">&#x27;xx&#x27;</span>, <span class="number">18</span>)) <span class="comment">// &#123;name: &quot;xx&quot;, age: 18&#125;</span></span><br></pre></td></tr></table></figure><p>换句话说，new Person 做的就是类似的事情。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="comment">// this = &#123;&#125;;（隐式创建）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加属性到 this</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return this;（隐式返回）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上分析，我们了解了构造函数中 this 的用法。</p><h2 class="bamboo-h " id="this 与 new 操作符的关系">this 与 new 操作符的关系</h2><br/><p>通过 new 操作符生成一个Person 对象的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br></pre></td></tr></table></figure><p>new 操作符做了 3 件事情。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">let</span> person = &#123;&#125;</span><br><span class="line"><span class="number">2.</span>person.<span class="property">__proto__</span> = <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="number">3.</span><span class="title class_">Person</span>.<span class="title function_">call</span>(person)</span><br></pre></td></tr></table></figure><p>我们自定义一个类似 new 功能的函数，来具体讲解上上面的 3 行代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name, age) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">New</span> () &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">New</span>(<span class="string">&#x27;xx&#x27;</span>, <span class="number">18</span>)) <span class="comment">// &#123;name: &quot;xx&quot;, age: 18&#125;</span></span><br></pre></td></tr></table></figure><p>返回的结果中也包含 name 和 age 属性，这就证明了 new 运算符对 this 指向的改变。Person.apply(obj, arguments) 调用后Person对象中的 this 就指向了 obj 对象，这样 obj 对象就具有了 name 和 age 属性。</p><p><strong>但是，不仅关注 new 操作符的函数本身，也要关注它的原型属性。</strong></p><h2 class="bamboo-h " id="prototype 属性与 new 的关系">prototype 属性与 new 的关系</h2><br/><p>我们在 Person 的原型上添加一个 sayHi 函数，然后通过New()返回的对象去调用 sayHi 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name, age) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">New</span>(<span class="string">&#x27;xx&#x27;</span>, <span class="number">18</span>).<span class="title function_">sayHi</span>()) <span class="comment">// Uncaught TypeError: New(...).sayHi is not a function</span></span><br></pre></td></tr></table></figure><p> 我们发现执行报错了，New 函数返回的对象并没有调用sayHi方法。</p><p> 这是因为 sayHi 方法是属于 Person 原型的函数，只有 Person 原型链上的对象才能继承 sayHi 方法。那么我们该怎么做呢?</p><p> 这里用到的就是__proto__属性，实例的__proto__属性指向创建实例的函数的原型。设置 obj 对象的__proto__值为 Person 对象的 prototype 属性，那么 obj 对象就继承了 Person 原型上的 sayHi 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name, age) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">New</span> () &#123;</span><br><span class="line">  <span class="comment">// 另一种写法：let obj = Object.create(Person.prototype)</span></span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  obj.<span class="property">__proto__</span> = <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">New</span>(<span class="string">&#x27;xx&#x27;</span>, <span class="number">18</span>).<span class="title function_">sayHi</span>()) <span class="comment">// Hi</span></span><br></pre></td></tr></table></figure><p> 结果输出 ‘Hi’, 方法调用成功。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v-model 双向数据绑定实现原理</title>
      <link href="/2021/06/01/v-model-shuang-xiang-shu-ju-bang-ding-shi-xian-yuan-li/"/>
      <url>/2021/06/01/v-model-shuang-xiang-shu-ju-bang-ding-shi-xian-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 class="bamboo-h " id="准备工作">准备工作</h2><br/><p>我们来手动实现一个 v-model 的功能。</p><p>首先定义了一个component组件，里面有一个template。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> <span class="title class_">CompOne</span> = &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;input type=&quot;text&quot;&gt;&lt;/input&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再定义一个vue对象，里面引用了该组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="title class_">CompOne</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;comp-one&gt;&lt;/comp-one&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt; </span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;).$mount(root)</span><br></pre></td></tr></table></figure><p>好了，准备工作完成。</p><h2 class="bamboo-h " id="实现">实现</h2><br/><p><img "" class="lazyload placeholder" data-original="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cc2c223924940259fa124c63a96c3e4~tplv-k3u1fbpfcp-watermark.image" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="1.gif"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CompOne</span> = &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;value&#x27;</span>], <span class="comment">// 接收父组件传递的数据</span></span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;input type=&quot;text&quot; @input=&quot;handleInput&quot; :value=&quot;value&quot;&gt;&lt;/input&gt; </span></span><br><span class="line"><span class="string">      // 添加一个input事件</span></span><br><span class="line"><span class="string">      // 接收父组件传递的value</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    handleInput (e) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;input&#x27;</span>, e.<span class="property">target</span>.<span class="property">value</span>) <span class="comment">// 通过$emit，当 value 变化时通知父组件</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img "" class="lazyload placeholder" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af3420cbfa4e4a818b203157ce8e3d7a~tplv-k3u1fbpfcp-watermark.image" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="2.gif"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="title class_">CompOne</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">    // value 为传递给子组件的数据</span></span><br><span class="line"><span class="string">    // @input 接收子组件通过 $emit 传递的参数</span></span><br><span class="line"><span class="string">      &lt;comp-one :value=&quot;value&quot; @input=&quot;value = arguments[0]&quot;&gt;&lt;/comp-one&gt; </span></span><br><span class="line"><span class="string">    &lt;/div&gt; </span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;).$mount(root)</span><br></pre></td></tr></table></figure><h2 class="bamboo-h " id="效果">效果</h2><br/><p><img "" class="lazyload placeholder" data-original="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1428aadc50644b9ad1629983bea1780~tplv-k3u1fbpfcp-watermark.image" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="3.gif"></p><p>大功告成，我们实现了 v-model 的功能！</p><h2 class="bamboo-h " id="拓展">拓展</h2><br/><p> 默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event。</p><p> 但是像单选框、复选框等类型的输入控件可能会将 value attribute 用于不同的目的。model 选项可以用<br> 来避免这样的冲突。<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="title class_">CompOne</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="string">&#x27;vue&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;comp-one v-model=&quot;value&quot;&gt;&lt;/comp-one&gt; // 使用v-model 满足语法糖规则：属性必须为value，方法名必须为：input</span></span><br><span class="line"><span class="string">    &lt;/div&gt; </span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;).$mount(root)</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改子组件 </span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CompOne</span> = &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;value1&#x27;</span>],</span><br><span class="line">  <span class="attr">model</span>: &#123;</span><br><span class="line">      <span class="attr">prop</span>: <span class="string">&quot;value1&quot;</span>, <span class="comment">// 接收的数据 value =&gt; value1</span></span><br><span class="line">      <span class="attr">event</span>: <span class="string">&quot;change&quot;</span> <span class="comment">// $emit 需要绑定的事件 input =&gt; change</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;input type=&quot;text&quot; @input=&quot;handleInput&quot; :value=&quot;value1&quot;&gt;&lt;/input&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    handleInput (e) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;change&#x27;</span>, e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样就可以让 v-model 变得更灵活，属性和方法名可以自定义。</p><h2 class="bamboo-h " id="总结">总结</h2><br/><p>v-model 时一个语法糖，它做了：</p><ol><li><p>绑定数据value</p></li><li><p>触发输入事件input</p></li><li><p>data 更新触发重新渲染</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代JS学习笔记</title>
      <link href="/2021/06/01/xian-dai-js-xue-xi-bi-ji/"/>
      <url>/2021/06/01/xian-dai-js-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、JS简介"><a href="#一、JS简介" class="headerlink" title="一、JS简介"></a>一、JS简介</h2><p>JS既可以运行在浏览器中，也可以运行在服务器端，甚至可以在任意搭载了Javascript引擎的设备中执行。</p><p>现代的 JavaScript 是一种“安全的”编程语言。它不提供对内存或 CPU 的底层访问，因为它最初是为浏览器创建的，不需要这些功能。</p><h3 id="1-引擎是如何工作的？"><a href="#1-引擎是如何工作的？" class="headerlink" title="1.引擎是如何工作的？"></a>1.引擎是如何工作的？</h3><p>引擎很复杂，但是基本原理很简单。</p><ol><li>引擎（如果是浏览器，则引擎被嵌入在其中）读取（“解析”）脚本。</li><li>然后，引擎将脚本转化（“编译”）为机器语言。</li><li>然后，机器代码快速地执行。</li></ol><p>引擎会对流程中的每个阶段都进行优化。它甚至可以在编译的脚本运行时监视它，分析流经该脚本的数据，并根据获得的信息进一步优化机器代码。</p><h3 id="2-同源策略"><a href="#2-同源策略" class="headerlink" title="2.同源策略"></a>2.同源策略</h3><p>不同的标签页/窗口之间通常互不了解。有时候，也会有一些联系，例如一个标签页通过 JavaScript 打开的另外一个标签页。但即使在这种情况下，如果两个标签页打开的不是同一个网站（<strong>域名、协议或者端口任一不相同的网站</strong>），它们都不能相互通信。</p><p>这就是所谓的“同源策略”。为了解决“同源策略”问题，两个标签页必须 <strong>都</strong> 包含一些处理这个问题的特定的 JavaScript 代码，并均允许数据交换。本教程会讲到这部分相关的知识。</p><p>这个限制也是为了用户的信息安全。例如，用户打开的 <code>http://anysite.com</code> 网页必须不能访问 <code>http://gmail.com</code>（另外一个标签页打开的网页）也不能从那里窃取信息。</p><h2 id="二、JS基础知识"><a href="#二、JS基础知识" class="headerlink" title="二、JS基础知识"></a>二、JS基础知识</h2><h3 id="1-现代模式-“use-strict”"><a href="#1-现代模式-“use-strict”" class="headerlink" title="1.现代模式 “use strict”"></a>1.现代模式 “use strict”</h3><p>长久以来，JavaScript 不断向前发展且并未带来任何兼容性问题。新的特性被加入，旧的功能也没有改变。</p><p>这么做有利于兼容旧代码，但缺点是 JavaScript 创造者的任何错误或不完善的决定也将永远被保留在 JavaScript 语言中。</p><p>这种情况一直持续到 2009 年 ECMAScript 5 (ES5) 的出现。<strong>ES5</strong> 规范增加了新的语言特性并且修改了一些已经存在的特性。为了保证旧的功能能够使用，大部分的修改是默认不生效的。你需要一个特殊的指令 —— <code>&quot;use strict&quot;</code> 来明确地激活这些特性。</p><p><strong>没有类似于 <code>&quot;no use strict&quot;</code> 这样的指令可以使程序返回默认模式。 没有办法取消 <code>use strict</code></strong></p><p>现代 JavaScript 支持 “classes” 和 “modules” —— 高级语言结构（本教程后续章节会讲到），它们会自动启用 <code>use strict</code>。因此，如果我们使用它们，则无需添加 <code>&quot;use strict&quot;</code> 指令。</p><p><strong>因此，目前我们欢迎将 <code>&quot;use strict&quot;;</code> 写在脚本的顶部。稍后，当你的代码全都写在了 class 和 module 中时，你则可以将 <code>&quot;use strict&quot;;</code> 这行代码省略掉。</strong></p><h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h3><h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><ol><li>变量名称必须仅包含字母，数字，符号 <code>$</code> 和 <code>_</code>。</li><li>首字符必须非数字。</li></ol><p>如果命名包括多个单词，通常采用驼峰式命名法（<a href="https://en.wikipedia.org/wiki/CamelCase">camelCase</a>）。也就是，单词一个接一个，除了第一个单词，其他的每个单词都以大写字母开头：<code>myVeryLongName</code>。</p><p>有趣的是，美元符号 <code>&#39;$&#39;</code> 和下划线 <code>&#39;_&#39;</code> 也可以用于变量命名。它们是正常的符号，就跟字母一样，没有任何特殊的含义。</p><h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h3><p>在 JavaScript 中有 8 种基本的数据类型（译注：7 种原始类型和 1 种引用类型）。</p><h4 id="数学运算是安全的"><a href="#数学运算是安全的" class="headerlink" title="数学运算是安全的"></a><strong>数学运算是安全的</strong></h4><p>在 JavaScript 中做数学运算是安全的。我们可以做任何事：除以 0，将非数字字符串视为数字，等等。</p><p>脚本永远不会因为一个致命的错误（“死亡”）而停止。最坏的情况下，我们会得到 <code>NaN</code> 的结果。</p><p><strong>在 JavaScript 中，“number” 类型无法表示大于 <code>(253-1)</code>（即 <code>9007199254740991</code>），或小于 <code>-(253-1)</code> 的整数。这是其内部表示形式导致的技术限制。</strong></p><h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><p>在 JavaScript 中，有三种包含字符串的方式。</p><ol><li>双引号：<code>&quot;Hello&quot;</code>.</li><li>单引号：<code>&#39;Hello&#39;</code>.</li><li>反引号：<code>Hello</code>.</li></ol><h4 id="null类型"><a href="#null类型" class="headerlink" title="null类型"></a>null类型</h4><p>相比较于其他编程语言，JavaScript 中的 <code>null</code> 不是一个“对不存在的 <code>object</code> 的引用”或者 “null 指针”。</p><p>JavaScript 中的 <code>null</code> 仅仅是一个代表“无”、“空”或“值未知”的特殊值。</p><p>上面的代码表示 <code>age</code> 是未知的。</p><p>JavaScript的最初版本是这样区分的：<strong>null是一个表示”无”的对象，转为数值时为0；undefined是一个表        示”无”的原始值，转为数值时为NaN。</strong></p><p>现在的用法：</p><p><strong>null表示”没有对象”，即该处不应该有值。</strong></p><p>（1） 作为函数的参数，表示该函数的参数不是对象。</p><p>（2） 作为对象原型链的终点</p><p><strong>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。</strong></p><h4 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h4><p><code>typeof</code> 运算符返回参数的类型。当我们想要分别处理不同类型值的时候，或者想快速进行数据类型检验时，非常有用。</p><p>它支持两种语法形式：</p><ol><li>作为运算符：<code>typeof x</code>。</li><li>函数形式：<code>typeof(x)</code>。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typeof undefined // &quot;undefined&quot;</span><br><span class="line"></span><br><span class="line">typeof 0 // &quot;number&quot;</span><br><span class="line"></span><br><span class="line">typeof 10n // &quot;bigint&quot;</span><br><span class="line"></span><br><span class="line">typeof true // &quot;boolean&quot;</span><br><span class="line"></span><br><span class="line">typeof &quot;foo&quot; // &quot;string&quot;</span><br><span class="line"></span><br><span class="line">typeof Symbol(&quot;id&quot;) // &quot;symbol&quot;</span><br><span class="line"></span><br><span class="line">typeof Math // &quot;object&quot;  (1)</span><br><span class="line"></span><br><span class="line">typeof null // &quot;object&quot;  (2)</span><br><span class="line"></span><br><span class="line">typeof alert // &quot;function&quot;  (3)</span><br></pre></td></tr></table></figure><p><strong><code>null</code> 绝对不是一个 <code>object</code>。<code>null</code> 有自己的类型，它是一个特殊值。</strong></p><p><strong>并非JavaScript中的所有内容都是对象，应该说所有内容都可以充当对象。</strong></p><p>原始类型不是  但是有包装函数，可以有对象的属性和方法</p><h3 id="4-类型转换"><a href="#4-类型转换" class="headerlink" title="4.类型转换"></a>4.类型转换</h3><h4 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h4><p>当我们需要一个字符串形式的值时，就会进行字符串转换。比如，<code>alert(value)</code> 将 <code>value</code> 转换为字符串类型，然后显示这个值。我们也可以显式地调用 <code>String(value)</code> 来将 <code>value</code> 转换为字符串类型：</p><h4 id="数字类型转换"><a href="#数字类型转换" class="headerlink" title="数字类型转换"></a>数字类型转换</h4><p>在算术函数和表达式中，会自动进行 number 类型转换。比如，当把除法 <code>/</code> 用于非 number 类型：</p><p>我们也可以使用 <code>Number(value)</code> 显式地将这个 <code>value</code> 转换为 number 类型。</p><p>当我们从 string 类型源（如文本表单）中读取一个值，但期望输入一个数字时，通常需要进行显式转换。如果该字符串不是一个有效的数字，转换的结果会是 <code>NaN</code>。</p><p>number 类型转换规则：</p><table><thead><tr><th>值</th><th align="center">变成……</th></tr></thead><tbody><tr><td>undefined</td><td align="center">NaN</td></tr><tr><td>null</td><td align="center">0</td></tr><tr><td>true/false</td><td align="center">1/0</td></tr><tr><td>string</td><td align="center">去掉首尾空格后的纯数字字符串中含有的数字。如果剩余字符串为空，则转换结果为 <code>0</code>。否则，将会从剩余字符串中“读取”数字。当类型转换出现 error 时返回 <code>NaN</code>。</td></tr></tbody></table><h4 id="布尔型转换"><a href="#布尔型转换" class="headerlink" title="布尔型转换"></a>布尔型转换</h4><p>转换规则如下：</p><ul><li>直观上为“空”的值（如 <code>0</code>、空字符串、<code>null</code>、<code>undefined</code> 和 <code>NaN</code>）将变为 <code>false</code>。</li><li>其他值变成 <code>true</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot; + 1 + 0 // &#x27;10&#x27;</span><br><span class="line">&quot;&quot; - 1 + 0 // -1</span><br><span class="line">true + false // 1</span><br><span class="line">6 / &quot;3&quot;  // 2</span><br><span class="line">&quot;2&quot; * &quot;3&quot;  // 6</span><br><span class="line">4 + 5 + &quot;px&quot; // &#x27;9px&#x27;</span><br><span class="line">&quot;$&quot; + 4 + 5  // &#x27;$45&#x27;</span><br><span class="line">&quot;4&quot; - 2  // 2</span><br><span class="line">&quot;4px&quot; - 2 // NaN</span><br><span class="line">7 / 0 // infinity</span><br><span class="line">&quot;  -9  &quot; + 5 // &#x27;-9 5&#x27;</span><br><span class="line">&quot;  -9  &quot; - 5 // -14</span><br><span class="line">null + 1 // 1</span><br><span class="line">undefined + 1  // NaN</span><br><span class="line">&quot; \t \n&quot; - 2 // -2</span><br></pre></td></tr></table></figure><h3 id="5-值的比较"><a href="#5-值的比较" class="headerlink" title="5.值的比较"></a>5.值的比较</h3><p>普通的相等性检查 <code>==</code> 存在一个问题，它不能区分出 <code>0</code> 和 <code>false</code>，也同样无法区分空字符串和 <code>false</code></p><p><strong>严格相等运算符 <code>===</code> 在进行比较时不会做任何的类型转换。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert( null &gt; 0 );  // (1) false</span><br><span class="line">alert( null == 0 ); // (2) false</span><br><span class="line">alert( null &gt;= 0 ); // (3) true</span><br></pre></td></tr></table></figure><p>为什么会出现这种反常结果，这是因为相等性检查 <code>==</code> 和普通比较符 <code>&gt; &lt; &gt;= &lt;=</code> 的代码逻辑是相互独立的。进行值的比较时，<code>null</code> 会被转化为数字，因此它被转化为了 <code>0</code>。这就是为什么（3）中 <code>null &gt;= 0</code> 返回值是 true，（1）中 <code>null &gt; 0</code> 返回值是 false。</p><p>另一方面，<code>undefined</code> 和 <code>null</code> 在相等性检查 <code>==</code> 中不会进行任何的类型转换，它们有自己独立的比较规则，所以除了它们之间互等外，不会等于任何其他的值。这就解释了为什么（2）中 <code>null == 0</code> 会返回 false。</p><p><strong>除非你非常清楚自己在做什么，否则永远不要使用 <code>&gt;= &gt; &lt; &lt;=</code> 去比较一个可能为 <code>null/undefined</code> 的变量。对于取值可能是 <code>null/undefined</code> 的变量，请按需要分别检查它的取值情况。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5 &gt; 4  // true</span><br><span class="line">&quot;apple&quot; &gt; &quot;pineapple&quot; // false</span><br><span class="line">&quot;2&quot; &gt; &quot;12&quot; // true</span><br><span class="line">undefined == null // true</span><br><span class="line">undefined === null // false</span><br><span class="line">null == &quot;\n0\n&quot; // false</span><br><span class="line">null === +&quot;\n0\n&quot; // false</span><br></pre></td></tr></table></figure><h3 id="6-空值合并运算符"><a href="#6-空值合并运算符" class="headerlink" title="6.空值合并运算符"></a>6.空值合并运算符</h3><p>如果第一个参数不是 <code>null/undefined</code>，则 <code>??</code> 返回第一个参数。否则，返回第二个参数。空值合并运算符并不是什么全新的东西。它只是一种获得两者中的第一个“已定义的”值的不错的语法。</p><h4 id="与-比较"><a href="#与-比较" class="headerlink" title="与||比较"></a>与||比较</h4><p>它们之间重要的区别是：</p><ul><li><code>||</code> 返回第一个 <strong>真</strong> 值。</li><li><code>??</code> 返回第一个 <strong>已定义的</strong> 值。</li></ul><p>换句话说，<code>||</code> 无法区分 <code>false</code>、<code>0</code>、空字符串 <code>&quot;&quot;</code> 和 <code>null/undefined</code>。它们都一样 —— 假值（falsy values）。如果其中任何一个是 <code>||</code> 的第一个参数，那么我们将得到第二个参数作为结果。</p><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p><code>??</code> 运算符的优先级相当低：在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table">MDN table</a> 中为 <code>5</code>。因此，<code>??</code> 在 <code>=</code> 和 <code>?</code> 之前计算，但在大多数其他运算符（例如，<code>+</code> 和 <code>*</code>）之后计算。</p><p>因此，如果我们需要在还有其他运算符的表达式中使用 <code>??</code> 进行取值，需要考虑加括号</p><h3 id="7-函数"><a href="#7-函数" class="headerlink" title="7.函数"></a>7.函数</h3><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>如果未提供参数，那么其默认值则是 <code>undefined</code>。</p><p>如果我们想在本示例中设定“默认”的 <code>text</code>，那么我们可以在 <code>=</code> 之后指定它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function showMessage(from, text = &quot;no text given&quot;) &#123;</span><br><span class="line">  alert( from + &quot;: &quot; + text );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showMessage(&quot;Ann&quot;); // Ann: no text given</span><br></pre></td></tr></table></figure><p>现在如果 <code>text</code> 参数未被传递，它将会得到值 <code>&quot;no text given&quot;</code>。</p><p>在 JavaScript 中，函数是一个<strong>值</strong>，所以我们可以把它当成值对待。上面代码显示了一段字符串值，即函数的源码。</p><p>的确，在某种意义上说一个函数是一个特殊值，我们可以像 <code>sayHi()</code> 这样调用它。</p><p>但它依然是一个值，所以我们可以像使用其他类型的值一样使用它。</p><h4 id="为什么会有分号？"><a href="#为什么会有分号？" class="headerlink" title="为什么会有分号？"></a>为什么会有分号？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function sayHi() &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let sayHi = function() &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>答案很简单：</p><ul><li>在代码块的结尾不需要加分号 <code>;</code>，像 <code>if &#123; ... &#125;</code>，<code>for &#123; &#125;</code>，<code>function f &#123; &#125;</code> 等语法结构后面都不用加。</li><li>函数表达式是在语句内部的：<code>let sayHi = ...;</code>，作为一个值。它不是代码块而是一个赋值语句。不管值是什么，都建议在语句末尾添加分号 <code>;</code>。所以这里的分号与函数表达式本身没有任何关系，它只是用于终止语句。</li></ul><h4 id="一个函数是表示一个“行为”的值"><a href="#一个函数是表示一个“行为”的值" class="headerlink" title="一个函数是表示一个“行为”的值"></a><strong>一个函数是表示一个“行为”的值</strong></h4><p>字符串或数字等常规值代表 <strong>数据</strong>。</p><p>函数可以被视为一个 <strong>行为（action）</strong>。</p><p>我们可以在变量之间传递它们，并在需要时运行。</p><p><strong>在编程语言中，一等公民可以作为函数参数，可以作为函数返回值，也可以赋值给变量。</strong></p><h2 id="三、对象"><a href="#三、对象" class="headerlink" title="三、对象"></a>三、对象</h2><h3 id="1-计算属性"><a href="#1-计算属性" class="headerlink" title="1.计算属性"></a>1.计算属性</h3><p>当创建一个对象时，我们可以在对象字面量中使用方括号。这叫做 <strong>计算属性</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let fruit = prompt(&quot;Which fruit to buy?&quot;, &quot;apple&quot;);</span><br><span class="line"></span><br><span class="line">let bag = &#123;</span><br><span class="line">  [fruit]: 5, // 属性名是从 fruit 变量中得到的</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert( bag.apple ); // 5 如果 fruit=&quot;apple&quot;</span><br></pre></td></tr></table></figure><p>这里有个小陷阱：一个名为 <code>__proto__</code> 的属性。我们不能将它设置为一个非对象的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line">obj.__proto__ = 5; // 分配一个数字</span><br><span class="line">alert(obj.__proto__); // [object Object] — 值为对象，与预期结果不同</span><br></pre></td></tr></table></figure><p>我们从代码中可以看出来，把它赋值为 <code>5</code> 的操作被忽略了。</p><h3 id="2-属性存在性测试，‘in’操作"><a href="#2-属性存在性测试，‘in’操作" class="headerlink" title="2.属性存在性测试，‘in’操作"></a>2.属性存在性测试，‘in’操作</h3><p>相对于其他语言，javascript的对象中有一个需要特别注意的特性：能够被访问任何属性。即使属性不存在也不会报错！读取不存在的属性只会得到 <code>undefined</code>。所以我们可以很容易地判断一个属性是否存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">alert( user.noSuchProperty === undefined ); // true 意思是没有这个属性</span><br></pre></td></tr></table></figure><p>这里还有一个特别的，检查属性是否存在的操作符 <code>&quot;in&quot;</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;key&quot; in object</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123; name: &quot;John&quot;, age: 30 &#125;;</span><br><span class="line"></span><br><span class="line">alert( &quot;age&quot; in user ); // true，user.age 存在</span><br><span class="line">alert( &quot;blabla&quot; in user ); // false，user.blabla 不存在。</span><br></pre></td></tr></table></figure><p>请注意，<code>in</code> 的左边必须是 <strong>属性名</strong>。通常是一个带引号的字符串。</p><h4 id="in-与-undefined比较"><a href="#in-与-undefined比较" class="headerlink" title="in 与 undefined比较"></a>in 与 undefined比较</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  test: undefined</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert( obj.test ); // 显示 undefined，所以属性不存在？</span><br><span class="line"></span><br><span class="line">alert( &quot;test&quot; in obj ); // true，属性存在！</span><br></pre></td></tr></table></figure><h4 id="对象属性排序"><a href="#对象属性排序" class="headerlink" title="对象属性排序"></a>对象属性排序</h4><p>对象有顺序吗？换句话说，如果我们遍历一个对象，我们获取属性的顺序是和属性添加时的顺序相同吗？这靠谱吗？</p><p>简短的回答是：“有特别的顺序”：整数属性会被进行排序，其他属性则按照创建的顺序显示。</p><p>我们可以使用非整数属性名来 <strong>欺骗</strong> 程序。只需要给每个键名加一个加号 <code>&quot;+&quot;</code> 前缀就行了。</p><h3 id="3-对象的引用和复制"><a href="#3-对象的引用和复制" class="headerlink" title="3.对象的引用和复制"></a>3.对象的引用和复制</h3><p>与原始类型相比，对象的根本区别之一是对象是“通过引用”被存储和复制的，与原始类型值相反：字符串，数字，布尔值等 —— 始终是以“整体值”的形式被复制的。</p><h3 id="4-垃圾回收"><a href="#4-垃圾回收" class="headerlink" title="4.垃圾回收"></a>4.垃圾回收</h3><p>JavaScript 中主要的内存管理概念是 <strong>可达性</strong>。</p><p>简而言之，“可达”值是那些以某种方式可访问或可用的值。它们一定是存储在内存中的。</p><ol><li><p>这里列出固有的可达值的基本集合，这些值明显不能被释放。</p><p>比方说：</p><ul><li>当前函数的局部变量和参数。</li><li>嵌套调用时，当前调用链上所有函数的变量与参数。</li><li>全局变量。</li><li>（还有一些内部的）</li></ul><p>这些值被称作 <strong>根（roots）</strong>。</p></li><li><p>如果一个值可以通过引用或引用链从根访问任何其他值，则认为该值是可达的。</p></li></ol><p><strong>主要需要掌握的内容：</strong></p><ul><li>垃圾回收是自动完成的，我们不能强制执行或是阻止执行。</li><li>当对象是可达状态时，它一定是存在于内存中的。</li><li>被引用与可访问（从一个根）不同：一组相互连接的对象可能整体都不可达。</li></ul><h3 id="5-this"><a href="#5-this" class="headerlink" title="5.this"></a>5.this</h3><p>在 JavaScript 中，<code>this</code> 是“自由”的，它的值是在调用时计算出来的，它的值并不取决于方法声明的位置，而是取决于在“点符号前”的是什么对象。</p><p>以“方法”的语法调用函数时：<code>object.method()</code>，调用过程中的 <code>this</code> 值是 <code>object</code>。</p><h3 id="6-构造器和操作符‘new’"><a href="#6-构造器和操作符‘new’" class="headerlink" title="6.构造器和操作符‘new’"></a>6.构造器和操作符‘new’</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>当一个函数被使用 <code>new</code> 操作符执行时，它按照以下步骤：</p><ol><li>一个新的空对象被创建并分配给 <code>this</code>。这个新对象会被执行[[prototype]]连接</li><li>函数体执行。通常它会修改 <code>this</code>，为其添加新的属性。</li><li>返回 <code>this</code> 的值。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function User(name) &#123;</span><br><span class="line">  // this = &#123;&#125;;（隐式创建）</span><br><span class="line"></span><br><span class="line">  // 添加属性到 this</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.isAdmin = false;</span><br><span class="line"></span><br><span class="line">  // return this;（隐式返回）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这是构造器的主要目的 —— 实现可重用的对象创建代码。</strong></p><h4 id="构造器的return"><a href="#构造器的return" class="headerlink" title="构造器的return"></a>构造器的return</h4><p>通常，构造器没有 <code>return</code> 语句。它们的任务是将所有必要的东西写入 <code>this</code>，并自动转换为结果。</p><p>但是，如果这有一个 <code>return</code> 语句，那么规则就简单了：</p><ul><li><strong>如果 <code>return</code> 返回的是一个对象，则返回这个对象，而不是 <code>this</code>。</strong></li><li>如果 <code>return</code> 返回的是一个原始类型，则忽略。</li></ul><p>换句话说，带有对象的 <code>return</code> 返回该对象，在所有其他情况下返回 <code>this</code>。</p><p>例如，这里 <code>return</code> 通过返回一个对象覆盖 <code>this</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function BigUser() &#123;</span><br><span class="line"></span><br><span class="line">  this.name = &quot;John&quot;;</span><br><span class="line"></span><br><span class="line">  return &#123; name: &quot;Godzilla&quot; &#125;;  // &lt;-- 返回这个对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert( new BigUser().name );  // Godzilla，得到了那个对象</span><br></pre></td></tr></table></figure><h3 id="7-可选链"><a href="#7-可选链" class="headerlink" title="7.可选链?."></a>7.可选链?.</h3><h4 id="‘不存在属性’的问题"><a href="#‘不存在属性’的问题" class="headerlink" title="‘不存在属性’的问题"></a>‘不存在属性’的问题</h4><p>我们大多数用户的地址都存储在 <code>user.address</code> 中，街道地址存储在 <code>user.address.street</code> 中，但有些用户没有提供这些信息。</p><p>在这种情况下，当我们尝试获取 <code>user.address.street</code>，而该用户恰好没提供地址信息，我们则会收到一个错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;&#125;; // 一个没有 &quot;address&quot; 属性的 user 对象</span><br><span class="line"></span><br><span class="line">alert(user.address.street); // Error!</span><br></pre></td></tr></table></figure><h4 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h4><p><strong>为了简明起见，在本文接下来的内容中，我们会说如果一个属性既不是 <code>null</code> 也不是 <code>undefined</code>，那么它就“存在”。</strong></p><p>换句话说，例如 <code>value?.prop</code>：</p><ul><li>如果 <code>value</code> 存在，则结果与 <code>value.prop</code> 相同，</li><li>否则（当 <code>value</code> 为 <code>undefined/null</code> 时）则返回 <code>undefined</code>。</li></ul><p>下面这是一种使用 <code>?.</code> 安全地访问 <code>user.address.street</code> 的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;&#125;; // user 没有 address 属性</span><br><span class="line"></span><br><span class="line">alert( user?.address?.street ); // undefined（不报错）</span><br></pre></td></tr></table></figure><p><strong>我们可以使用</strong> <code>?.</code> <strong>来安全地读取或删除，但不能写入</strong></p><h3 id="8-Sysmbol类型"><a href="#8-Sysmbol类型" class="headerlink" title="8.Sysmbol类型"></a>8.Sysmbol类型</h3><p>根据规范，对象的属性键只能是字符串类型或者 Symbol 类型。不是 Number，也不是 Boolean，只有字符串或 Symbol 这两种类型。</p><h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p>‘symbol’值表示唯一的标识符</p><p>可以使用symbol() 创建这种类型的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// id 是 symbol 的一个实例化对象</span><br><span class="line">let id = Symbol();</span><br></pre></td></tr></table></figure><p>创建时，我们可以给 Symbol 一个描述（也称为 Symbol 名），这在代码调试时非常有用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// id 是描述为 &quot;id&quot; 的 Symbol</span><br><span class="line">let id = Symbol(&quot;id&quot;);</span><br></pre></td></tr></table></figure><p>Symbol 保证是唯一的。即使我们创建了许多具有相同描述的 Symbol，它们的值也是不同。描述只是一个标签，不影响任何东西。</p><p>例如，这里有两个描述相同的 Symbol —— 它们不相等：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let id1 = Symbol(&quot;id&quot;);</span><br><span class="line">let id2 = Symbol(&quot;id&quot;);</span><br><span class="line"></span><br><span class="line">alert(id1 == id2); // false</span><br></pre></td></tr></table></figure><h4 id="Symbol不会被自动转换为字符串"><a href="#Symbol不会被自动转换为字符串" class="headerlink" title="Symbol不会被自动转换为字符串"></a>Symbol不会被自动转换为字符串</h4><p>JavaScript 中的大多数值都支持字符串的隐式转换。例如，我们可以 <code>alert</code> 任何值，都可以生效。Symbol 比较特殊，它不会被自动转换。</p><p>例如，这个 <code>alert</code> 将会提示出错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let id = Symbol(&quot;id&quot;);</span><br><span class="line">alert(id); // 类型错误：无法将 Symbol 值转换为字符串。</span><br></pre></td></tr></table></figure><p>如果我们真的想显示一个 Symbol，我们需要在它上面调用 <code>.toString()</code>，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let id = Symbol(&quot;id&quot;);</span><br><span class="line">alert(id.toString()); // Symbol(id)，现在它有效了</span><br></pre></td></tr></table></figure><p>或者获取 <code>symbol.description</code> 属性，只显示描述（description）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let id = Symbol(&quot;id&quot;);</span><br><span class="line">alert(id.description); // id</span><br></pre></td></tr></table></figure><h4 id="隐藏属性"><a href="#隐藏属性" class="headerlink" title="隐藏属性"></a>隐藏属性</h4><p>Symbol 允许我们创建对象的“隐藏”属性，代码的任何其他部分都不能意外访问或重写这些属性。</p><p>例如，如果我们使用的是属于第三方代码的 <code>user</code> 对象，我们想要给它们添加一些标识符。</p><p>我们可以给它们使用 Symbol 键：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="comment">// 属于另一个代码</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">user[id] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( user[id] ); <span class="comment">// 我们可以使用 Symbol 作为键来访问数据</span></span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a> 会同时复制字符串和 symbol 属性</p><p><code>Object.keys(user)</code> 也会忽略它们。这是一般“隐藏符号属性”原则的一部分。如果另一个脚本或库遍历我们的对象，它不会意外地访问到符号属性。</p><h4 id="全局Symbol"><a href="#全局Symbol" class="headerlink" title="全局Symbol"></a>全局Symbol</h4><p>正如我们所看到的，通常所有的 Symbol 都是不同的，即使它们有相同的名字。但有时我们想要名字相同的 Symbol 具有相同的实体。例如，应用程序的不同部分想要访问的 Symbol <code>&quot;id&quot;</code> 指的是完全相同的属性。</p><p>为了实现这一点，这里有一个 <strong>全局 Symbol 注册表</strong>。我们可以在其中创建 Symbol 并在稍后访问它们，它可以确保每次访问相同名字的 Symbol 时，返回的都是相同的 Symbol。</p><p>要从注册表中读取（不存在则创建）Symbol，请使用 <code>Symbol.for(key)</code>。</p><p>该调用会检查全局注册表，如果有一个描述为 <code>key</code> 的 Symbol，则返回该 Symbol，否则将创建一个新 Symbol（<code>Symbol(key)</code>），并通过给定的 <code>key</code> 将其存储在注册表中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 从全局注册表中读取</span><br><span class="line">let id = Symbol.for(&quot;id&quot;); // 如果该 Symbol 不存在，则创建它</span><br><span class="line"></span><br><span class="line">// 再次读取（可能是在代码中的另一个位置）</span><br><span class="line">let idAgain = Symbol.for(&quot;id&quot;);</span><br><span class="line"></span><br><span class="line">// 相同的 Symbol</span><br><span class="line">alert( id === idAgain ); // true</span><br></pre></td></tr></table></figure><h4 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor"></a>Symbol.keyFor</h4><p>对于全局 Symbol，不仅有 <code>Symbol.for(key)</code> 按名字返回一个 Symbol，还有一个反向调用：<code>Symbol.keyFor(sym)</code>，它的作用完全反过来：通过全局 Symbol 返回一个名字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 通过 name 获取 Symbol</span><br><span class="line">let sym = Symbol.for(&quot;name&quot;);</span><br><span class="line">let sym2 = Symbol.for(&quot;id&quot;);</span><br><span class="line"></span><br><span class="line">// 通过 Symbol 获取 name</span><br><span class="line">alert( Symbol.keyFor(sym) ); // name</span><br><span class="line">alert( Symbol.keyFor(sym2) ); // id</span><br></pre></td></tr></table></figure><p><code>Symbol.keyFor</code> 内部使用全局 Symbol 注册表来查找 Symbol 的键。所以它不适用于非全局 Symbol。如果 Symbol 不是全局的，它将无法找到它并返回 <code>undefined</code>。</p><p><strong>也就是说，任何 Symbol 都具有 <code>description</code> 属性。</strong></p><h2 id="四、数据类型"><a href="#四、数据类型" class="headerlink" title="四、数据类型"></a>四、数据类型</h2><p>函数 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed">toFixed(n)</a> 将数字舍入到小数点后 <code>n</code> 位，并以<strong>字符串</strong>形式返回结果。</p><p>有一个特殊的内建方法 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/is"><code>Object.is</code></a>，它类似于 <code>===</code> 一样对值进行比较，但它对于两种边缘情况更可靠：</p><ol><li>它适用于 <code>NaN</code>：<code>Object.is（NaN，NaN）=== true</code>，这是件好事。</li><li>值 <code>0</code> 和 <code>-0</code> 是不同的：<code>Object.is（0，-0）=== false</code>，从技术上讲这是对的，因为在内部，数字的符号位可能会不同，即使其他所有位均为零。</li></ol><p>在所有其他情况下，<code>Object.is(a，b)</code> 与 <code>a === b</code> 相同。</p><p>这种比较方式经常被用在 JavaScript 规范中。当内部算法需要比较两个值是否完全相同时，它使用 <code>Object.is</code>（内部称为 <a href="https://tc39.github.io/ecma262/#sec-samevalue">SameValue</a>）。</p><p><strong>结论：在处理小数时避免相等性检查。</strong></p><p>在 <code>if</code> 测试中 <code>indexOf</code> 有一点不方便。我们不能像这样把它放在 <code>if</code> 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;Widget with id&quot;;</span><br><span class="line"></span><br><span class="line">if (str.indexOf(&quot;Widget&quot;)) &#123;</span><br><span class="line">    alert(&quot;We found it&quot;); // 不工作！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例中的 <code>alert</code> 不会显示，因为 <code>str.indexOf(&quot;Widget&quot;)</code> 返回 <code>0</code>（意思是它在起始位置就查找到了匹配项）。是的，但是 <code>if</code> 认为 <code>0</code> 表示 <code>false</code>。</p><p>因此我们应该检查 <code>-1</code>，像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;Widget with id&quot;;</span><br><span class="line"></span><br><span class="line">if (str.indexOf(&quot;Widget&quot;) != -1) &#123;</span><br><span class="line">    alert(&quot;We found it&quot;); // 现在工作了！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">方法</th><th align="left">选择方式……</th><th align="left">负值参数</th></tr></thead><tbody><tr><td align="left"><code>slice(start, end)</code></td><td align="left">从 <code>start</code> 到 <code>end</code>（不含 <code>end</code>）</td><td align="left">允许</td></tr><tr><td align="left"><code>substring(start, end)</code></td><td align="left"><code>start</code> 与 <code>end</code> 之间（包括 <code>start</code>，但不包括 <code>end</code>）</td><td align="left">负值代表 <code>0</code></td></tr><tr><td align="left"><code>substr(start, length)</code></td><td align="left">从 <code>start</code> 开始获取长为 <code>length</code> 的字符串</td><td align="left">允许 <code>start</code> 为负数</td></tr></tbody></table><p>写一个函数 <code>ucFirst(str)</code>，并返回首字母大写的字符串 <code>str</code>，例如：</p><p><strong>这里存在一个小问题。如果 <code>str</code> 是空的，那么 <code>str[0]</code> 就是 <code>undefined</code>，但由于 <code>undefined</code> 并没有 <code>toUpperCase()</code> 方法，因此我们会得到一个错误。</strong></p><ol><li>使用 <code>str.charAt(0)</code>，因为它总是会返回一个字符串（可能为空）。</li><li>为空字符添加测试。</li></ol><h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h3><h4 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h4><p>数组是对象，所以我们可以尝试使用 <code>delete</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&quot;I&quot;, &quot;go&quot;, &quot;home&quot;];</span><br><span class="line"></span><br><span class="line">delete arr[1]; // remove &quot;go&quot;</span><br><span class="line"></span><br><span class="line">alert( arr[1] ); // undefined</span><br><span class="line"></span><br><span class="line">// now arr = [&quot;I&quot;,  , &quot;home&quot;];</span><br><span class="line">alert( arr.length ); // 3</span><br></pre></td></tr></table></figure><p>元素被删除了，但数组仍然有 3 个元素，我们可以看到 <code>arr.length == 3</code>。</p><p>这很正常，因为 <code>delete obj.key</code> 是通过 <code>key</code> 来移除对应的值。对于对象来说是可以的。但是对于数组来说，我们通常希望剩下的元素能够移动并占据被释放的位置。我们希望得到一个更短的数组。</p><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/splice">arr.splice</a> 方法可以说是处理数组的瑞士军刀。它可以做所有事情：添加，删除和插入元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.splice(start[, deleteCount, elem1, ..., elemN])</span><br></pre></td></tr></table></figure><h4 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.slice([start], [end])</span><br></pre></td></tr></table></figure><p>它会返回一个新数组，将所有从索引 <code>start</code> 到 <code>end</code>（不包括 <code>end</code>）的数组项复制到一个新的数组。<code>start</code> 和 <code>end</code> 都可以是负数，在这种情况下，从末尾计算索引。</p><h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h4><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/concat">arr.concat</a> 创建一个新数组，其中包含来自于其他数组和其他项的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.concat(arg1, arg2...)</span><br></pre></td></tr></table></figure><h4 id="arr-forEach"><a href="#arr-forEach" class="headerlink" title="arr.forEach"></a>arr.forEach</h4><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">arr.forEach</a> 方法允许为数组的每个元素都运行一个函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(function(item, index, array) &#123;</span><br><span class="line">  // ... do something with item</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果我们想检查是否包含某个元素，并且不想知道确切的索引，那么 <code>arr.includes</code> 是首选。</p><p>此外，<code>includes</code> 的一个非常小的差别是它能正确处理<code>NaN</code>，而不像 <code>indexOf/lastIndexOf</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr = [NaN];</span><br><span class="line">alert( arr.indexOf(NaN) ); // -1（应该为 0，但是严格相等 === equality 对 NaN 无效）</span><br><span class="line">alert( arr.includes(NaN) );// true（这个结果是对的）</span><br></pre></td></tr></table></figure><p><strong>我们已经知道，箭头函数没有自身的 <code>this</code>。现在我们知道了它们也没有特殊的 <code>arguments</code> 对象。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习 Vue 原理：响应式</title>
      <link href="/2021/05/30/xue-xi-vue-yuan-li-xiang-ying-shi/"/>
      <url>/2021/05/30/xue-xi-vue-yuan-li-xiang-ying-shi/</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>近来在学习Vue，对于它的核心概念之一——响应式一直有所困惑，偶然间发现一门课程vue advanced workshop with Evan You。Vue的作者尤雨溪亲自讲解Vue。下面是对该课程学习的总结。欢迎大家参考和提出意见。</p></div><h2 class="bamboo-h " id="什么是响应式？">什么是响应式？</h2><br/><p>响应式是 Vue的一个核心特性，用于监听视图中绑定的数据，当数据发生改变时视图自动更新。</p><p>只要状态发生改变，系统依赖部分发生自动更新就可以称为响应性。</p><p>在web的场景下，就是不断变化的状态反应到DOM上的变化。</p><p>响应式实现数据驱动视图的第一步。</p><h2 class="bamboo-h " id="数据驱动视图">数据驱动视图</h2><br/><p>现在有这样一个例子：</p><blockquote><p>变量 a 和变量 b ，变量 b 的值永远等于 a 的 10 倍。</p></blockquote><p>如果使用命令式编程，可以很简单实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> b = a * <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>但是当我们设置 b 的值为 4 时， b 还是等于 30</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> b = a * <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">// 30</span></span><br><span class="line">a = <span class="number">4</span>; <span class="comment">// 命令式，b不会保持关系同步</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>那么该如何实现当a改变时，b同时也改变呢？</p><blockquote><p>这里有一个神奇的函数onChanged()，它接收一个函数并且当 a 的值改变时，可以自动执行里面的代码，我们将 b 的更新放在里面，问题就解决了。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onChanged (<span class="function">() =&gt;</span> b = a * <span class="number">10</span> ) <span class="comment">// 声明式, b 随着 a 改变而改变</span></span><br></pre></td></tr></table></figure><p>我们扩展一下，下面代码同样有一个神奇函数onStateChange，它会在 state 改变的时候自动运行，那我们只要在函数中编写dom操作的代码，就可以实现 dom 的自动更新了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DOM元素</span></span><br><span class="line">&lt;span <span class="keyword">class</span>=<span class="string">&quot;cell b1&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 神奇函数，当state值改变会自动重新运行</span></span><br><span class="line"><span class="title function_">onStateChange</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.cell.b1&#x27;</span>).<span class="property">textContent</span> = state.<span class="property">a</span> * <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们再进一步抽象，把 dom 的操作使用渲染引擎替换，但是我们不去研究渲染引擎的实现，只是简单的认为它会自动解析模版代码与数据关联即可，那代码就会变成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DOM元素</span></span><br><span class="line">&lt;span <span class="keyword">class</span>=<span class="string">&quot;cell b1&quot;</span>&gt;</span><br><span class="line">&#123;&#123; state.<span class="property">a</span> * <span class="number">10</span> &#125;&#125;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 神奇函数，当state值改变会自动重新运行</span></span><br><span class="line"><span class="title function_">onStateChange</span>(<span class="function">() =&gt;</span> &#123; view = <span class="title function_">render</span>(state) &#125;)</span><br></pre></td></tr></table></figure><h2 class="bamboo-h " id="如何实现响应式">如何实现响应式</h2><br/><h3 class="bamboo-h warning" id="getter 和 setter">getter 和 setter</h3><br/><p>Vue 中对象会被转换成响应式， 使用ES5的 defineProperty() 重写所有属性的 getter 和 setter 方法。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/web/javascript/reference/global_objects/object/defineproperty">MDN上关于Object.defineProperty的介绍</a></p><p>下面将演示如何通过convert函数修改传入对象的getter和setter实现修改对象属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">convert</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> internalValue = obj[key] <span class="comment">// 闭包，提供了存储机会 内部值</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">get () &#123;</span><br><span class="line"><span class="keyword">return</span> internalValue</span><br><span class="line">&#125;,</span><br><span class="line">set (newValue) &#123;</span><br><span class="line">internalValue = newValue</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 class="bamboo-h warning" id="依赖跟踪（订阅发布模式）">依赖跟踪（订阅发布模式）</h3><br/><h4 class="bamboo-h red" id="为什么要依赖收集？">为什么要依赖收集？</h4><br/><p>先来看下面的代码</p><figure class="highlight plaintext"><figcaption><span>Vue(&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    template: </span><br><span class="line">        `&lt;div&gt;</span><br><span class="line">            &lt;span&gt;text1:&lt;/span&gt; &#123;&#123;text1&#125;&#125;</span><br><span class="line">        &lt;div&gt;`,</span><br><span class="line">    data: &#123;</span><br><span class="line">        text1: &#x27;text1&#x27;,</span><br><span class="line">        text2: &#x27;text2&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>按照之前响应式中的方法进行绑定则会出现一个问题——text3在实际模板中并没有被用到，然而当text3的数据被修改（this.text3 = ‘test’）的时候，同样会触发text3的setter导致重新执行渲染，这显然不正确。</p><p>所以我们要进行<strong>依赖收集</strong>。</p><h4 class="bamboo-h red" id="如何实现？">如何实现？</h4><br/><p><strong>创建一个依赖跟踪类Dep，里面有两个方法：’depend’ ‘notify’。</strong></p><p>‘depend’: 收集这种依赖项。</p><p>‘notify’: 表示依赖发生改变，任何之前被定义为依赖的表达式、函数、计算都会被通知重新执行。也就是说我们需要找到一种让他们建立关联的方法。我们把这种计算关系叫依赖。这种计算也被认为是订阅者模式。<br>下面是Dep类期望达到的效果，调用dep.depend方法收集收集依赖，当调用dep.notify方法，控制台会再次输出updated语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line"></span><br><span class="line">autorun (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">dep.<span class="title function_">depend</span>() <span class="comment">// 实际上是把这个函数添加到订阅者列表中dep中,之后无论你在任何地方调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;updated&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// should log: &quot;updated&quot;</span></span><br><span class="line"></span><br><span class="line">dep.<span class="title function_">notify</span>()</span><br><span class="line"><span class="comment">// 函数再次被调用 should log: &quot;updated&quot; autorun</span></span><br></pre></td></tr></table></figure><p>这个 autorun 函数接收一个更新函数或者表达式，当你进入这个更新函数时，一切都变得特别，当代码放在这个响应区内，就可以通过dep.depend 方法注册依赖项。</p><p>代码实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">Dep</span> = <span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span> () &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">subsctibers</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">&#125;</span><br><span class="line">depend () &#123;</span><br><span class="line"><span class="keyword">if</span> (activeUpdate) &#123;</span><br><span class="line"><span class="comment">// 注册这个activeUpdate作为订阅者</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">add</span>(activeUpdate)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">notify () &#123;</span><br><span class="line"><span class="comment">// 通知所有订阅者</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">sub</span> =&gt;</span> <span class="title function_">sub</span>()) <span class="comment">// 获取订阅函数并执行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> activeUpdate <span class="comment">// 发布者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">autorun</span> (update) &#123;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">wrappedUpdate</span> () &#123;</span><br><span class="line">activeUpdate = wrappedUpdate <span class="comment">// 赋值给 wrappedUpdate 会使得当依赖关系发生改变update 函数会重新执行 动态更新依赖 保证依赖一直是最新的</span></span><br><span class="line"><span class="title function_">update</span>()</span><br><span class="line">wrappedUpdate = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">updateWrapper</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">autorun</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">dep.<span class="title function_">depend</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 class="bamboo-h warning" id="实现迷你响应性系统">实现迷你响应性系统</h3><br/><p>结合前面两个函数convert() autorun() 将covert改名成observe()。<br>observer需要一个监听对象，监听他们得getter和setter，在getters和setters里面，我们可以设置依赖。<br>都整合后我们相当于创建了一个对象，我们访问一个属性，它收集依赖，调用dep.depend 当我们通过赋值改变属性值，调用notify触发改变。</p><p>期望实现的调用效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line"><span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">observe</span>(state)</span><br><span class="line"></span><br><span class="line"><span class="title function_">autorun</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">count</span>))</span><br><span class="line"><span class="comment">// should immediately log &quot;count is: 0&quot;</span></span><br><span class="line"></span><br><span class="line">state.<span class="property">count</span> ++</span><br><span class="line"><span class="comment">// should log &quot;count is: 1&quot;</span></span><br></pre></td></tr></table></figure><p>最终整合代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeUpdate) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">add</span>(activeUpdate)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">sub</span> =&gt;</span> <span class="title function_">sub</span>())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span> (obj) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> internalValue = obj[key]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">      <span class="comment">// 在getter收集依赖项，当触发notify时重新运行</span></span><br><span class="line">      get () &#123;</span><br><span class="line">        dep.<span class="title function_">depend</span>()</span><br><span class="line">        <span class="keyword">return</span> internalValue</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// setter用于调用notify</span></span><br><span class="line">      set (newVal) &#123;</span><br><span class="line">        <span class="keyword">if</span> (internalValue !== newVal) &#123;</span><br><span class="line">          internalValue = newVal</span><br><span class="line">          dep.<span class="title function_">notify</span>()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> activeUpdate = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">autorun</span> (update) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">wrappedUpdate</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    activeUpdate = wrappedUpdate</span><br><span class="line">    <span class="title function_">update</span>()</span><br><span class="line">    activeUpdate = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">wrappedUpdate</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上都是基于个人的理解，写的学习笔记，欢迎大家提出建议。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组去重的4种算法</title>
      <link href="/2021/05/30/shu-zu-qu-chong-de-4-chong-suan-fa/"/>
      <url>/2021/05/30/shu-zu-qu-chong-de-4-chong-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>存在一个数组<code>[1, 3, 5, 7, 9, 1, 5, 9]</code></p><p>通过一定的算法，得到数组<code>[1, 3, 5, 7, 9]</code></p><h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arrUnique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!result.<span class="title function_">includes</span>(k)) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(k)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">arrUnique</span>(arr) )</span><br></pre></td></tr></table></figure><h2 id="利用对象键值对"><a href="#利用对象键值对" class="headerlink" title="利用对象键值对"></a>利用对象键值对</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arrUnique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> val = arr[i]</span><br><span class="line">    <span class="keyword">if</span> (!obj[val]) &#123;</span><br><span class="line">      obj[val] = <span class="literal">true</span></span><br><span class="line">      result.<span class="title function_">push</span>(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">arrUnique</span>(arr))</span><br></pre></td></tr></table></figure><h2 id="先排序，再去重"><a href="#先排序，再去重" class="headerlink" title="先排序，再去重"></a>先排序，再去重</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arrUnique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [arr[<span class="number">0</span>]]</span><br><span class="line">  arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] !== result[result.<span class="property">length</span> - <span class="number">1</span>]) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">arrUnique</span>(arr))</span><br></pre></td></tr></table></figure><h2 id="借助ES6的Set数据结构"><a href="#借助ES6的Set数据结构" class="headerlink" title="借助ES6的Set数据结构"></a>借助ES6的Set数据结构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arrUnique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">arrUnique</span>(arr))</span><br></pre></td></tr></table></figure><p>1</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三种类型检查方法：typeof、instanceof 和 Object.prototype.toString</title>
      <link href="/2021/05/29/san-chong-lei-xing-jian-cha-fang-fa-typeof-instanceof-he-object.prototype.tostring/"/>
      <url>/2021/05/29/san-chong-lei-xing-jian-cha-fang-fa-typeof-instanceof-he-object.prototype.tostring/</url>
      
        <content type="html"><![CDATA[<h2 class="bamboo-h " id="typeof 运算符,">typeof 运算符,</h2><br/><p>typeof 运算符返回参数的类型。当我们想要分别处理不同类型值的时候，或者想快速进行数据类型检验时，非常有用。 它支持两种语法形式：</p><ul><li>作为运算符：typeof x。</li><li>函数形式：typeof(x)。</li></ul><p>括号有的时候时必须的，如果不加上括号将会因为优先级的问题得不到我们想要的结果。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;string&#x27;</span> === <span class="literal">true</span>; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">typeof</span> (<span class="string">&#x27;string&#x27;</span> === <span class="literal">true</span>); <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>对 typeof x 的调用会以<strong>字符串</strong>的形式返回数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">0</span> <span class="comment">// &quot;number&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">10n</span> <span class="comment">// &quot;bigint&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;foo&quot;</span> <span class="comment">// &quot;string&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>) <span class="comment">// &quot;symbol&quot; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Math</span> <span class="comment">// &quot;object&quot;  (1) // 任何其他对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &quot;object&quot;  (2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> alert <span class="comment">// &quot;function&quot;  (3) // 函数对象</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>最后三行可能需要额外的说明：</p><ol><li>Math 是一个提供数学运算的内建 object。</li><li>typeof null 的结果是 “object”。这是官方承认的 typeof 的行为上的错误，这个问题来自于 JavaScript 语言的早期，并为了兼容性而保留了下来。null 绝对不是一个 object。null 有自己的类型，它是一个特殊值。</li><li>typeof alert 的结果是 “function”，因为 alert 在 JavaScript 语言中是一个函数。在 JavaScript 语言中没有一个特别的 “function” 类型。函数隶属于 object 类型。但是 typeof 会对函数区分对待，并返回 “function”。这也是来自于 JavaScript 语言早期的问题。从技术上讲，这种行为是不正确的，但在实际编程中却非常方便。</li></ol><p>另外 typeof 处理包装类型的时候会返回对应的原始数据类型。但是不推荐这样写。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">typeof</span> <span class="title class_">Number</span>(<span class="number">1</span>); <span class="comment">// &quot;number&quot;</span></span><br><span class="line">        <span class="keyword">typeof</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>); <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line">        <span class="keyword">typeof</span> <span class="title class_">String</span>(<span class="string">&#x27;string&#x27;</span>); <span class="comment">// &quot;string&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 class="bamboo-h warning" id="typeof 运算符区别对待Object类型和Function类型">typeof 运算符区别对待Object类型和Function类型</h3><br/><p>从技术角度讲，函数在ECMAScript中是对象，不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过typeof 运算符来区分函数和其他对象是有必要的。</p><h3 class="bamboo-h warning" id="typeof 运算符对null的处理">typeof 运算符对null的处理</h3><br/><p>这个bug是第一版Javascript留下来的，javascript中不同对象在底层都表示为二进制，而javascript 中每种数据类型使用3bit表示，会把二进制前三位都为0的判断为object类型。</p><ul><li>000 表示Object类型的数据。</li><li>001 表示Int类型的数据。</li><li>010 表示Double类型的数据。</li><li>100 表示String类型的数据。</li><li>110 表示Boolean类型的数据。</li></ul><p>由于null代表空指针，大多数平台中值为0x00，因此null的类型标签就成了0，所以执行typeof时会返回 ‘object’。<br>% title h2, instanceof运算符 %}</p><p>% title h3,判断一个变量是数组还是对象, warning %}</p><p>首先我们试着用 typeof 运算符进行测试。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> arr) <span class="comment">// &quot;object&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>发现输出结果为”object”，这并不是我们期望的结果。 所以使用 typeof 运算符并不能直接判断一个变量时对象还是数组类型。实际上，typeof 运算符在判断基本数据类型时会很有用，但是在判断引用市局类型时，却显得很吃力。</p><p>接下来我们试着用 instanceof 运算符进行测试。</p><p><strong>instance运算符用于通过查找原型链来检测某个变量是否为某个类型数据的实例</strong>。使用instanceof 运算符可以判断一个变量时数组还是对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">const</span> a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> b = &#123;<span class="attr">name</span>: <span class="string">&#x27;xx&#x27;</span>&#125;;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(b <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// false</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(b <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>有一点需要留意，a 同时还隶属于 Object 类。因为从原型上来讲，Array 是继承自 Object 的。instanceof 在检查中会将原型链考虑在内。 因此我们在判断一个变量时数组还是对象时，应该先判断数组类型，然后再去判断对象类型。如果先判断对象，那么数组值也会被判断为对象类型，这无法满足要求。</p><p>我们可以得到以下的封装函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">function</span> <span class="title function_">getDataType</span> (o) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> <span class="title class_">Array</span>) <span class="keyword">return</span> <span class="string">&#x27;Array&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> <span class="title class_">Object</span>) <span class="keyword">return</span> <span class="string">&#x27;Object&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;others&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 class="bamboo-h red" id="另一种思路：判断构造函数">另一种思路：判断构造函数</h4><br/><p>判断一个函数是否时数组或者对象，从另一个角度讲，就是判断变量的构造函数时Array类型还是Ojbect类型。因为一个对象的实例都是通过构造函数生成的，所以，我们可以直接判断一个变量的constructor属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">const</span> a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">constructor</span> === <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">constructor</span> === <span class="title class_">Object</span>);  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> b = &#123;<span class="attr">name</span>: <span class="string">&#x27;xx&#x27;</span>&#125;;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">constructor</span> === <span class="title class_">Array</span>); <span class="comment">// false</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">constructor</span> === <span class="title class_">Object</span>); <span class="comment">// true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们可以得到以下的封装函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">function</span> <span class="title function_">getDataType</span> (o) &#123;</span><br><span class="line">            <span class="keyword">const</span> constructor = o.<span class="property">__proto__</span>.<span class="property">constructor</span> || o.<span class="property">constructor</span></span><br><span class="line">            <span class="keyword">if</span> (constructor === <span class="title class_">Array</span>) <span class="keyword">return</span> <span class="string">&#x27;Array&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (constructor === <span class="title class_">Object</span>) <span class="keyword">return</span> <span class="string">&#x27;Object&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;others&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 class="bamboo-h warning" id="Object.prototype.toString 函数">Object.prototype.toString 函数</h2><br/><h3 class="bamboo-h " id="使用 Object.prototype.toString.call() 方法来揭示类型">使用 Object.prototype.toString.call() 方法来揭示类型</h3><br/><p>每种引用类型都会直接或者间接继承自Object类型，因此它们都包含toString()函数。不同数据类型的toString()类型返回值也不一样，所以通过toString()函数可以准确判断值的类型。</p><ul><li>对于 number 类型，结果是 [object Number]</li><li>对于 boolean 类型，结果是 [object Boolean]</li><li>对于 null：[object Null]</li><li>对于 undefined：[object Undefined]</li><li>对于数组：[object Array]</li><li>对于对象：[object Object]</li><li>……等（可自定义）</li></ul><h3 class="bamboo-h warning" id="Symbol.toStringTag">Symbol.toStringTag</h3><br/><p>可以使用特殊的对象属性 Symbol.toStringTag 自定义对象的 toString 方法的行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>]: <span class="string">&quot;User&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">alert</span>( &#123;&#125;.<span class="property">toString</span>.<span class="title function_">call</span>(user) ); <span class="comment">// [object User]</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>所以，如果我们想要获取内建对象的类型，并希望把该信息以字符串的形式返回，而不只是检查类型的话，我们可以用 {}.toString.call 替代 instanceof。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img "" class="lazyload placeholder" data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bac10e554c14ea58d2dfdcd96b153d3~tplv-k3u1fbpfcp-zoom-1.image" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="总结"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript 求数组的最大值和最小值 (6种方法)</title>
      <link href="/2021/05/29/javascript-qiu-shu-zu-de-zui-da-zhi-he-zui-xiao-zhi-6-chong-fang-fa/"/>
      <url>/2021/05/29/javascript-qiu-shu-zu-de-zui-da-zhi-he-zui-xiao-zhi-6-chong-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 class="bamboo-h " id="通过prototype属性扩展min()函数和max()函数">通过prototype属性扩展min()函数和max()函数</h2><br/><p>算法1的思路是在自定义min()和max()函数中，通过循环由第一个值依次与后面的值作比较，动态更新最大值和最小值，从而找到结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小值</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">min</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> min = <span class="variable language_">this</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> len = <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>[i] &lt; min) min = <span class="variable language_">this</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最大值</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">max</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="variable language_">this</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> len = <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>[i] &gt; max) max = <span class="variable language_">this</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">min</span>()); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">max</span>()); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><h2 class="bamboo-h " id="借助Math对象的min()函数和max()函数">借助Math对象的min()函数和max()函数</h2><br/><p>算法2的主要思路是通过apply()函数改变函数的执行体，将数组作为参数传递给apply()函数。这样数组就可以直接调用Math对象的min()函数和max()函数来获取返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property">min</span> = <span class="keyword">function</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">min</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>, array)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最大值</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property">max</span> = <span class="keyword">function</span> (<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>, array)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">min</span>(arr)); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">max</span>(arr)); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><h2 class="bamboo-h " id="算法2的优化">算法2的优化</h2><br/><p>在算法2中将min()函数和max()函数作为Array类型的静态函数，但不支持链式调用，我们可以利用对象字面量进行简化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小值</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">min</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">min</span>.<span class="title function_">apply</span>(&#123;&#125;, <span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最大值</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">max</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(&#123;&#125;, <span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">min</span>()); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">max</span>()); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><p>与算法2不同的是，在验证时，因为min()函数和max()函数属于实例方法，所以可以直接通过数组调用。<br>上面的算法代码中apply()函数传入的第一个值为{},实际表示当前执行环境的全局对象。第二个参数this指向需要处理的数组。<br>由于apply函数的特殊性第一个参数，指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。所以我们也可以将第一个参数设置为null、undefind。</p><h2 class="bamboo-h " id="借助Array类型的reduce()函数">借助Array类型的reduce()函数</h2><br/><p>算法4的主要思想是reduce()函数不设置initialValue初始值，将数组的第一个元素直接作为回调函数的第一个参数，依次与后面的值进行比较。当需要找最大值时，每轮累加器返回当前比较中大的值；当需要找最小值时，每轮累加器返回当前比较中小的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小值</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">min</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pre &lt; cur ? pre : cur</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最大值</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">max</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pre &gt; cur ? pre : cur</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">min</span>()); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">max</span>()); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><h2 class="bamboo-h " id="借助Array类型的sort()函数">借助Array类型的sort()函数</h2><br/><p>算法5的主要思想时借助数组的原生sort()函数对数组进行排序，排序完成后首尾元素即是数组的最小、最大元素。<br>默认的sort()函数在排序时时按照字母顺序排序的，数字会被按照字符串处理。例如数字 18 会被当做”18”处理，数字 6 被当”6”来处理，在排序时是按照字符串的每一位进行比较的，因为”1”比”6”要小，所以”11”排序时要比”6”小。对于数值类型的数组来说，这显然不合理。所以我们需要进行自定义排序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sortArr = arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line"><span class="comment">// 最小值</span></span><br><span class="line">sortArr[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 最大值</span></span><br><span class="line">sortArr[sortArr.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sortArr[<span class="number">0</span>]); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sortArr[sortArr.<span class="property">length</span> - <span class="number">1</span>]); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><h2 class="bamboo-h " id="借助ES6的扩展运算符">借助ES6的扩展运算符</h2><br/><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小值</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">min</span>(...arr)</span><br><span class="line"><span class="comment">// 最大值</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(...arr)</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">min</span>(...arr)); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">max</span>(...arr)); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
